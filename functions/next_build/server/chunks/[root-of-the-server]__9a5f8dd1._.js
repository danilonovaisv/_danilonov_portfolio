module.exports = [
  9254,
  (e, t, r) => {
    'use strict';
    var n = Object.defineProperty,
      i = Object.getOwnPropertyDescriptor,
      s = Object.getOwnPropertyNames,
      a = Object.prototype.hasOwnProperty,
      o = {},
      l = {
        RequestCookies: () => g,
        ResponseCookies: () => m,
        parseCookie: () => h,
        parseSetCookie: () => d,
        stringifyCookie: () => c,
      };
    for (var u in l) n(o, u, { get: l[u], enumerable: !0 });
    function c(e) {
      var t;
      let r = [
          'path' in e && e.path && `Path=${e.path}`,
          'expires' in e &&
            (e.expires || 0 === e.expires) &&
            `Expires=${('number' == typeof e.expires ? new Date(e.expires) : e.expires).toUTCString()}`,
          'maxAge' in e && 'number' == typeof e.maxAge && `Max-Age=${e.maxAge}`,
          'domain' in e && e.domain && `Domain=${e.domain}`,
          'secure' in e && e.secure && 'Secure',
          'httpOnly' in e && e.httpOnly && 'HttpOnly',
          'sameSite' in e && e.sameSite && `SameSite=${e.sameSite}`,
          'partitioned' in e && e.partitioned && 'Partitioned',
          'priority' in e && e.priority && `Priority=${e.priority}`,
        ].filter(Boolean),
        n = `${e.name}=${encodeURIComponent(null != (t = e.value) ? t : '')}`;
      return 0 === r.length ? n : `${n}; ${r.join('; ')}`;
    }
    function h(e) {
      let t = new Map();
      for (let r of e.split(/; */)) {
        if (!r) continue;
        let e = r.indexOf('=');
        if (-1 === e) {
          t.set(r, 'true');
          continue;
        }
        let [n, i] = [r.slice(0, e), r.slice(e + 1)];
        try {
          t.set(n, decodeURIComponent(null != i ? i : 'true'));
        } catch {}
      }
      return t;
    }
    function d(e) {
      if (!e) return;
      let [[t, r], ...n] = h(e),
        {
          domain: i,
          expires: s,
          httponly: a,
          maxage: o,
          path: l,
          samesite: u,
          secure: c,
          partitioned: d,
          priority: g,
        } = Object.fromEntries(
          n.map(([e, t]) => [e.toLowerCase().replace(/-/g, ''), t])
        );
      {
        var m,
          y,
          b = {
            name: t,
            value: decodeURIComponent(r),
            domain: i,
            ...(s && { expires: new Date(s) }),
            ...(a && { httpOnly: !0 }),
            ...('string' == typeof o && { maxAge: Number(o) }),
            path: l,
            ...(u && {
              sameSite: p.includes((m = (m = u).toLowerCase())) ? m : void 0,
            }),
            ...(c && { secure: !0 }),
            ...(g && {
              priority: f.includes((y = (y = g).toLowerCase())) ? y : void 0,
            }),
            ...(d && { partitioned: !0 }),
          };
        let e = {};
        for (let t in b) b[t] && (e[t] = b[t]);
        return e;
      }
    }
    t.exports = ((e, t, r, o) => {
      if ((t && 'object' == typeof t) || 'function' == typeof t)
        for (let l of s(t))
          a.call(e, l) ||
            l === r ||
            n(e, l, {
              get: () => t[l],
              enumerable: !(o = i(t, l)) || o.enumerable,
            });
      return e;
    })(n({}, '__esModule', { value: !0 }), o);
    var p = ['strict', 'lax', 'none'],
      f = ['low', 'medium', 'high'],
      g = class {
        constructor(e) {
          ((this._parsed = new Map()), (this._headers = e));
          const t = e.get('cookie');
          if (t)
            for (const [e, r] of h(t))
              this._parsed.set(e, { name: e, value: r });
        }
        [Symbol.iterator]() {
          return this._parsed[Symbol.iterator]();
        }
        get size() {
          return this._parsed.size;
        }
        get(...e) {
          let t = 'string' == typeof e[0] ? e[0] : e[0].name;
          return this._parsed.get(t);
        }
        getAll(...e) {
          var t;
          let r = Array.from(this._parsed);
          if (!e.length) return r.map(([e, t]) => t);
          let n =
            'string' == typeof e[0]
              ? e[0]
              : null == (t = e[0])
                ? void 0
                : t.name;
          return r.filter(([e]) => e === n).map(([e, t]) => t);
        }
        has(e) {
          return this._parsed.has(e);
        }
        set(...e) {
          let [t, r] = 1 === e.length ? [e[0].name, e[0].value] : e,
            n = this._parsed;
          return (
            n.set(t, { name: t, value: r }),
            this._headers.set(
              'cookie',
              Array.from(n)
                .map(([e, t]) => c(t))
                .join('; ')
            ),
            this
          );
        }
        delete(e) {
          let t = this._parsed,
            r = Array.isArray(e) ? e.map((e) => t.delete(e)) : t.delete(e);
          return (
            this._headers.set(
              'cookie',
              Array.from(t)
                .map(([e, t]) => c(t))
                .join('; ')
            ),
            r
          );
        }
        clear() {
          return (this.delete(Array.from(this._parsed.keys())), this);
        }
        [Symbol.for('edge-runtime.inspect.custom')]() {
          return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
        }
        toString() {
          return [...this._parsed.values()]
            .map((e) => `${e.name}=${encodeURIComponent(e.value)}`)
            .join('; ');
        }
      },
      m = class {
        constructor(e) {
          var t, r, n;
          ((this._parsed = new Map()), (this._headers = e));
          const i =
            null !=
            (n =
              null != (r = null == (t = e.getSetCookie) ? void 0 : t.call(e))
                ? r
                : e.get('set-cookie'))
              ? n
              : [];
          for (const e of Array.isArray(i)
            ? i
            : (function (e) {
                if (!e) return [];
                var t,
                  r,
                  n,
                  i,
                  s,
                  a = [],
                  o = 0;
                function l() {
                  for (; o < e.length && /\s/.test(e.charAt(o)); ) o += 1;
                  return o < e.length;
                }
                for (; o < e.length; ) {
                  for (t = o, s = !1; l(); )
                    if (',' === (r = e.charAt(o))) {
                      for (
                        n = o, o += 1, l(), i = o;
                        o < e.length &&
                        '=' !== (r = e.charAt(o)) &&
                        ';' !== r &&
                        ',' !== r;
                      )
                        o += 1;
                      o < e.length && '=' === e.charAt(o)
                        ? ((s = !0),
                          (o = i),
                          a.push(e.substring(t, n)),
                          (t = o))
                        : (o = n + 1);
                    } else o += 1;
                  (!s || o >= e.length) && a.push(e.substring(t, e.length));
                }
                return a;
              })(i)) {
            const t = d(e);
            t && this._parsed.set(t.name, t);
          }
        }
        get(...e) {
          let t = 'string' == typeof e[0] ? e[0] : e[0].name;
          return this._parsed.get(t);
        }
        getAll(...e) {
          var t;
          let r = Array.from(this._parsed.values());
          if (!e.length) return r;
          let n =
            'string' == typeof e[0]
              ? e[0]
              : null == (t = e[0])
                ? void 0
                : t.name;
          return r.filter((e) => e.name === n);
        }
        has(e) {
          return this._parsed.has(e);
        }
        set(...e) {
          let [t, r, n] = 1 === e.length ? [e[0].name, e[0].value, e[0]] : e,
            i = this._parsed;
          return (
            i.set(
              t,
              (function (e = { name: '', value: '' }) {
                return (
                  'number' == typeof e.expires &&
                    (e.expires = new Date(e.expires)),
                  e.maxAge &&
                    (e.expires = new Date(Date.now() + 1e3 * e.maxAge)),
                  (null === e.path || void 0 === e.path) && (e.path = '/'),
                  e
                );
              })({ name: t, value: r, ...n })
            ),
            (function (e, t) {
              for (let [, r] of (t.delete('set-cookie'), e)) {
                let e = c(r);
                t.append('set-cookie', e);
              }
            })(i, this._headers),
            this
          );
        }
        delete(...e) {
          let [t, r] = 'string' == typeof e[0] ? [e[0]] : [e[0].name, e[0]];
          return this.set({ ...r, name: t, value: '', expires: new Date(0) });
        }
        [Symbol.for('edge-runtime.inspect.custom')]() {
          return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
        }
        toString() {
          return [...this._parsed.values()].map(c).join('; ');
        }
      };
  },
  80317,
  (e) => {
    'use strict';
    function t(e) {
      return Symbol.for(e);
    }
    var r,
      n,
      i,
      s,
      a,
      o,
      l,
      u,
      c,
      h,
      d,
      p,
      f,
      g = new (function e(t) {
        var r = this;
        ((r._currentContext = t ? new Map(t) : new Map()),
          (r.getValue = function (e) {
            return r._currentContext.get(e);
          }),
          (r.setValue = function (t, n) {
            var i = new e(r._currentContext);
            return (i._currentContext.set(t, n), i);
          }),
          (r.deleteValue = function (t) {
            var n = new e(r._currentContext);
            return (n._currentContext.delete(t), n);
          }));
      })(),
      m = function (e, t) {
        var r = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var n,
          i,
          s = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(n = s.next()).done; )
            a.push(n.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            n && !n.done && (r = s.return) && r.call(s);
          } finally {
            if (i) throw i.error;
          }
        }
        return a;
      },
      y = function (e, t, r) {
        if (r || 2 == arguments.length)
          for (var n, i = 0, s = t.length; i < s; i++)
            (!n && i in t) ||
              (n || (n = Array.prototype.slice.call(t, 0, i)), (n[i] = t[i]));
        return e.concat(n || Array.prototype.slice.call(t));
      },
      b = (function () {
        function e() {}
        return (
          (e.prototype.active = function () {
            return g;
          }),
          (e.prototype.with = function (e, t, r) {
            for (var n = [], i = 3; i < arguments.length; i++)
              n[i - 3] = arguments[i];
            return t.call.apply(t, y([r], m(n), !1));
          }),
          (e.prototype.bind = function (e, t) {
            return t;
          }),
          (e.prototype.enable = function () {
            return this;
          }),
          (e.prototype.disable = function () {
            return this;
          }),
          e
        );
      })(),
      v = 'object' == typeof globalThis ? globalThis : e.g,
      w = '1.9.0',
      _ = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/,
      E = (function (e) {
        var t = new Set([e]),
          r = new Set(),
          n = e.match(_);
        if (!n)
          return function () {
            return !1;
          };
        var i = { major: +n[1], minor: +n[2], patch: +n[3], prerelease: n[4] };
        if (null != i.prerelease)
          return function (t) {
            return t === e;
          };
        function s(e) {
          return (r.add(e), !1);
        }
        return function (e) {
          if (t.has(e)) return !0;
          if (r.has(e)) return !1;
          var n = e.match(_);
          if (!n) return s(e);
          var a = {
            major: +n[1],
            minor: +n[2],
            patch: +n[3],
            prerelease: n[4],
          };
          if (null != a.prerelease || i.major !== a.major) return s(e);
          if (0 === i.major)
            return i.minor === a.minor && i.patch <= a.patch
              ? (t.add(e), !0)
              : s(e);
          return i.minor <= a.minor ? (t.add(e), !0) : s(e);
        };
      })(w),
      S = Symbol.for('opentelemetry.js.api.' + w.split('.')[0]);
    function R(e, t, r, n) {
      void 0 === n && (n = !1);
      var i,
        s = (v[S] = null != (i = v[S]) ? i : { version: w });
      if (!n && s[e]) {
        var a = Error(
          '@opentelemetry/api: Attempted duplicate registration of API: ' + e
        );
        return (r.error(a.stack || a.message), !1);
      }
      if (s.version !== w) {
        var a = Error(
          '@opentelemetry/api: Registration of version v' +
            s.version +
            ' for ' +
            e +
            ' does not match previously registered API v' +
            w
        );
        return (r.error(a.stack || a.message), !1);
      }
      return (
        (s[e] = t),
        r.debug(
          '@opentelemetry/api: Registered a global for ' + e + ' v' + w + '.'
        ),
        !0
      );
    }
    function O(e) {
      var t,
        r,
        n = null == (t = v[S]) ? void 0 : t.version;
      if (n && E(n)) return null == (r = v[S]) ? void 0 : r[e];
    }
    function T(e, t) {
      t.debug(
        '@opentelemetry/api: Unregistering a global for ' + e + ' v' + w + '.'
      );
      var r = v[S];
      r && delete r[e];
    }
    var k = function (e, t) {
        var r = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var n,
          i,
          s = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(n = s.next()).done; )
            a.push(n.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            n && !n.done && (r = s.return) && r.call(s);
          } finally {
            if (i) throw i.error;
          }
        }
        return a;
      },
      P = function (e, t, r) {
        if (r || 2 == arguments.length)
          for (var n, i = 0, s = t.length; i < s; i++)
            (!n && i in t) ||
              (n || (n = Array.prototype.slice.call(t, 0, i)), (n[i] = t[i]));
        return e.concat(n || Array.prototype.slice.call(t));
      },
      x = (function () {
        function e(e) {
          this._namespace = e.namespace || 'DiagComponentLogger';
        }
        return (
          (e.prototype.debug = function () {
            for (var e = [], t = 0; t < arguments.length; t++)
              e[t] = arguments[t];
            return A('debug', this._namespace, e);
          }),
          (e.prototype.error = function () {
            for (var e = [], t = 0; t < arguments.length; t++)
              e[t] = arguments[t];
            return A('error', this._namespace, e);
          }),
          (e.prototype.info = function () {
            for (var e = [], t = 0; t < arguments.length; t++)
              e[t] = arguments[t];
            return A('info', this._namespace, e);
          }),
          (e.prototype.warn = function () {
            for (var e = [], t = 0; t < arguments.length; t++)
              e[t] = arguments[t];
            return A('warn', this._namespace, e);
          }),
          (e.prototype.verbose = function () {
            for (var e = [], t = 0; t < arguments.length; t++)
              e[t] = arguments[t];
            return A('verbose', this._namespace, e);
          }),
          e
        );
      })();
    function A(e, t, r) {
      var n = O('diag');
      if (n) return (r.unshift(t), n[e].apply(n, P([], k(r), !1)));
    }
    (((l = r || (r = {}))[(l.NONE = 0)] = 'NONE'),
      (l[(l.ERROR = 30)] = 'ERROR'),
      (l[(l.WARN = 50)] = 'WARN'),
      (l[(l.INFO = 60)] = 'INFO'),
      (l[(l.DEBUG = 70)] = 'DEBUG'),
      (l[(l.VERBOSE = 80)] = 'VERBOSE'),
      (l[(l.ALL = 9999)] = 'ALL'));
    var C = function (e, t) {
        var r = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var n,
          i,
          s = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(n = s.next()).done; )
            a.push(n.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            n && !n.done && (r = s.return) && r.call(s);
          } finally {
            if (i) throw i.error;
          }
        }
        return a;
      },
      I = function (e, t, r) {
        if (r || 2 == arguments.length)
          for (var n, i = 0, s = t.length; i < s; i++)
            (!n && i in t) ||
              (n || (n = Array.prototype.slice.call(t, 0, i)), (n[i] = t[i]));
        return e.concat(n || Array.prototype.slice.call(t));
      },
      N = (function () {
        function e() {
          function e(e) {
            return function () {
              for (var t = [], r = 0; r < arguments.length; r++)
                t[r] = arguments[r];
              var n = O('diag');
              if (n) return n[e].apply(n, I([], C(t), !1));
            };
          }
          var t = this;
          ((t.setLogger = function (e, n) {
            if ((void 0 === n && (n = { logLevel: r.INFO }), e === t)) {
              var i,
                s,
                a,
                o = Error(
                  'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'
                );
              return (t.error(null != (i = o.stack) ? i : o.message), !1);
            }
            'number' == typeof n && (n = { logLevel: n });
            var l = O('diag'),
              u = (function (e, t) {
                function n(r, n) {
                  var i = t[r];
                  return 'function' == typeof i && e >= n
                    ? i.bind(t)
                    : function () {};
                }
                return (
                  e < r.NONE ? (e = r.NONE) : e > r.ALL && (e = r.ALL),
                  (t = t || {}),
                  {
                    error: n('error', r.ERROR),
                    warn: n('warn', r.WARN),
                    info: n('info', r.INFO),
                    debug: n('debug', r.DEBUG),
                    verbose: n('verbose', r.VERBOSE),
                  }
                );
              })(null != (s = n.logLevel) ? s : r.INFO, e);
            if (l && !n.suppressOverrideMessage) {
              var c =
                null != (a = Error().stack)
                  ? a
                  : '<failed to generate stacktrace>';
              (l.warn('Current logger will be overwritten from ' + c),
                u.warn(
                  'Current logger will overwrite one already registered from ' +
                    c
                ));
            }
            return R('diag', u, t, !0);
          }),
            (t.disable = function () {
              T('diag', t);
            }),
            (t.createComponentLogger = function (e) {
              return new x(e);
            }),
            (t.verbose = e('verbose')),
            (t.debug = e('debug')),
            (t.info = e('info')),
            (t.warn = e('warn')),
            (t.error = e('error')));
        }
        return (
          (e.instance = function () {
            return (
              this._instance || (this._instance = new e()),
              this._instance
            );
          }),
          e
        );
      })(),
      j = function (e, t) {
        var r = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var n,
          i,
          s = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(n = s.next()).done; )
            a.push(n.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            n && !n.done && (r = s.return) && r.call(s);
          } finally {
            if (i) throw i.error;
          }
        }
        return a;
      },
      D = function (e, t, r) {
        if (r || 2 == arguments.length)
          for (var n, i = 0, s = t.length; i < s; i++)
            (!n && i in t) ||
              (n || (n = Array.prototype.slice.call(t, 0, i)), (n[i] = t[i]));
        return e.concat(n || Array.prototype.slice.call(t));
      },
      $ = 'context',
      L = new b(),
      U = (function () {
        function e() {}
        return (
          (e.getInstance = function () {
            return (
              this._instance || (this._instance = new e()),
              this._instance
            );
          }),
          (e.prototype.setGlobalContextManager = function (e) {
            return R($, e, N.instance());
          }),
          (e.prototype.active = function () {
            return this._getContextManager().active();
          }),
          (e.prototype.with = function (e, t, r) {
            for (var n, i = [], s = 3; s < arguments.length; s++)
              i[s - 3] = arguments[s];
            return (n = this._getContextManager()).with.apply(
              n,
              D([e, t, r], j(i), !1)
            );
          }),
          (e.prototype.bind = function (e, t) {
            return this._getContextManager().bind(e, t);
          }),
          (e.prototype._getContextManager = function () {
            return O($) || L;
          }),
          (e.prototype.disable = function () {
            (this._getContextManager().disable(), T($, N.instance()));
          }),
          e
        );
      })(),
      M = U.getInstance(),
      B = N.instance(),
      q =
        ((u = function (e, t) {
          return (u =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (e, t) {
                e.__proto__ = t;
              }) ||
            function (e, t) {
              for (var r in t)
                Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            })(e, t);
        }),
        function (e, t) {
          if ('function' != typeof t && null !== t)
            throw TypeError(
              'Class extends value ' +
                String(t) +
                ' is not a constructor or null'
            );
          function r() {
            this.constructor = e;
          }
          (u(e, t),
            (e.prototype =
              null === t
                ? Object.create(t)
                : ((r.prototype = t.prototype), new r())));
        }),
      V = (function () {
        function e() {}
        return (
          (e.prototype.createGauge = function (e, t) {
            return ee;
          }),
          (e.prototype.createHistogram = function (e, t) {
            return et;
          }),
          (e.prototype.createCounter = function (e, t) {
            return Z;
          }),
          (e.prototype.createUpDownCounter = function (e, t) {
            return er;
          }),
          (e.prototype.createObservableGauge = function (e, t) {
            return ei;
          }),
          (e.prototype.createObservableCounter = function (e, t) {
            return en;
          }),
          (e.prototype.createObservableUpDownCounter = function (e, t) {
            return es;
          }),
          (e.prototype.addBatchObservableCallback = function (e, t) {}),
          (e.prototype.removeBatchObservableCallback = function (e) {}),
          e
        );
      })(),
      W = function () {},
      G = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (q(t, e), (t.prototype.add = function (e, t) {}), t);
      })(W),
      H = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (q(t, e), (t.prototype.add = function (e, t) {}), t);
      })(W),
      F = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (q(t, e), (t.prototype.record = function (e, t) {}), t);
      })(W),
      z = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (q(t, e), (t.prototype.record = function (e, t) {}), t);
      })(W),
      K = (function () {
        function e() {}
        return (
          (e.prototype.addCallback = function (e) {}),
          (e.prototype.removeCallback = function (e) {}),
          e
        );
      })(),
      X = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (q(t, e), t);
      })(K),
      J = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (q(t, e), t);
      })(K),
      Y = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (q(t, e), t);
      })(K),
      Q = new V(),
      Z = new G(),
      ee = new F(),
      et = new z(),
      er = new H(),
      en = new X(),
      ei = new J(),
      es = new Y();
    function ea() {
      return Q;
    }
    var eo = new ((function () {
        function e() {}
        return (
          (e.prototype.getMeter = function (e, t, r) {
            return Q;
          }),
          e
        );
      })())(),
      el = 'metrics',
      eu = (function () {
        function e() {}
        return (
          (e.getInstance = function () {
            return (
              this._instance || (this._instance = new e()),
              this._instance
            );
          }),
          (e.prototype.setGlobalMeterProvider = function (e) {
            return R(el, e, N.instance());
          }),
          (e.prototype.getMeterProvider = function () {
            return O(el) || eo;
          }),
          (e.prototype.getMeter = function (e, t, r) {
            return this.getMeterProvider().getMeter(e, t, r);
          }),
          (e.prototype.disable = function () {
            T(el, N.instance());
          }),
          e
        );
      })().getInstance(),
      ec = (function () {
        function e() {}
        return (
          (e.prototype.inject = function (e, t) {}),
          (e.prototype.extract = function (e, t) {
            return e;
          }),
          (e.prototype.fields = function () {
            return [];
          }),
          e
        );
      })(),
      eh = {
        get: function (e, t) {
          if (null != e) return e[t];
        },
        keys: function (e) {
          return null == e ? [] : Object.keys(e);
        },
      },
      ed = {
        set: function (e, t, r) {
          null != e && (e[t] = r);
        },
      },
      ep = t('OpenTelemetry Baggage Key');
    function ef(e) {
      return e.getValue(ep) || void 0;
    }
    function eg() {
      return ef(U.getInstance().active());
    }
    function em(e, t) {
      return e.setValue(ep, t);
    }
    function ey(e) {
      return e.deleteValue(ep);
    }
    var eb = function (e, t) {
        var r = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var n,
          i,
          s = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(n = s.next()).done; )
            a.push(n.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            n && !n.done && (r = s.return) && r.call(s);
          } finally {
            if (i) throw i.error;
          }
        }
        return a;
      },
      ev = function (e) {
        var t = 'function' == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          n = 0;
        if (r) return r.call(e);
        if (e && 'number' == typeof e.length)
          return {
            next: function () {
              return (
                e && n >= e.length && (e = void 0),
                { value: e && e[n++], done: !e }
              );
            },
          };
        throw TypeError(
          t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.'
        );
      },
      ew = (function () {
        function e(e) {
          this._entries = e ? new Map(e) : new Map();
        }
        return (
          (e.prototype.getEntry = function (e) {
            var t = this._entries.get(e);
            if (t) return Object.assign({}, t);
          }),
          (e.prototype.getAllEntries = function () {
            return Array.from(this._entries.entries()).map(function (e) {
              var t = eb(e, 2);
              return [t[0], t[1]];
            });
          }),
          (e.prototype.setEntry = function (t, r) {
            var n = new e(this._entries);
            return (n._entries.set(t, r), n);
          }),
          (e.prototype.removeEntry = function (t) {
            var r = new e(this._entries);
            return (r._entries.delete(t), r);
          }),
          (e.prototype.removeEntries = function () {
            for (var t, r, n = [], i = 0; i < arguments.length; i++)
              n[i] = arguments[i];
            var s = new e(this._entries);
            try {
              for (var a = ev(n), o = a.next(); !o.done; o = a.next()) {
                var l = o.value;
                s._entries.delete(l);
              }
            } catch (e) {
              t = { error: e };
            } finally {
              try {
                o && !o.done && (r = a.return) && r.call(a);
              } finally {
                if (t) throw t.error;
              }
            }
            return s;
          }),
          (e.prototype.clear = function () {
            return new e();
          }),
          e
        );
      })(),
      e_ = Symbol('BaggageEntryMetadata'),
      eE = N.instance();
    function eS(e) {
      return (void 0 === e && (e = {}), new ew(new Map(Object.entries(e))));
    }
    function eR(e) {
      return (
        'string' != typeof e &&
          (eE.error(
            'Cannot create baggage metadata from unknown type: ' + typeof e
          ),
          (e = '')),
        {
          __TYPE__: e_,
          toString: function () {
            return e;
          },
        }
      );
    }
    var eO = 'propagation',
      eT = new ec(),
      ek = (function () {
        function e() {
          ((this.createBaggage = eS),
            (this.getBaggage = ef),
            (this.getActiveBaggage = eg),
            (this.setBaggage = em),
            (this.deleteBaggage = ey));
        }
        return (
          (e.getInstance = function () {
            return (
              this._instance || (this._instance = new e()),
              this._instance
            );
          }),
          (e.prototype.setGlobalPropagator = function (e) {
            return R(eO, e, N.instance());
          }),
          (e.prototype.inject = function (e, t, r) {
            return (
              void 0 === r && (r = ed),
              this._getGlobalPropagator().inject(e, t, r)
            );
          }),
          (e.prototype.extract = function (e, t, r) {
            return (
              void 0 === r && (r = eh),
              this._getGlobalPropagator().extract(e, t, r)
            );
          }),
          (e.prototype.fields = function () {
            return this._getGlobalPropagator().fields();
          }),
          (e.prototype.disable = function () {
            T(eO, N.instance());
          }),
          (e.prototype._getGlobalPropagator = function () {
            return O(eO) || eT;
          }),
          e
        );
      })().getInstance();
    (((c = n || (n = {}))[(c.NONE = 0)] = 'NONE'),
      (c[(c.SAMPLED = 1)] = 'SAMPLED'));
    var eP = '0000000000000000',
      ex = '00000000000000000000000000000000',
      eA = { traceId: ex, spanId: eP, traceFlags: n.NONE },
      eC = (function () {
        function e(e) {
          (void 0 === e && (e = eA), (this._spanContext = e));
        }
        return (
          (e.prototype.spanContext = function () {
            return this._spanContext;
          }),
          (e.prototype.setAttribute = function (e, t) {
            return this;
          }),
          (e.prototype.setAttributes = function (e) {
            return this;
          }),
          (e.prototype.addEvent = function (e, t) {
            return this;
          }),
          (e.prototype.addLink = function (e) {
            return this;
          }),
          (e.prototype.addLinks = function (e) {
            return this;
          }),
          (e.prototype.setStatus = function (e) {
            return this;
          }),
          (e.prototype.updateName = function (e) {
            return this;
          }),
          (e.prototype.end = function (e) {}),
          (e.prototype.isRecording = function () {
            return !1;
          }),
          (e.prototype.recordException = function (e, t) {}),
          e
        );
      })(),
      eI = t('OpenTelemetry Context Key SPAN');
    function eN(e) {
      return e.getValue(eI) || void 0;
    }
    function ej() {
      return eN(U.getInstance().active());
    }
    function eD(e, t) {
      return e.setValue(eI, t);
    }
    function e$(e) {
      return e.deleteValue(eI);
    }
    function eL(e, t) {
      return eD(e, new eC(t));
    }
    function eU(e) {
      var t;
      return null == (t = eN(e)) ? void 0 : t.spanContext();
    }
    var eM = /^([0-9a-f]{32})$/i,
      eB = /^[0-9a-f]{16}$/i;
    function eq(e) {
      return eM.test(e) && e !== ex;
    }
    function eV(e) {
      return eB.test(e) && e !== eP;
    }
    function eW(e) {
      return eq(e.traceId) && eV(e.spanId);
    }
    function eG(e) {
      return new eC(e);
    }
    var eH = U.getInstance(),
      eF = (function () {
        function e() {}
        return (
          (e.prototype.startSpan = function (e, t, r) {
            if (
              (void 0 === r && (r = eH.active()), null == t ? void 0 : t.root)
            )
              return new eC();
            var n,
              i = r && eU(r);
            return 'object' == typeof (n = i) &&
              'string' == typeof n.spanId &&
              'string' == typeof n.traceId &&
              'number' == typeof n.traceFlags &&
              eW(i)
              ? new eC(i)
              : new eC();
          }),
          (e.prototype.startActiveSpan = function (e, t, r, n) {
            if (!(arguments.length < 2)) {
              2 == arguments.length
                ? (a = t)
                : 3 == arguments.length
                  ? ((i = t), (a = r))
                  : ((i = t), (s = r), (a = n));
              var i,
                s,
                a,
                o = null != s ? s : eH.active(),
                l = this.startSpan(e, i, o),
                u = eD(o, l);
              return eH.with(u, a, void 0, l);
            }
          }),
          e
        );
      })(),
      ez = new eF(),
      eK = (function () {
        function e(e, t, r, n) {
          ((this._provider = e),
            (this.name = t),
            (this.version = r),
            (this.options = n));
        }
        return (
          (e.prototype.startSpan = function (e, t, r) {
            return this._getTracer().startSpan(e, t, r);
          }),
          (e.prototype.startActiveSpan = function (e, t, r, n) {
            var i = this._getTracer();
            return Reflect.apply(i.startActiveSpan, i, arguments);
          }),
          (e.prototype._getTracer = function () {
            if (this._delegate) return this._delegate;
            var e = this._provider.getDelegateTracer(
              this.name,
              this.version,
              this.options
            );
            return e ? ((this._delegate = e), this._delegate) : ez;
          }),
          e
        );
      })(),
      eX = new ((function () {
        function e() {}
        return (
          (e.prototype.getTracer = function (e, t, r) {
            return new eF();
          }),
          e
        );
      })())(),
      eJ = (function () {
        function e() {}
        return (
          (e.prototype.getTracer = function (e, t, r) {
            var n;
            return null != (n = this.getDelegateTracer(e, t, r))
              ? n
              : new eK(this, e, t, r);
          }),
          (e.prototype.getDelegate = function () {
            var e;
            return null != (e = this._delegate) ? e : eX;
          }),
          (e.prototype.setDelegate = function (e) {
            this._delegate = e;
          }),
          (e.prototype.getDelegateTracer = function (e, t, r) {
            var n;
            return null == (n = this._delegate) ? void 0 : n.getTracer(e, t, r);
          }),
          e
        );
      })(),
      eY = 'trace',
      eQ = (function () {
        function e() {
          ((this._proxyTracerProvider = new eJ()),
            (this.wrapSpanContext = eG),
            (this.isSpanContextValid = eW),
            (this.deleteSpan = e$),
            (this.getSpan = eN),
            (this.getActiveSpan = ej),
            (this.getSpanContext = eU),
            (this.setSpan = eD),
            (this.setSpanContext = eL));
        }
        return (
          (e.getInstance = function () {
            return (
              this._instance || (this._instance = new e()),
              this._instance
            );
          }),
          (e.prototype.setGlobalTracerProvider = function (e) {
            var t = R(eY, this._proxyTracerProvider, N.instance());
            return (t && this._proxyTracerProvider.setDelegate(e), t);
          }),
          (e.prototype.getTracerProvider = function () {
            return O(eY) || this._proxyTracerProvider;
          }),
          (e.prototype.getTracer = function (e, t) {
            return this.getTracerProvider().getTracer(e, t);
          }),
          (e.prototype.disable = function () {
            (T(eY, N.instance()), (this._proxyTracerProvider = new eJ()));
          }),
          e
        );
      })().getInstance();
    let eZ = { context: M, diag: B, metrics: eu, propagation: ek, trace: eQ };
    (e.s(['default', 0, eZ], 94528), e.i(94528));
    var e0 = [
        { n: 'error', c: 'error' },
        { n: 'warn', c: 'warn' },
        { n: 'info', c: 'info' },
        { n: 'debug', c: 'debug' },
        { n: 'verbose', c: 'trace' },
      ],
      e1 = function () {
        for (var e = 0; e < e0.length; e++)
          this[e0[e].n] = (function (e) {
            return function () {
              for (var t = [], r = 0; r < arguments.length; r++)
                t[r] = arguments[r];
              if (console) {
                var n = console[e];
                if (
                  ('function' != typeof n && (n = console.log),
                  'function' == typeof n)
                )
                  return n.apply(console, t);
              }
            };
          })(e0[e].c);
      };
    (((h = i || (i = {}))[(h.INT = 0)] = 'INT'),
      (h[(h.DOUBLE = 1)] = 'DOUBLE'),
      ((d = s || (s = {}))[(d.NOT_RECORD = 0)] = 'NOT_RECORD'),
      (d[(d.RECORD = 1)] = 'RECORD'),
      (d[(d.RECORD_AND_SAMPLED = 2)] = 'RECORD_AND_SAMPLED'),
      ((p = a || (a = {}))[(p.INTERNAL = 0)] = 'INTERNAL'),
      (p[(p.SERVER = 1)] = 'SERVER'),
      (p[(p.CLIENT = 2)] = 'CLIENT'),
      (p[(p.PRODUCER = 3)] = 'PRODUCER'),
      (p[(p.CONSUMER = 4)] = 'CONSUMER'),
      ((f = o || (o = {}))[(f.UNSET = 0)] = 'UNSET'),
      (f[(f.OK = 1)] = 'OK'),
      (f[(f.ERROR = 2)] = 'ERROR'));
    var e2 = '[_0-9a-z-*/]',
      e3 = RegExp(
        '^(?:[a-z]' +
          e2 +
          '{0,255}|' +
          ('[a-z0-9]' + e2 + '{0,240}@[a-z]') +
          e2 +
          '{0,13})$'
      ),
      e4 = /^[ -~]{0,255}[!-~]$/,
      e5 = /,|=/,
      e6 = (function () {
        function e(e) {
          ((this._internalState = new Map()), e && this._parse(e));
        }
        return (
          (e.prototype.set = function (e, t) {
            var r = this._clone();
            return (
              r._internalState.has(e) && r._internalState.delete(e),
              r._internalState.set(e, t),
              r
            );
          }),
          (e.prototype.unset = function (e) {
            var t = this._clone();
            return (t._internalState.delete(e), t);
          }),
          (e.prototype.get = function (e) {
            return this._internalState.get(e);
          }),
          (e.prototype.serialize = function () {
            var e = this;
            return this._keys()
              .reduce(function (t, r) {
                return (t.push(r + '=' + e.get(r)), t);
              }, [])
              .join(',');
          }),
          (e.prototype._parse = function (e) {
            !(e.length > 512) &&
              ((this._internalState = e
                .split(',')
                .reverse()
                .reduce(function (e, t) {
                  var r = t.trim(),
                    n = r.indexOf('=');
                  if (-1 !== n) {
                    var i = r.slice(0, n),
                      s = r.slice(n + 1, t.length);
                    e3.test(i) && e4.test(s) && !e5.test(s) && e.set(i, s);
                  }
                  return e;
                }, new Map())),
              this._internalState.size > 32 &&
                (this._internalState = new Map(
                  Array.from(this._internalState.entries())
                    .reverse()
                    .slice(0, 32)
                )));
          }),
          (e.prototype._keys = function () {
            return Array.from(this._internalState.keys()).reverse();
          }),
          (e.prototype._clone = function () {
            var t = new e();
            return ((t._internalState = new Map(this._internalState)), t);
          }),
          e
        );
      })();
    function e9(e) {
      return new e6(e);
    }
    e.s(
      [
        'DiagConsoleLogger',
        () => e1,
        'DiagLogLevel',
        () => r,
        'INVALID_SPANID',
        () => eP,
        'INVALID_SPAN_CONTEXT',
        () => eA,
        'INVALID_TRACEID',
        () => ex,
        'ProxyTracer',
        () => eK,
        'ProxyTracerProvider',
        () => eJ,
        'ROOT_CONTEXT',
        () => g,
        'SamplingDecision',
        () => s,
        'SpanKind',
        () => a,
        'SpanStatusCode',
        () => o,
        'TraceFlags',
        () => n,
        'ValueType',
        () => i,
        'baggageEntryMetadataFromString',
        () => eR,
        'context',
        () => M,
        'createContextKey',
        () => t,
        'createNoopMeter',
        () => ea,
        'createTraceState',
        () => e9,
        'default',
        0,
        eZ,
        'defaultTextMapGetter',
        () => eh,
        'defaultTextMapSetter',
        () => ed,
        'diag',
        () => B,
        'isSpanContextValid',
        () => eW,
        'isValidSpanId',
        () => eV,
        'isValidTraceId',
        () => eq,
        'metrics',
        () => eu,
        'propagation',
        () => ek,
        'trace',
        () => eQ,
      ],
      80317
    );
  },
  31387,
  (e, t, r) => {
    (() => {
      'use strict';
      let r, n, i, s, a;
      var o,
        l,
        u,
        c,
        h,
        d,
        p,
        f,
        g,
        m,
        y,
        b,
        v,
        w,
        _,
        E,
        S = {
          491: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ContextAPI = void 0));
            let n = r(223),
              i = r(172),
              s = r(930),
              a = 'context',
              o = new n.NoopContextManager();
            class l {
              static getInstance() {
                return (
                  this._instance || (this._instance = new l()),
                  this._instance
                );
              }
              setGlobalContextManager(e) {
                return (0, i.registerGlobal)(a, e, s.DiagAPI.instance());
              }
              active() {
                return this._getContextManager().active();
              }
              with(e, t, r, ...n) {
                return this._getContextManager().with(e, t, r, ...n);
              }
              bind(e, t) {
                return this._getContextManager().bind(e, t);
              }
              _getContextManager() {
                return (0, i.getGlobal)(a) || o;
              }
              disable() {
                (this._getContextManager().disable(),
                  (0, i.unregisterGlobal)(a, s.DiagAPI.instance()));
              }
            }
            t.ContextAPI = l;
          },
          930: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DiagAPI = void 0));
            let n = r(56),
              i = r(912),
              s = r(957),
              a = r(172);
            class o {
              constructor() {
                function e(e) {
                  return function (...t) {
                    let r = (0, a.getGlobal)('diag');
                    if (r) return r[e](...t);
                  };
                }
                const t = this;
                ((t.setLogger = (e, r = { logLevel: s.DiagLogLevel.INFO }) => {
                  var n, o, l;
                  if (e === t) {
                    let e = Error(
                      'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'
                    );
                    return (t.error(null != (n = e.stack) ? n : e.message), !1);
                  }
                  'number' == typeof r && (r = { logLevel: r });
                  let u = (0, a.getGlobal)('diag'),
                    c = (0, i.createLogLevelDiagLogger)(
                      null != (o = r.logLevel) ? o : s.DiagLogLevel.INFO,
                      e
                    );
                  if (u && !r.suppressOverrideMessage) {
                    let e =
                      null != (l = Error().stack)
                        ? l
                        : '<failed to generate stacktrace>';
                    (u.warn(`Current logger will be overwritten from ${e}`),
                      c.warn(
                        `Current logger will overwrite one already registered from ${e}`
                      ));
                  }
                  return (0, a.registerGlobal)('diag', c, t, !0);
                }),
                  (t.disable = () => {
                    (0, a.unregisterGlobal)('diag', t);
                  }),
                  (t.createComponentLogger = (e) =>
                    new n.DiagComponentLogger(e)),
                  (t.verbose = e('verbose')),
                  (t.debug = e('debug')),
                  (t.info = e('info')),
                  (t.warn = e('warn')),
                  (t.error = e('error')));
              }
              static instance() {
                return (
                  this._instance || (this._instance = new o()),
                  this._instance
                );
              }
            }
            t.DiagAPI = o;
          },
          653: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.MetricsAPI = void 0));
            let n = r(660),
              i = r(172),
              s = r(930),
              a = 'metrics';
            class o {
              static getInstance() {
                return (
                  this._instance || (this._instance = new o()),
                  this._instance
                );
              }
              setGlobalMeterProvider(e) {
                return (0, i.registerGlobal)(a, e, s.DiagAPI.instance());
              }
              getMeterProvider() {
                return (0, i.getGlobal)(a) || n.NOOP_METER_PROVIDER;
              }
              getMeter(e, t, r) {
                return this.getMeterProvider().getMeter(e, t, r);
              }
              disable() {
                (0, i.unregisterGlobal)(a, s.DiagAPI.instance());
              }
            }
            t.MetricsAPI = o;
          },
          181: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.PropagationAPI = void 0));
            let n = r(172),
              i = r(874),
              s = r(194),
              a = r(277),
              o = r(369),
              l = r(930),
              u = 'propagation',
              c = new i.NoopTextMapPropagator();
            class h {
              constructor() {
                ((this.createBaggage = o.createBaggage),
                  (this.getBaggage = a.getBaggage),
                  (this.getActiveBaggage = a.getActiveBaggage),
                  (this.setBaggage = a.setBaggage),
                  (this.deleteBaggage = a.deleteBaggage));
              }
              static getInstance() {
                return (
                  this._instance || (this._instance = new h()),
                  this._instance
                );
              }
              setGlobalPropagator(e) {
                return (0, n.registerGlobal)(u, e, l.DiagAPI.instance());
              }
              inject(e, t, r = s.defaultTextMapSetter) {
                return this._getGlobalPropagator().inject(e, t, r);
              }
              extract(e, t, r = s.defaultTextMapGetter) {
                return this._getGlobalPropagator().extract(e, t, r);
              }
              fields() {
                return this._getGlobalPropagator().fields();
              }
              disable() {
                (0, n.unregisterGlobal)(u, l.DiagAPI.instance());
              }
              _getGlobalPropagator() {
                return (0, n.getGlobal)(u) || c;
              }
            }
            t.PropagationAPI = h;
          },
          997: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.TraceAPI = void 0));
            let n = r(172),
              i = r(846),
              s = r(139),
              a = r(607),
              o = r(930),
              l = 'trace';
            class u {
              constructor() {
                ((this._proxyTracerProvider = new i.ProxyTracerProvider()),
                  (this.wrapSpanContext = s.wrapSpanContext),
                  (this.isSpanContextValid = s.isSpanContextValid),
                  (this.deleteSpan = a.deleteSpan),
                  (this.getSpan = a.getSpan),
                  (this.getActiveSpan = a.getActiveSpan),
                  (this.getSpanContext = a.getSpanContext),
                  (this.setSpan = a.setSpan),
                  (this.setSpanContext = a.setSpanContext));
              }
              static getInstance() {
                return (
                  this._instance || (this._instance = new u()),
                  this._instance
                );
              }
              setGlobalTracerProvider(e) {
                let t = (0, n.registerGlobal)(
                  l,
                  this._proxyTracerProvider,
                  o.DiagAPI.instance()
                );
                return (t && this._proxyTracerProvider.setDelegate(e), t);
              }
              getTracerProvider() {
                return (0, n.getGlobal)(l) || this._proxyTracerProvider;
              }
              getTracer(e, t) {
                return this.getTracerProvider().getTracer(e, t);
              }
              disable() {
                ((0, n.unregisterGlobal)(l, o.DiagAPI.instance()),
                  (this._proxyTracerProvider = new i.ProxyTracerProvider()));
              }
            }
            t.TraceAPI = u;
          },
          277: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.deleteBaggage =
                t.setBaggage =
                t.getActiveBaggage =
                t.getBaggage =
                  void 0));
            let n = r(491),
              i = (0, r(780).createContextKey)('OpenTelemetry Baggage Key');
            function s(e) {
              return e.getValue(i) || void 0;
            }
            ((t.getBaggage = s),
              (t.getActiveBaggage = function () {
                return s(n.ContextAPI.getInstance().active());
              }),
              (t.setBaggage = function (e, t) {
                return e.setValue(i, t);
              }),
              (t.deleteBaggage = function (e) {
                return e.deleteValue(i);
              }));
          },
          993: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.BaggageImpl = void 0));
            class r {
              constructor(e) {
                this._entries = e ? new Map(e) : new Map();
              }
              getEntry(e) {
                let t = this._entries.get(e);
                if (t) return Object.assign({}, t);
              }
              getAllEntries() {
                return Array.from(this._entries.entries()).map(([e, t]) => [
                  e,
                  t,
                ]);
              }
              setEntry(e, t) {
                let n = new r(this._entries);
                return (n._entries.set(e, t), n);
              }
              removeEntry(e) {
                let t = new r(this._entries);
                return (t._entries.delete(e), t);
              }
              removeEntries(...e) {
                let t = new r(this._entries);
                for (let r of e) t._entries.delete(r);
                return t;
              }
              clear() {
                return new r();
              }
            }
            t.BaggageImpl = r;
          },
          830: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.baggageEntryMetadataSymbol = void 0),
              (t.baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata')));
          },
          369: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.baggageEntryMetadataFromString = t.createBaggage = void 0));
            let n = r(930),
              i = r(993),
              s = r(830),
              a = n.DiagAPI.instance();
            ((t.createBaggage = function (e = {}) {
              return new i.BaggageImpl(new Map(Object.entries(e)));
            }),
              (t.baggageEntryMetadataFromString = function (e) {
                return (
                  'string' != typeof e &&
                    (a.error(
                      `Cannot create baggage metadata from unknown type: ${typeof e}`
                    ),
                    (e = '')),
                  { __TYPE__: s.baggageEntryMetadataSymbol, toString: () => e }
                );
              }));
          },
          67: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.context = void 0),
              (t.context = r(491).ContextAPI.getInstance()));
          },
          223: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.NoopContextManager = void 0));
            let n = r(780);
            t.NoopContextManager = class {
              active() {
                return n.ROOT_CONTEXT;
              }
              with(e, t, r, ...n) {
                return t.call(r, ...n);
              }
              bind(e, t) {
                return t;
              }
              enable() {
                return this;
              }
              disable() {
                return this;
              }
            };
          },
          780: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ROOT_CONTEXT = t.createContextKey = void 0),
              (t.createContextKey = function (e) {
                return Symbol.for(e);
              }));
            class r {
              constructor(e) {
                const t = this;
                ((t._currentContext = e ? new Map(e) : new Map()),
                  (t.getValue = (e) => t._currentContext.get(e)),
                  (t.setValue = (e, n) => {
                    let i = new r(t._currentContext);
                    return (i._currentContext.set(e, n), i);
                  }),
                  (t.deleteValue = (e) => {
                    let n = new r(t._currentContext);
                    return (n._currentContext.delete(e), n);
                  }));
              }
            }
            t.ROOT_CONTEXT = new r();
          },
          506: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.diag = void 0),
              (t.diag = r(930).DiagAPI.instance()));
          },
          56: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DiagComponentLogger = void 0));
            let n = r(172);
            function i(e, t, r) {
              let i = (0, n.getGlobal)('diag');
              if (i) return (r.unshift(t), i[e](...r));
            }
            t.DiagComponentLogger = class {
              constructor(e) {
                this._namespace = e.namespace || 'DiagComponentLogger';
              }
              debug(...e) {
                return i('debug', this._namespace, e);
              }
              error(...e) {
                return i('error', this._namespace, e);
              }
              info(...e) {
                return i('info', this._namespace, e);
              }
              warn(...e) {
                return i('warn', this._namespace, e);
              }
              verbose(...e) {
                return i('verbose', this._namespace, e);
              }
            };
          },
          972: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DiagConsoleLogger = void 0));
            let r = [
              { n: 'error', c: 'error' },
              { n: 'warn', c: 'warn' },
              { n: 'info', c: 'info' },
              { n: 'debug', c: 'debug' },
              { n: 'verbose', c: 'trace' },
            ];
            t.DiagConsoleLogger = class {
              constructor() {
                for (let e = 0; e < r.length; e++)
                  this[r[e].n] = (function (e) {
                    return function (...t) {
                      if (console) {
                        let r = console[e];
                        if (
                          ('function' != typeof r && (r = console.log),
                          'function' == typeof r)
                        )
                          return r.apply(console, t);
                      }
                    };
                  })(r[e].c);
              }
            };
          },
          912: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.createLogLevelDiagLogger = void 0));
            let n = r(957);
            t.createLogLevelDiagLogger = function (e, t) {
              function r(r, n) {
                let i = t[r];
                return 'function' == typeof i && e >= n
                  ? i.bind(t)
                  : function () {};
              }
              return (
                e < n.DiagLogLevel.NONE
                  ? (e = n.DiagLogLevel.NONE)
                  : e > n.DiagLogLevel.ALL && (e = n.DiagLogLevel.ALL),
                (t = t || {}),
                {
                  error: r('error', n.DiagLogLevel.ERROR),
                  warn: r('warn', n.DiagLogLevel.WARN),
                  info: r('info', n.DiagLogLevel.INFO),
                  debug: r('debug', n.DiagLogLevel.DEBUG),
                  verbose: r('verbose', n.DiagLogLevel.VERBOSE),
                }
              );
            };
          },
          957: (e, t) => {
            var r;
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DiagLogLevel = void 0),
              ((r = t.DiagLogLevel || (t.DiagLogLevel = {}))[(r.NONE = 0)] =
                'NONE'),
              (r[(r.ERROR = 30)] = 'ERROR'),
              (r[(r.WARN = 50)] = 'WARN'),
              (r[(r.INFO = 60)] = 'INFO'),
              (r[(r.DEBUG = 70)] = 'DEBUG'),
              (r[(r.VERBOSE = 80)] = 'VERBOSE'),
              (r[(r.ALL = 9999)] = 'ALL'));
          },
          172: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.unregisterGlobal = t.getGlobal = t.registerGlobal = void 0));
            let n = r(200),
              i = r(521),
              s = r(130),
              a = i.VERSION.split('.')[0],
              o = Symbol.for(`opentelemetry.js.api.${a}`),
              l = n._globalThis;
            ((t.registerGlobal = function (e, t, r, n = !1) {
              var s;
              let a = (l[o] = null != (s = l[o]) ? s : { version: i.VERSION });
              if (!n && a[e]) {
                let t = Error(
                  `@opentelemetry/api: Attempted duplicate registration of API: ${e}`
                );
                return (r.error(t.stack || t.message), !1);
              }
              if (a.version !== i.VERSION) {
                let t = Error(
                  `@opentelemetry/api: Registration of version v${a.version} for ${e} does not match previously registered API v${i.VERSION}`
                );
                return (r.error(t.stack || t.message), !1);
              }
              return (
                (a[e] = t),
                r.debug(
                  `@opentelemetry/api: Registered a global for ${e} v${i.VERSION}.`
                ),
                !0
              );
            }),
              (t.getGlobal = function (e) {
                var t, r;
                let n = null == (t = l[o]) ? void 0 : t.version;
                if (n && (0, s.isCompatible)(n))
                  return null == (r = l[o]) ? void 0 : r[e];
              }),
              (t.unregisterGlobal = function (e, t) {
                t.debug(
                  `@opentelemetry/api: Unregistering a global for ${e} v${i.VERSION}.`
                );
                let r = l[o];
                r && delete r[e];
              }));
          },
          130: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.isCompatible = t._makeCompatibilityCheck = void 0));
            let n = r(521),
              i = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
            function s(e) {
              let t = new Set([e]),
                r = new Set(),
                n = e.match(i);
              if (!n) return () => !1;
              let s = {
                major: +n[1],
                minor: +n[2],
                patch: +n[3],
                prerelease: n[4],
              };
              if (null != s.prerelease)
                return function (t) {
                  return t === e;
                };
              function a(e) {
                return (r.add(e), !1);
              }
              return function (e) {
                if (t.has(e)) return !0;
                if (r.has(e)) return !1;
                let n = e.match(i);
                if (!n) return a(e);
                let o = {
                  major: +n[1],
                  minor: +n[2],
                  patch: +n[3],
                  prerelease: n[4],
                };
                if (null != o.prerelease || s.major !== o.major) return a(e);
                if (0 === s.major)
                  return s.minor === o.minor && s.patch <= o.patch
                    ? (t.add(e), !0)
                    : a(e);
                return s.minor <= o.minor ? (t.add(e), !0) : a(e);
              };
            }
            ((t._makeCompatibilityCheck = s), (t.isCompatible = s(n.VERSION)));
          },
          886: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.metrics = void 0),
              (t.metrics = r(653).MetricsAPI.getInstance()));
          },
          901: (e, t) => {
            var r;
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ValueType = void 0),
              ((r = t.ValueType || (t.ValueType = {}))[(r.INT = 0)] = 'INT'),
              (r[(r.DOUBLE = 1)] = 'DOUBLE'));
          },
          102: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.createNoopMeter =
                t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC =
                t.NOOP_OBSERVABLE_GAUGE_METRIC =
                t.NOOP_OBSERVABLE_COUNTER_METRIC =
                t.NOOP_UP_DOWN_COUNTER_METRIC =
                t.NOOP_HISTOGRAM_METRIC =
                t.NOOP_COUNTER_METRIC =
                t.NOOP_METER =
                t.NoopObservableUpDownCounterMetric =
                t.NoopObservableGaugeMetric =
                t.NoopObservableCounterMetric =
                t.NoopObservableMetric =
                t.NoopHistogramMetric =
                t.NoopUpDownCounterMetric =
                t.NoopCounterMetric =
                t.NoopMetric =
                t.NoopMeter =
                  void 0));
            class r {
              createHistogram(e, r) {
                return t.NOOP_HISTOGRAM_METRIC;
              }
              createCounter(e, r) {
                return t.NOOP_COUNTER_METRIC;
              }
              createUpDownCounter(e, r) {
                return t.NOOP_UP_DOWN_COUNTER_METRIC;
              }
              createObservableGauge(e, r) {
                return t.NOOP_OBSERVABLE_GAUGE_METRIC;
              }
              createObservableCounter(e, r) {
                return t.NOOP_OBSERVABLE_COUNTER_METRIC;
              }
              createObservableUpDownCounter(e, r) {
                return t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
              }
              addBatchObservableCallback(e, t) {}
              removeBatchObservableCallback(e) {}
            }
            t.NoopMeter = r;
            class n {}
            t.NoopMetric = n;
            class i extends n {
              add(e, t) {}
            }
            t.NoopCounterMetric = i;
            class s extends n {
              add(e, t) {}
            }
            t.NoopUpDownCounterMetric = s;
            class a extends n {
              record(e, t) {}
            }
            t.NoopHistogramMetric = a;
            class o {
              addCallback(e) {}
              removeCallback(e) {}
            }
            t.NoopObservableMetric = o;
            class l extends o {}
            t.NoopObservableCounterMetric = l;
            class u extends o {}
            t.NoopObservableGaugeMetric = u;
            class c extends o {}
            ((t.NoopObservableUpDownCounterMetric = c),
              (t.NOOP_METER = new r()),
              (t.NOOP_COUNTER_METRIC = new i()),
              (t.NOOP_HISTOGRAM_METRIC = new a()),
              (t.NOOP_UP_DOWN_COUNTER_METRIC = new s()),
              (t.NOOP_OBSERVABLE_COUNTER_METRIC = new l()),
              (t.NOOP_OBSERVABLE_GAUGE_METRIC = new u()),
              (t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new c()),
              (t.createNoopMeter = function () {
                return t.NOOP_METER;
              }));
          },
          660: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.NOOP_METER_PROVIDER = t.NoopMeterProvider = void 0));
            let n = r(102);
            class i {
              getMeter(e, t, r) {
                return n.NOOP_METER;
              }
            }
            ((t.NoopMeterProvider = i), (t.NOOP_METER_PROVIDER = new i()));
          },
          200: function (e, t, r) {
            var n =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (e, t, r, n) {
                      (void 0 === n && (n = r),
                        Object.defineProperty(e, n, {
                          enumerable: !0,
                          get: function () {
                            return t[r];
                          },
                        }));
                    }
                  : function (e, t, r, n) {
                      (void 0 === n && (n = r), (e[n] = t[r]));
                    }),
              i =
                (this && this.__exportStar) ||
                function (e, t) {
                  for (var r in e)
                    'default' === r ||
                      Object.prototype.hasOwnProperty.call(t, r) ||
                      n(t, e, r);
                };
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              i(r(46), t));
          },
          651: (t, r) => {
            (Object.defineProperty(r, '__esModule', { value: !0 }),
              (r._globalThis = void 0),
              (r._globalThis =
                'object' == typeof globalThis ? globalThis : e.g));
          },
          46: function (e, t, r) {
            var n =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (e, t, r, n) {
                      (void 0 === n && (n = r),
                        Object.defineProperty(e, n, {
                          enumerable: !0,
                          get: function () {
                            return t[r];
                          },
                        }));
                    }
                  : function (e, t, r, n) {
                      (void 0 === n && (n = r), (e[n] = t[r]));
                    }),
              i =
                (this && this.__exportStar) ||
                function (e, t) {
                  for (var r in e)
                    'default' === r ||
                      Object.prototype.hasOwnProperty.call(t, r) ||
                      n(t, e, r);
                };
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              i(r(651), t));
          },
          939: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.propagation = void 0),
              (t.propagation = r(181).PropagationAPI.getInstance()));
          },
          874: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.NoopTextMapPropagator = void 0),
              (t.NoopTextMapPropagator = class {
                inject(e, t) {}
                extract(e, t) {
                  return e;
                }
                fields() {
                  return [];
                }
              }));
          },
          194: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.defaultTextMapSetter = t.defaultTextMapGetter = void 0),
              (t.defaultTextMapGetter = {
                get(e, t) {
                  if (null != e) return e[t];
                },
                keys: (e) => (null == e ? [] : Object.keys(e)),
              }),
              (t.defaultTextMapSetter = {
                set(e, t, r) {
                  null != e && (e[t] = r);
                },
              }));
          },
          845: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.trace = void 0),
              (t.trace = r(997).TraceAPI.getInstance()));
          },
          403: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.NonRecordingSpan = void 0));
            let n = r(476);
            t.NonRecordingSpan = class {
              constructor(e = n.INVALID_SPAN_CONTEXT) {
                this._spanContext = e;
              }
              spanContext() {
                return this._spanContext;
              }
              setAttribute(e, t) {
                return this;
              }
              setAttributes(e) {
                return this;
              }
              addEvent(e, t) {
                return this;
              }
              setStatus(e) {
                return this;
              }
              updateName(e) {
                return this;
              }
              end(e) {}
              isRecording() {
                return !1;
              }
              recordException(e, t) {}
            };
          },
          614: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.NoopTracer = void 0));
            let n = r(491),
              i = r(607),
              s = r(403),
              a = r(139),
              o = n.ContextAPI.getInstance();
            t.NoopTracer = class {
              startSpan(e, t, r = o.active()) {
                var n;
                if (null == t ? void 0 : t.root)
                  return new s.NonRecordingSpan();
                let l = r && (0, i.getSpanContext)(r);
                return 'object' == typeof (n = l) &&
                  'string' == typeof n.spanId &&
                  'string' == typeof n.traceId &&
                  'number' == typeof n.traceFlags &&
                  (0, a.isSpanContextValid)(l)
                  ? new s.NonRecordingSpan(l)
                  : new s.NonRecordingSpan();
              }
              startActiveSpan(e, t, r, n) {
                let s, a, l;
                if (arguments.length < 2) return;
                2 == arguments.length
                  ? (l = t)
                  : 3 == arguments.length
                    ? ((s = t), (l = r))
                    : ((s = t), (a = r), (l = n));
                let u = null != a ? a : o.active(),
                  c = this.startSpan(e, s, u),
                  h = (0, i.setSpan)(u, c);
                return o.with(h, l, void 0, c);
              }
            };
          },
          124: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.NoopTracerProvider = void 0));
            let n = r(614);
            t.NoopTracerProvider = class {
              getTracer(e, t, r) {
                return new n.NoopTracer();
              }
            };
          },
          125: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ProxyTracer = void 0));
            let n = new (r(614).NoopTracer)();
            t.ProxyTracer = class {
              constructor(e, t, r, n) {
                ((this._provider = e),
                  (this.name = t),
                  (this.version = r),
                  (this.options = n));
              }
              startSpan(e, t, r) {
                return this._getTracer().startSpan(e, t, r);
              }
              startActiveSpan(e, t, r, n) {
                let i = this._getTracer();
                return Reflect.apply(i.startActiveSpan, i, arguments);
              }
              _getTracer() {
                if (this._delegate) return this._delegate;
                let e = this._provider.getDelegateTracer(
                  this.name,
                  this.version,
                  this.options
                );
                return e ? ((this._delegate = e), this._delegate) : n;
              }
            };
          },
          846: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ProxyTracerProvider = void 0));
            let n = r(125),
              i = new (r(124).NoopTracerProvider)();
            t.ProxyTracerProvider = class {
              getTracer(e, t, r) {
                var i;
                return null != (i = this.getDelegateTracer(e, t, r))
                  ? i
                  : new n.ProxyTracer(this, e, t, r);
              }
              getDelegate() {
                var e;
                return null != (e = this._delegate) ? e : i;
              }
              setDelegate(e) {
                this._delegate = e;
              }
              getDelegateTracer(e, t, r) {
                var n;
                return null == (n = this._delegate)
                  ? void 0
                  : n.getTracer(e, t, r);
              }
            };
          },
          996: (e, t) => {
            var r;
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.SamplingDecision = void 0),
              ((r = t.SamplingDecision || (t.SamplingDecision = {}))[
                (r.NOT_RECORD = 0)
              ] = 'NOT_RECORD'),
              (r[(r.RECORD = 1)] = 'RECORD'),
              (r[(r.RECORD_AND_SAMPLED = 2)] = 'RECORD_AND_SAMPLED'));
          },
          607: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.getSpanContext =
                t.setSpanContext =
                t.deleteSpan =
                t.setSpan =
                t.getActiveSpan =
                t.getSpan =
                  void 0));
            let n = r(780),
              i = r(403),
              s = r(491),
              a = (0, n.createContextKey)('OpenTelemetry Context Key SPAN');
            function o(e) {
              return e.getValue(a) || void 0;
            }
            function l(e, t) {
              return e.setValue(a, t);
            }
            ((t.getSpan = o),
              (t.getActiveSpan = function () {
                return o(s.ContextAPI.getInstance().active());
              }),
              (t.setSpan = l),
              (t.deleteSpan = function (e) {
                return e.deleteValue(a);
              }),
              (t.setSpanContext = function (e, t) {
                return l(e, new i.NonRecordingSpan(t));
              }),
              (t.getSpanContext = function (e) {
                var t;
                return null == (t = o(e)) ? void 0 : t.spanContext();
              }));
          },
          325: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.TraceStateImpl = void 0));
            let n = r(564);
            class i {
              constructor(e) {
                ((this._internalState = new Map()), e && this._parse(e));
              }
              set(e, t) {
                let r = this._clone();
                return (
                  r._internalState.has(e) && r._internalState.delete(e),
                  r._internalState.set(e, t),
                  r
                );
              }
              unset(e) {
                let t = this._clone();
                return (t._internalState.delete(e), t);
              }
              get(e) {
                return this._internalState.get(e);
              }
              serialize() {
                return this._keys()
                  .reduce((e, t) => (e.push(t + '=' + this.get(t)), e), [])
                  .join(',');
              }
              _parse(e) {
                !(e.length > 512) &&
                  ((this._internalState = e
                    .split(',')
                    .reverse()
                    .reduce((e, t) => {
                      let r = t.trim(),
                        i = r.indexOf('=');
                      if (-1 !== i) {
                        let s = r.slice(0, i),
                          a = r.slice(i + 1, t.length);
                        (0, n.validateKey)(s) &&
                          (0, n.validateValue)(a) &&
                          e.set(s, a);
                      }
                      return e;
                    }, new Map())),
                  this._internalState.size > 32 &&
                    (this._internalState = new Map(
                      Array.from(this._internalState.entries())
                        .reverse()
                        .slice(0, 32)
                    )));
              }
              _keys() {
                return Array.from(this._internalState.keys()).reverse();
              }
              _clone() {
                let e = new i();
                return ((e._internalState = new Map(this._internalState)), e);
              }
            }
            t.TraceStateImpl = i;
          },
          564: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.validateValue = t.validateKey = void 0));
            let r = '[_0-9a-z-*/]',
              n = `[a-z]${r}{0,255}`,
              i = `[a-z0-9]${r}{0,240}@[a-z]${r}{0,13}`,
              s = RegExp(`^(?:${n}|${i})$`),
              a = /^[ -~]{0,255}[!-~]$/,
              o = /,|=/;
            ((t.validateKey = function (e) {
              return s.test(e);
            }),
              (t.validateValue = function (e) {
                return a.test(e) && !o.test(e);
              }));
          },
          98: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.createTraceState = void 0));
            let n = r(325);
            t.createTraceState = function (e) {
              return new n.TraceStateImpl(e);
            };
          },
          476: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.INVALID_SPAN_CONTEXT =
                t.INVALID_TRACEID =
                t.INVALID_SPANID =
                  void 0));
            let n = r(475);
            ((t.INVALID_SPANID = '0000000000000000'),
              (t.INVALID_TRACEID = '00000000000000000000000000000000'),
              (t.INVALID_SPAN_CONTEXT = {
                traceId: t.INVALID_TRACEID,
                spanId: t.INVALID_SPANID,
                traceFlags: n.TraceFlags.NONE,
              }));
          },
          357: (e, t) => {
            var r;
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.SpanKind = void 0),
              ((r = t.SpanKind || (t.SpanKind = {}))[(r.INTERNAL = 0)] =
                'INTERNAL'),
              (r[(r.SERVER = 1)] = 'SERVER'),
              (r[(r.CLIENT = 2)] = 'CLIENT'),
              (r[(r.PRODUCER = 3)] = 'PRODUCER'),
              (r[(r.CONSUMER = 4)] = 'CONSUMER'));
          },
          139: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.wrapSpanContext =
                t.isSpanContextValid =
                t.isValidSpanId =
                t.isValidTraceId =
                  void 0));
            let n = r(476),
              i = r(403),
              s = /^([0-9a-f]{32})$/i,
              a = /^[0-9a-f]{16}$/i;
            function o(e) {
              return s.test(e) && e !== n.INVALID_TRACEID;
            }
            function l(e) {
              return a.test(e) && e !== n.INVALID_SPANID;
            }
            ((t.isValidTraceId = o),
              (t.isValidSpanId = l),
              (t.isSpanContextValid = function (e) {
                return o(e.traceId) && l(e.spanId);
              }),
              (t.wrapSpanContext = function (e) {
                return new i.NonRecordingSpan(e);
              }));
          },
          847: (e, t) => {
            var r;
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.SpanStatusCode = void 0),
              ((r = t.SpanStatusCode || (t.SpanStatusCode = {}))[
                (r.UNSET = 0)
              ] = 'UNSET'),
              (r[(r.OK = 1)] = 'OK'),
              (r[(r.ERROR = 2)] = 'ERROR'));
          },
          475: (e, t) => {
            var r;
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.TraceFlags = void 0),
              ((r = t.TraceFlags || (t.TraceFlags = {}))[(r.NONE = 0)] =
                'NONE'),
              (r[(r.SAMPLED = 1)] = 'SAMPLED'));
          },
          521: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.VERSION = void 0),
              (t.VERSION = '1.6.0'));
          },
        },
        R = {};
      function O(e) {
        var t = R[e];
        if (void 0 !== t) return t.exports;
        var r = (R[e] = { exports: {} }),
          n = !0;
        try {
          (S[e].call(r.exports, r, r.exports, O), (n = !1));
        } finally {
          n && delete R[e];
        }
        return r.exports;
      }
      O.ab = '/ROOT/node_modules/next/dist/compiled/@opentelemetry/api/';
      var T = {};
      (Object.defineProperty(T, '__esModule', { value: !0 }),
        (T.trace =
          T.propagation =
          T.metrics =
          T.diag =
          T.context =
          T.INVALID_SPAN_CONTEXT =
          T.INVALID_TRACEID =
          T.INVALID_SPANID =
          T.isValidSpanId =
          T.isValidTraceId =
          T.isSpanContextValid =
          T.createTraceState =
          T.TraceFlags =
          T.SpanStatusCode =
          T.SpanKind =
          T.SamplingDecision =
          T.ProxyTracerProvider =
          T.ProxyTracer =
          T.defaultTextMapSetter =
          T.defaultTextMapGetter =
          T.ValueType =
          T.createNoopMeter =
          T.DiagLogLevel =
          T.DiagConsoleLogger =
          T.ROOT_CONTEXT =
          T.createContextKey =
          T.baggageEntryMetadataFromString =
            void 0),
        (o = O(369)),
        Object.defineProperty(T, 'baggageEntryMetadataFromString', {
          enumerable: !0,
          get: function () {
            return o.baggageEntryMetadataFromString;
          },
        }),
        (l = O(780)),
        Object.defineProperty(T, 'createContextKey', {
          enumerable: !0,
          get: function () {
            return l.createContextKey;
          },
        }),
        Object.defineProperty(T, 'ROOT_CONTEXT', {
          enumerable: !0,
          get: function () {
            return l.ROOT_CONTEXT;
          },
        }),
        (u = O(972)),
        Object.defineProperty(T, 'DiagConsoleLogger', {
          enumerable: !0,
          get: function () {
            return u.DiagConsoleLogger;
          },
        }),
        (c = O(957)),
        Object.defineProperty(T, 'DiagLogLevel', {
          enumerable: !0,
          get: function () {
            return c.DiagLogLevel;
          },
        }),
        (h = O(102)),
        Object.defineProperty(T, 'createNoopMeter', {
          enumerable: !0,
          get: function () {
            return h.createNoopMeter;
          },
        }),
        (d = O(901)),
        Object.defineProperty(T, 'ValueType', {
          enumerable: !0,
          get: function () {
            return d.ValueType;
          },
        }),
        (p = O(194)),
        Object.defineProperty(T, 'defaultTextMapGetter', {
          enumerable: !0,
          get: function () {
            return p.defaultTextMapGetter;
          },
        }),
        Object.defineProperty(T, 'defaultTextMapSetter', {
          enumerable: !0,
          get: function () {
            return p.defaultTextMapSetter;
          },
        }),
        (f = O(125)),
        Object.defineProperty(T, 'ProxyTracer', {
          enumerable: !0,
          get: function () {
            return f.ProxyTracer;
          },
        }),
        (g = O(846)),
        Object.defineProperty(T, 'ProxyTracerProvider', {
          enumerable: !0,
          get: function () {
            return g.ProxyTracerProvider;
          },
        }),
        (m = O(996)),
        Object.defineProperty(T, 'SamplingDecision', {
          enumerable: !0,
          get: function () {
            return m.SamplingDecision;
          },
        }),
        (y = O(357)),
        Object.defineProperty(T, 'SpanKind', {
          enumerable: !0,
          get: function () {
            return y.SpanKind;
          },
        }),
        (b = O(847)),
        Object.defineProperty(T, 'SpanStatusCode', {
          enumerable: !0,
          get: function () {
            return b.SpanStatusCode;
          },
        }),
        (v = O(475)),
        Object.defineProperty(T, 'TraceFlags', {
          enumerable: !0,
          get: function () {
            return v.TraceFlags;
          },
        }),
        (w = O(98)),
        Object.defineProperty(T, 'createTraceState', {
          enumerable: !0,
          get: function () {
            return w.createTraceState;
          },
        }),
        (_ = O(139)),
        Object.defineProperty(T, 'isSpanContextValid', {
          enumerable: !0,
          get: function () {
            return _.isSpanContextValid;
          },
        }),
        Object.defineProperty(T, 'isValidTraceId', {
          enumerable: !0,
          get: function () {
            return _.isValidTraceId;
          },
        }),
        Object.defineProperty(T, 'isValidSpanId', {
          enumerable: !0,
          get: function () {
            return _.isValidSpanId;
          },
        }),
        (E = O(476)),
        Object.defineProperty(T, 'INVALID_SPANID', {
          enumerable: !0,
          get: function () {
            return E.INVALID_SPANID;
          },
        }),
        Object.defineProperty(T, 'INVALID_TRACEID', {
          enumerable: !0,
          get: function () {
            return E.INVALID_TRACEID;
          },
        }),
        Object.defineProperty(T, 'INVALID_SPAN_CONTEXT', {
          enumerable: !0,
          get: function () {
            return E.INVALID_SPAN_CONTEXT;
          },
        }),
        (r = O(67)),
        Object.defineProperty(T, 'context', {
          enumerable: !0,
          get: function () {
            return r.context;
          },
        }),
        (n = O(506)),
        Object.defineProperty(T, 'diag', {
          enumerable: !0,
          get: function () {
            return n.diag;
          },
        }),
        (i = O(886)),
        Object.defineProperty(T, 'metrics', {
          enumerable: !0,
          get: function () {
            return i.metrics;
          },
        }),
        (s = O(939)),
        Object.defineProperty(T, 'propagation', {
          enumerable: !0,
          get: function () {
            return s.propagation;
          },
        }),
        (a = O(845)),
        Object.defineProperty(T, 'trace', {
          enumerable: !0,
          get: function () {
            return a.trace;
          },
        }),
        (T.default = {
          context: r.context,
          diag: n.diag,
          metrics: i.metrics,
          propagation: s.propagation,
          trace: a.trace,
        }),
        (t.exports = T));
    })();
  },
  62712,
  (e, t, r) => {
    (() => {
      'use strict';
      'u' > typeof __nccwpck_require__ &&
        (__nccwpck_require__.ab =
          '/ROOT/node_modules/next/dist/compiled/cookie/');
      var e,
        r,
        n,
        i,
        s = {};
      ((s.parse = function (t, r) {
        if ('string' != typeof t)
          throw TypeError('argument str must be a string');
        for (
          var i = {}, s = t.split(n), a = (r || {}).decode || e, o = 0;
          o < s.length;
          o++
        ) {
          var l = s[o],
            u = l.indexOf('=');
          if (!(u < 0)) {
            var c = l.substr(0, u).trim(),
              h = l.substr(++u, l.length).trim();
            ('"' == h[0] && (h = h.slice(1, -1)),
              void 0 == i[c] &&
                (i[c] = (function (e, t) {
                  try {
                    return t(e);
                  } catch (t) {
                    return e;
                  }
                })(h, a)));
          }
        }
        return i;
      }),
        (s.serialize = function (e, t, n) {
          var s = n || {},
            a = s.encode || r;
          if ('function' != typeof a)
            throw TypeError('option encode is invalid');
          if (!i.test(e)) throw TypeError('argument name is invalid');
          var o = a(t);
          if (o && !i.test(o)) throw TypeError('argument val is invalid');
          var l = e + '=' + o;
          if (null != s.maxAge) {
            var u = s.maxAge - 0;
            if (isNaN(u) || !isFinite(u))
              throw TypeError('option maxAge is invalid');
            l += '; Max-Age=' + Math.floor(u);
          }
          if (s.domain) {
            if (!i.test(s.domain)) throw TypeError('option domain is invalid');
            l += '; Domain=' + s.domain;
          }
          if (s.path) {
            if (!i.test(s.path)) throw TypeError('option path is invalid');
            l += '; Path=' + s.path;
          }
          if (s.expires) {
            if ('function' != typeof s.expires.toUTCString)
              throw TypeError('option expires is invalid');
            l += '; Expires=' + s.expires.toUTCString();
          }
          if (
            (s.httpOnly && (l += '; HttpOnly'),
            s.secure && (l += '; Secure'),
            s.sameSite)
          )
            switch (
              'string' == typeof s.sameSite
                ? s.sameSite.toLowerCase()
                : s.sameSite
            ) {
              case !0:
              case 'strict':
                l += '; SameSite=Strict';
                break;
              case 'lax':
                l += '; SameSite=Lax';
                break;
              case 'none':
                l += '; SameSite=None';
                break;
              default:
                throw TypeError('option sameSite is invalid');
            }
          return l;
        }),
        (e = decodeURIComponent),
        (r = encodeURIComponent),
        (n = /; */),
        (i = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/),
        (t.exports = s));
    })();
  },
  47413,
  (e, t, r) => {
    (() => {
      'use strict';
      let e, r, n, i, s;
      var a = {
          993: (e) => {
            var t = Object.prototype.hasOwnProperty,
              r = '~';
            function n() {}
            function i(e, t, r) {
              ((this.fn = e), (this.context = t), (this.once = r || !1));
            }
            function s(e, t, n, s, a) {
              if ('function' != typeof n)
                throw TypeError('The listener must be a function');
              var o = new i(n, s || e, a),
                l = r ? r + t : t;
              return (
                e._events[l]
                  ? e._events[l].fn
                    ? (e._events[l] = [e._events[l], o])
                    : e._events[l].push(o)
                  : ((e._events[l] = o), e._eventsCount++),
                e
              );
            }
            function a(e, t) {
              0 == --e._eventsCount
                ? (e._events = new n())
                : delete e._events[t];
            }
            function o() {
              ((this._events = new n()), (this._eventsCount = 0));
            }
            (Object.create &&
              ((n.prototype = Object.create(null)),
              new n().__proto__ || (r = !1)),
              (o.prototype.eventNames = function () {
                var e,
                  n,
                  i = [];
                if (0 === this._eventsCount) return i;
                for (n in (e = this._events))
                  t.call(e, n) && i.push(r ? n.slice(1) : n);
                return Object.getOwnPropertySymbols
                  ? i.concat(Object.getOwnPropertySymbols(e))
                  : i;
              }),
              (o.prototype.listeners = function (e) {
                var t = r ? r + e : e,
                  n = this._events[t];
                if (!n) return [];
                if (n.fn) return [n.fn];
                for (var i = 0, s = n.length, a = Array(s); i < s; i++)
                  a[i] = n[i].fn;
                return a;
              }),
              (o.prototype.listenerCount = function (e) {
                var t = r ? r + e : e,
                  n = this._events[t];
                return n ? (n.fn ? 1 : n.length) : 0;
              }),
              (o.prototype.emit = function (e, t, n, i, s, a) {
                var o = r ? r + e : e;
                if (!this._events[o]) return !1;
                var l,
                  u,
                  c = this._events[o],
                  h = arguments.length;
                if (c.fn) {
                  switch (
                    (c.once && this.removeListener(e, c.fn, void 0, !0), h)
                  ) {
                    case 1:
                      return (c.fn.call(c.context), !0);
                    case 2:
                      return (c.fn.call(c.context, t), !0);
                    case 3:
                      return (c.fn.call(c.context, t, n), !0);
                    case 4:
                      return (c.fn.call(c.context, t, n, i), !0);
                    case 5:
                      return (c.fn.call(c.context, t, n, i, s), !0);
                    case 6:
                      return (c.fn.call(c.context, t, n, i, s, a), !0);
                  }
                  for (u = 1, l = Array(h - 1); u < h; u++)
                    l[u - 1] = arguments[u];
                  c.fn.apply(c.context, l);
                } else {
                  var d,
                    p = c.length;
                  for (u = 0; u < p; u++)
                    switch (
                      (c[u].once && this.removeListener(e, c[u].fn, void 0, !0),
                      h)
                    ) {
                      case 1:
                        c[u].fn.call(c[u].context);
                        break;
                      case 2:
                        c[u].fn.call(c[u].context, t);
                        break;
                      case 3:
                        c[u].fn.call(c[u].context, t, n);
                        break;
                      case 4:
                        c[u].fn.call(c[u].context, t, n, i);
                        break;
                      default:
                        if (!l)
                          for (d = 1, l = Array(h - 1); d < h; d++)
                            l[d - 1] = arguments[d];
                        c[u].fn.apply(c[u].context, l);
                    }
                }
                return !0;
              }),
              (o.prototype.on = function (e, t, r) {
                return s(this, e, t, r, !1);
              }),
              (o.prototype.once = function (e, t, r) {
                return s(this, e, t, r, !0);
              }),
              (o.prototype.removeListener = function (e, t, n, i) {
                var s = r ? r + e : e;
                if (!this._events[s]) return this;
                if (!t) return (a(this, s), this);
                var o = this._events[s];
                if (o.fn)
                  o.fn !== t ||
                    (i && !o.once) ||
                    (n && o.context !== n) ||
                    a(this, s);
                else {
                  for (var l = 0, u = [], c = o.length; l < c; l++)
                    (o[l].fn !== t ||
                      (i && !o[l].once) ||
                      (n && o[l].context !== n)) &&
                      u.push(o[l]);
                  u.length
                    ? (this._events[s] = 1 === u.length ? u[0] : u)
                    : a(this, s);
                }
                return this;
              }),
              (o.prototype.removeAllListeners = function (e) {
                var t;
                return (
                  e
                    ? ((t = r ? r + e : e), this._events[t] && a(this, t))
                    : ((this._events = new n()), (this._eventsCount = 0)),
                  this
                );
              }),
              (o.prototype.off = o.prototype.removeListener),
              (o.prototype.addListener = o.prototype.on),
              (o.prefixed = r),
              (o.EventEmitter = o),
              (e.exports = o));
          },
          213: (e) => {
            e.exports = (e, t) => (
              (t = t || (() => {})),
              e.then(
                (e) =>
                  new Promise((e) => {
                    e(t());
                  }).then(() => e),
                (e) =>
                  new Promise((e) => {
                    e(t());
                  }).then(() => {
                    throw e;
                  })
              )
            );
          },
          574: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.default = function (e, t, r) {
                let n = 0,
                  i = e.length;
                for (; i > 0; ) {
                  let s = (i / 2) | 0,
                    a = n + s;
                  0 >= r(e[a], t) ? ((n = ++a), (i -= s + 1)) : (i = s);
                }
                return n;
              }));
          },
          821: (e, t, r) => {
            Object.defineProperty(t, '__esModule', { value: !0 });
            let n = r(574);
            t.default = class {
              constructor() {
                this._queue = [];
              }
              enqueue(e, t) {
                let r = {
                  priority: (t = Object.assign({ priority: 0 }, t)).priority,
                  run: e,
                };
                if (
                  this.size &&
                  this._queue[this.size - 1].priority >= t.priority
                )
                  return void this._queue.push(r);
                let i = n.default(
                  this._queue,
                  r,
                  (e, t) => t.priority - e.priority
                );
                this._queue.splice(i, 0, r);
              }
              dequeue() {
                let e = this._queue.shift();
                return null == e ? void 0 : e.run;
              }
              filter(e) {
                return this._queue
                  .filter((t) => t.priority === e.priority)
                  .map((e) => e.run);
              }
              get size() {
                return this._queue.length;
              }
            };
          },
          816: (e, t, r) => {
            let n = r(213);
            class i extends Error {
              constructor(e) {
                (super(e), (this.name = 'TimeoutError'));
              }
            }
            let s = (e, t, r) =>
              new Promise((s, a) => {
                if ('number' != typeof t || t < 0)
                  throw TypeError(
                    'Expected `milliseconds` to be a positive number'
                  );
                if (t === 1 / 0) return void s(e);
                let o = setTimeout(() => {
                  if ('function' == typeof r) {
                    try {
                      s(r());
                    } catch (e) {
                      a(e);
                    }
                    return;
                  }
                  let n =
                      'string' == typeof r
                        ? r
                        : `Promise timed out after ${t} milliseconds`,
                    o = r instanceof Error ? r : new i(n);
                  ('function' == typeof e.cancel && e.cancel(), a(o));
                }, t);
                n(e.then(s, a), () => {
                  clearTimeout(o);
                });
              });
            ((e.exports = s),
              (e.exports.default = s),
              (e.exports.TimeoutError = i));
          },
        },
        o = {};
      function l(e) {
        var t = o[e];
        if (void 0 !== t) return t.exports;
        var r = (o[e] = { exports: {} }),
          n = !0;
        try {
          (a[e](r, r.exports, l), (n = !1));
        } finally {
          n && delete o[e];
        }
        return r.exports;
      }
      l.ab = '/ROOT/node_modules/next/dist/compiled/p-queue/';
      var u = {};
      (Object.defineProperty(u, '__esModule', { value: !0 }),
        (e = l(993)),
        (r = l(816)),
        (n = l(821)),
        (i = () => {}),
        (s = new r.TimeoutError()),
        (u.default = class extends e {
          constructor(e) {
            var t, r, s, a;
            if (
              (super(),
              (this._intervalCount = 0),
              (this._intervalEnd = 0),
              (this._pendingCount = 0),
              (this._resolveEmpty = i),
              (this._resolveIdle = i),
              !(
                'number' ==
                  typeof (e = Object.assign(
                    {
                      carryoverConcurrencyCount: !1,
                      intervalCap: 1 / 0,
                      interval: 0,
                      concurrency: 1 / 0,
                      autoStart: !0,
                      queueClass: n.default,
                    },
                    e
                  )).intervalCap && e.intervalCap >= 1
              ))
            )
              throw TypeError(
                `Expected \`intervalCap\` to be a number from 1 and up, got \`${null != (r = null == (t = e.intervalCap) ? void 0 : t.toString()) ? r : ''}\` (${typeof e.intervalCap})`
              );
            if (
              void 0 === e.interval ||
              !(Number.isFinite(e.interval) && e.interval >= 0)
            )
              throw TypeError(
                `Expected \`interval\` to be a finite number >= 0, got \`${null != (a = null == (s = e.interval) ? void 0 : s.toString()) ? a : ''}\` (${typeof e.interval})`
              );
            ((this._carryoverConcurrencyCount = e.carryoverConcurrencyCount),
              (this._isIntervalIgnored =
                e.intervalCap === 1 / 0 || 0 === e.interval),
              (this._intervalCap = e.intervalCap),
              (this._interval = e.interval),
              (this._queue = new e.queueClass()),
              (this._queueClass = e.queueClass),
              (this.concurrency = e.concurrency),
              (this._timeout = e.timeout),
              (this._throwOnTimeout = !0 === e.throwOnTimeout),
              (this._isPaused = !1 === e.autoStart));
          }
          get _doesIntervalAllowAnother() {
            return (
              this._isIntervalIgnored || this._intervalCount < this._intervalCap
            );
          }
          get _doesConcurrentAllowAnother() {
            return this._pendingCount < this._concurrency;
          }
          _next() {
            (this._pendingCount--,
              this._tryToStartAnother(),
              this.emit('next'));
          }
          _resolvePromises() {
            (this._resolveEmpty(),
              (this._resolveEmpty = i),
              0 === this._pendingCount &&
                (this._resolveIdle(),
                (this._resolveIdle = i),
                this.emit('idle')));
          }
          _onResumeInterval() {
            (this._onInterval(),
              this._initializeIntervalIfNeeded(),
              (this._timeoutId = void 0));
          }
          _isIntervalPaused() {
            let e = Date.now();
            if (void 0 === this._intervalId) {
              let t = this._intervalEnd - e;
              if (!(t < 0))
                return (
                  void 0 === this._timeoutId &&
                    (this._timeoutId = setTimeout(() => {
                      this._onResumeInterval();
                    }, t)),
                  !0
                );
              this._intervalCount = this._carryoverConcurrencyCount
                ? this._pendingCount
                : 0;
            }
            return !1;
          }
          _tryToStartAnother() {
            if (0 === this._queue.size)
              return (
                this._intervalId && clearInterval(this._intervalId),
                (this._intervalId = void 0),
                this._resolvePromises(),
                !1
              );
            if (!this._isPaused) {
              let e = !this._isIntervalPaused();
              if (
                this._doesIntervalAllowAnother &&
                this._doesConcurrentAllowAnother
              ) {
                let t = this._queue.dequeue();
                return (
                  !!t &&
                  (this.emit('active'),
                  t(),
                  e && this._initializeIntervalIfNeeded(),
                  !0)
                );
              }
            }
            return !1;
          }
          _initializeIntervalIfNeeded() {
            this._isIntervalIgnored ||
              void 0 !== this._intervalId ||
              ((this._intervalId = setInterval(() => {
                this._onInterval();
              }, this._interval)),
              (this._intervalEnd = Date.now() + this._interval));
          }
          _onInterval() {
            (0 === this._intervalCount &&
              0 === this._pendingCount &&
              this._intervalId &&
              (clearInterval(this._intervalId), (this._intervalId = void 0)),
              (this._intervalCount = this._carryoverConcurrencyCount
                ? this._pendingCount
                : 0),
              this._processQueue());
          }
          _processQueue() {
            for (; this._tryToStartAnother(); );
          }
          get concurrency() {
            return this._concurrency;
          }
          set concurrency(e) {
            if (!('number' == typeof e && e >= 1))
              throw TypeError(
                `Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`
              );
            ((this._concurrency = e), this._processQueue());
          }
          async add(e, t = {}) {
            return new Promise((n, i) => {
              let a = async () => {
                (this._pendingCount++, this._intervalCount++);
                try {
                  let a =
                    void 0 === this._timeout && void 0 === t.timeout
                      ? e()
                      : r.default(
                          Promise.resolve(e()),
                          void 0 === t.timeout ? this._timeout : t.timeout,
                          () => {
                            (void 0 === t.throwOnTimeout
                              ? this._throwOnTimeout
                              : t.throwOnTimeout) && i(s);
                          }
                        );
                  n(await a);
                } catch (e) {
                  i(e);
                }
                this._next();
              };
              (this._queue.enqueue(a, t),
                this._tryToStartAnother(),
                this.emit('add'));
            });
          }
          async addAll(e, t) {
            return Promise.all(e.map(async (e) => this.add(e, t)));
          }
          start() {
            return (
              this._isPaused && ((this._isPaused = !1), this._processQueue()),
              this
            );
          }
          pause() {
            this._isPaused = !0;
          }
          clear() {
            this._queue = new this._queueClass();
          }
          async onEmpty() {
            if (0 !== this._queue.size)
              return new Promise((e) => {
                let t = this._resolveEmpty;
                this._resolveEmpty = () => {
                  (t(), e());
                };
              });
          }
          async onIdle() {
            if (0 !== this._pendingCount || 0 !== this._queue.size)
              return new Promise((e) => {
                let t = this._resolveIdle;
                this._resolveIdle = () => {
                  (t(), e());
                };
              });
          }
          get size() {
            return this._queue.size;
          }
          sizeBy(e) {
            return this._queue.filter(e).length;
          }
          get pending() {
            return this._pendingCount;
          }
          get isPaused() {
            return this._isPaused;
          }
          get timeout() {
            return this._timeout;
          }
          set timeout(e) {
            this._timeout = e;
          }
        }),
        (t.exports = u));
    })();
  },
  51187,
  (e, t, r) => {
    t.exports = e.x(
      'next/dist/server/lib/incremental-cache/tags-manifest.external.js',
      () =>
        require('next/dist/server/lib/incremental-cache/tags-manifest.external.js')
    );
  },
  78500,
  (e, t, r) => {
    t.exports = e.x('node:async_hooks', () => require('node:async_hooks'));
  },
  22947,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      getTestReqInfo: function () {
        return l;
      },
      withRequest: function () {
        return o;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = new (e.r(78500).AsyncLocalStorage)();
    function a(e, t) {
      let r = t.header(e, 'next-test-proxy-port');
      if (!r) return;
      let n = t.url(e);
      return {
        url: n,
        proxyPort: Number(r),
        testData: t.header(e, 'next-test-data') || '',
      };
    }
    function o(e, t, r) {
      let n = a(e, t);
      return n ? s.run(n, r) : r();
    }
    function l(e, t) {
      let r = s.getStore();
      return r || (e && t ? a(e, t) : void 0);
    }
  },
  49883,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      handleFetch: function () {
        return l;
      },
      interceptFetch: function () {
        return u;
      },
      reader: function () {
        return a;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = e.r(22947),
      a = { url: (e) => e.url, header: (e, t) => e.headers.get(t) };
    async function o(e, t) {
      let {
        url: r,
        method: n,
        headers: i,
        body: s,
        cache: a,
        credentials: o,
        integrity: l,
        mode: u,
        redirect: c,
        referrer: h,
        referrerPolicy: d,
      } = t;
      return {
        testData: e,
        api: 'fetch',
        request: {
          url: r,
          method: n,
          headers: [
            ...Array.from(i),
            [
              'next-test-stack',
              (function () {
                let e = (Error().stack ?? '').split('\n');
                for (let t = 1; t < e.length; t++)
                  if (e[t].length > 0) {
                    e = e.slice(t);
                    break;
                  }
                return (e = (e = (e = e.filter(
                  (e) => !e.includes('/next/dist/')
                )).slice(0, 5)).map((e) =>
                  e.replace('webpack-internal:///(rsc)/', '').trim()
                )).join('    ');
              })(),
            ],
          ],
          body: s
            ? Buffer.from(await t.arrayBuffer()).toString('base64')
            : null,
          cache: a,
          credentials: o,
          integrity: l,
          mode: u,
          redirect: c,
          referrer: h,
          referrerPolicy: d,
        },
      };
    }
    async function l(e, t) {
      let r = (0, s.getTestReqInfo)(t, a);
      if (!r) return e(t);
      let { testData: n, proxyPort: i } = r,
        l = await o(n, t),
        u = await e(`http://localhost:${i}`, {
          method: 'POST',
          body: JSON.stringify(l),
          next: { internal: !0 },
        });
      if (!u.ok)
        throw Object.defineProperty(
          Error(`Proxy request failed: ${u.status}`),
          '__NEXT_ERROR_CODE',
          { value: 'E146', enumerable: !1, configurable: !0 }
        );
      let c = await u.json(),
        { api: h } = c;
      switch (h) {
        case 'continue':
          return e(t);
        case 'abort':
        case 'unhandled':
          throw Object.defineProperty(
            Error(`Proxy request aborted [${t.method} ${t.url}]`),
            '__NEXT_ERROR_CODE',
            { value: 'E145', enumerable: !1, configurable: !0 }
          );
        case 'fetch':
          return (function (e) {
            let { status: t, headers: r, body: n } = e.response;
            return new Response(n ? Buffer.from(n, 'base64') : null, {
              status: t,
              headers: new Headers(r),
            });
          })(c);
        default:
          return h;
      }
    }
    function u(t) {
      return (
        (e.g.fetch = function (e, r) {
          var n;
          return (null == r || null == (n = r.next) ? void 0 : n.internal)
            ? t(e, r)
            : l(t, new Request(e, r));
        }),
        () => {
          e.g.fetch = t;
        }
      );
    }
  },
  76532,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      interceptTestApis: function () {
        return o;
      },
      wrapRequestHandler: function () {
        return l;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = e.r(22947),
      a = e.r(49883);
    function o() {
      return (0, a.interceptFetch)(e.g.fetch);
    }
    function l(e) {
      return (t, r) => (0, s.withRequest)(t, a.reader, () => e(t, r));
    }
  },
  9933,
  (e, t, r) => {
    'use strict';
    let n;
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      (r.parseCookie = h),
      (r.parse = h),
      (r.stringifyCookie = function (e, t) {
        let r = t?.encode || encodeURIComponent,
          n = [];
        for (let t of Object.keys(e)) {
          let a = e[t];
          if (void 0 === a) continue;
          if (!i.test(t)) throw TypeError(`cookie name is invalid: ${t}`);
          let o = r(a);
          if (!s.test(o)) throw TypeError(`cookie val is invalid: ${a}`);
          n.push(`${t}=${o}`);
        }
        return n.join('; ');
      }),
      (r.stringifySetCookie = d),
      (r.serialize = d),
      (r.parseSetCookie = function (e, t) {
        let r = t?.decode || m,
          n = e.length,
          i = p(e, 0, n),
          s = f(e, 0, i),
          a =
            -1 === s
              ? { name: '', value: r(g(e, 0, i)) }
              : { name: g(e, 0, s), value: r(g(e, s + 1, i)) },
          o = i + 1;
        for (; o < n; ) {
          let t = p(e, o, n),
            r = f(e, o, t),
            i = -1 === r ? g(e, o, t) : g(e, o, r),
            s = -1 === r ? void 0 : g(e, r + 1, t);
          switch (i.toLowerCase()) {
            case 'httponly':
              a.httpOnly = !0;
              break;
            case 'secure':
              a.secure = !0;
              break;
            case 'partitioned':
              a.partitioned = !0;
              break;
            case 'domain':
              a.domain = s;
              break;
            case 'path':
              a.path = s;
              break;
            case 'max-age':
              s && l.test(s) && (a.maxAge = Number(s));
              break;
            case 'expires':
              if (!s) break;
              let u = new Date(s);
              Number.isFinite(u.valueOf()) && (a.expires = u);
              break;
            case 'priority':
              if (!s) break;
              let c = s.toLowerCase();
              ('low' === c || 'medium' === c || 'high' === c) &&
                (a.priority = c);
              break;
            case 'samesite':
              if (!s) break;
              let h = s.toLowerCase();
              ('lax' === h || 'strict' === h || 'none' === h) &&
                (a.sameSite = h);
          }
          o = t + 1;
        }
        return a;
      }),
      (r.stringifySetCookie = d),
      (r.serialize = d));
    let i = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
      s = /^[\u0021-\u003A\u003C-\u007E]*$/,
      a =
        /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      o = /^[\u0020-\u003A\u003D-\u007E]*$/,
      l = /^-?\d+$/,
      u = Object.prototype.toString,
      c = (((n = function () {}).prototype = Object.create(null)), n);
    function h(e, t) {
      let r = new c(),
        n = e.length;
      if (n < 2) return r;
      let i = t?.decode || m,
        s = 0;
      do {
        let t = f(e, s, n);
        if (-1 === t) break;
        let a = p(e, s, n);
        if (t > a) {
          s = e.lastIndexOf(';', t - 1) + 1;
          continue;
        }
        let o = g(e, s, t);
        (void 0 === r[o] && (r[o] = i(g(e, t + 1, a))), (s = a + 1));
      } while (s < n);
      return r;
    }
    function d(e, t, r) {
      let n = 'object' == typeof e ? e : { ...r, name: e, value: String(t) },
        l = ('object' == typeof t ? t : r)?.encode || encodeURIComponent;
      if (!i.test(n.name))
        throw TypeError(`argument name is invalid: ${n.name}`);
      let c = n.value ? l(n.value) : '';
      if (!s.test(c)) throw TypeError(`argument val is invalid: ${n.value}`);
      let h = n.name + '=' + c;
      if (void 0 !== n.maxAge) {
        if (!Number.isInteger(n.maxAge))
          throw TypeError(`option maxAge is invalid: ${n.maxAge}`);
        h += '; Max-Age=' + n.maxAge;
      }
      if (n.domain) {
        if (!a.test(n.domain))
          throw TypeError(`option domain is invalid: ${n.domain}`);
        h += '; Domain=' + n.domain;
      }
      if (n.path) {
        if (!o.test(n.path))
          throw TypeError(`option path is invalid: ${n.path}`);
        h += '; Path=' + n.path;
      }
      if (n.expires) {
        var d;
        if (
          ((d = n.expires),
          '[object Date]' !== u.call(d) ||
            !Number.isFinite(n.expires.valueOf()))
        )
          throw TypeError(`option expires is invalid: ${n.expires}`);
        h += '; Expires=' + n.expires.toUTCString();
      }
      if (
        (n.httpOnly && (h += '; HttpOnly'),
        n.secure && (h += '; Secure'),
        n.partitioned && (h += '; Partitioned'),
        n.priority)
      )
        switch (
          'string' == typeof n.priority ? n.priority.toLowerCase() : void 0
        ) {
          case 'low':
            h += '; Priority=Low';
            break;
          case 'medium':
            h += '; Priority=Medium';
            break;
          case 'high':
            h += '; Priority=High';
            break;
          default:
            throw TypeError(`option priority is invalid: ${n.priority}`);
        }
      if (n.sameSite)
        switch (
          'string' == typeof n.sameSite ? n.sameSite.toLowerCase() : n.sameSite
        ) {
          case !0:
          case 'strict':
            h += '; SameSite=Strict';
            break;
          case 'lax':
            h += '; SameSite=Lax';
            break;
          case 'none':
            h += '; SameSite=None';
            break;
          default:
            throw TypeError(`option sameSite is invalid: ${n.sameSite}`);
        }
      return h;
    }
    function p(e, t, r) {
      let n = e.indexOf(';', t);
      return -1 === n ? r : n;
    }
    function f(e, t, r) {
      let n = e.indexOf('=', t);
      return n < r ? n : -1;
    }
    function g(e, t, r) {
      let n = t,
        i = r;
      do {
        let t = e.charCodeAt(n);
        if (32 !== t && 9 !== t) break;
      } while (++n < i);
      for (; i > n; ) {
        let t = e.charCodeAt(i - 1);
        if (32 !== t && 9 !== t) break;
        i--;
      }
      return e.slice(n, i);
    }
    function m(e) {
      if (-1 === e.indexOf('%')) return e;
      try {
        return decodeURIComponent(e);
      } catch (t) {
        return e;
      }
    }
  },
  3995,
  (e, t, r) => {},
  12953,
  (e, t, r) => {
    'use strict';
    function n(e, t, r) {
      if (e) {
        for (let n of (r && (r = r.toLowerCase()), e))
          if (
            t === n.domain?.split(':', 1)[0].toLowerCase() ||
            r === n.defaultLocale.toLowerCase() ||
            n.locales?.some((e) => e.toLowerCase() === r)
          )
            return n;
      }
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'detectDomainLocale', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
  },
  57520,
  (e, t, r) => {
    'use strict';
    function n(e) {
      return e.replace(/\/$/, '') || '/';
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'removeTrailingSlash', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
  },
  52799,
  (e, t, r) => {
    'use strict';
    function n(e) {
      let t = e.indexOf('#'),
        r = e.indexOf('?'),
        n = r > -1 && (t < 0 || r < t);
      return n || t > -1
        ? {
            pathname: e.substring(0, n ? r : t),
            query: n ? e.substring(r, t > -1 ? t : void 0) : '',
            hash: t > -1 ? e.slice(t) : '',
          }
        : { pathname: e, query: '', hash: '' };
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'parsePath', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
  },
  11959,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'addPathPrefix', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = e.r(52799);
    function i(e, t) {
      if (!e.startsWith('/') || !t) return e;
      let { pathname: r, query: i, hash: s } = (0, n.parsePath)(e);
      return `${t}${r}${i}${s}`;
    }
  },
  30652,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'addPathSuffix', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = e.r(52799);
    function i(e, t) {
      if (!e.startsWith('/') || !t) return e;
      let { pathname: r, query: i, hash: s } = (0, n.parsePath)(e);
      return `${r}${t}${i}${s}`;
    }
  },
  86984,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'pathHasPrefix', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = e.r(52799);
    function i(e, t) {
      if ('string' != typeof e) return !1;
      let { pathname: r } = (0, n.parsePath)(e);
      return r === t || r.startsWith(t + '/');
    }
  },
  99256,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'addLocale', {
        enumerable: !0,
        get: function () {
          return s;
        },
      }));
    let n = e.r(11959),
      i = e.r(86984);
    function s(e, t, r, s) {
      if (!t || t === r) return e;
      let a = e.toLowerCase();
      return !s &&
        ((0, i.pathHasPrefix)(a, '/api') ||
          (0, i.pathHasPrefix)(a, `/${t.toLowerCase()}`))
        ? e
        : (0, n.addPathPrefix)(e, `/${t}`);
    }
  },
  16107,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'formatNextPathnameInfo', {
        enumerable: !0,
        get: function () {
          return o;
        },
      }));
    let n = e.r(57520),
      i = e.r(11959),
      s = e.r(30652),
      a = e.r(99256);
    function o(e) {
      let t = (0, a.addLocale)(
        e.pathname,
        e.locale,
        e.buildId ? void 0 : e.defaultLocale,
        e.ignorePrefix
      );
      return (
        (e.buildId || !e.trailingSlash) && (t = (0, n.removeTrailingSlash)(t)),
        e.buildId &&
          (t = (0, s.addPathSuffix)(
            (0, i.addPathPrefix)(t, `/_next/data/${e.buildId}`),
            '/' === e.pathname ? 'index.json' : '.json'
          )),
        (t = (0, i.addPathPrefix)(t, e.basePath)),
        !e.buildId && e.trailingSlash
          ? t.endsWith('/')
            ? t
            : (0, s.addPathSuffix)(t, '/')
          : (0, n.removeTrailingSlash)(t)
      );
    }
  },
  26729,
  (e, t, r) => {
    'use strict';
    function n(e, t) {
      let r;
      if (t?.host && !Array.isArray(t.host))
        r = t.host.toString().split(':', 1)[0];
      else {
        if (!e.hostname) return;
        r = e.hostname;
      }
      return r.toLowerCase();
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'getHostname', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
  },
  96045,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'normalizeLocalePath', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = new WeakMap();
    function i(e, t) {
      let r;
      if (!t) return { pathname: e };
      let i = n.get(t);
      i || ((i = t.map((e) => e.toLowerCase())), n.set(t, i));
      let s = e.split('/', 2);
      if (!s[1]) return { pathname: e };
      let a = s[1].toLowerCase(),
        o = i.indexOf(a);
      return o < 0
        ? { pathname: e }
        : ((r = t[o]),
          { pathname: (e = e.slice(r.length + 1) || '/'), detectedLocale: r });
    }
  },
  92624,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'removePathPrefix', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = e.r(86984);
    function i(e, t) {
      if (!(0, n.pathHasPrefix)(e, t)) return e;
      let r = e.slice(t.length);
      return r.startsWith('/') ? r : `/${r}`;
    }
  },
  7657,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'getNextPathnameInfo', {
        enumerable: !0,
        get: function () {
          return a;
        },
      }));
    let n = e.r(96045),
      i = e.r(92624),
      s = e.r(86984);
    function a(e, t) {
      let { basePath: r, i18n: a, trailingSlash: o } = t.nextConfig ?? {},
        l = { pathname: e, trailingSlash: '/' !== e ? e.endsWith('/') : o };
      r &&
        (0, s.pathHasPrefix)(l.pathname, r) &&
        ((l.pathname = (0, i.removePathPrefix)(l.pathname, r)),
        (l.basePath = r));
      let u = l.pathname;
      if (
        l.pathname.startsWith('/_next/data/') &&
        l.pathname.endsWith('.json')
      ) {
        let e = l.pathname
          .replace(/^\/_next\/data\//, '')
          .replace(/\.json$/, '')
          .split('/');
        ((l.buildId = e[0]),
          (u = 'index' !== e[1] ? `/${e.slice(1).join('/')}` : '/'),
          !0 === t.parseData && (l.pathname = u));
      }
      if (a) {
        let e = t.i18nProvider
          ? t.i18nProvider.analyze(l.pathname)
          : (0, n.normalizeLocalePath)(l.pathname, a.locales);
        ((l.locale = e.detectedLocale),
          (l.pathname = e.pathname ?? l.pathname),
          !e.detectedLocale &&
            l.buildId &&
            (e = t.i18nProvider
              ? t.i18nProvider.analyze(u)
              : (0, n.normalizeLocalePath)(u, a.locales)).detectedLocale &&
            (l.locale = e.detectedLocale));
      }
      return l;
    }
  },
  61400,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'NextURL', {
        enumerable: !0,
        get: function () {
          return c;
        },
      }));
    let n = e.r(12953),
      i = e.r(16107),
      s = e.r(26729),
      a = e.r(7657),
      o =
        /(?!^https?:\/\/)(127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\[::1\]|localhost)/;
    function l(e, t) {
      return new URL(
        String(e).replace(o, 'localhost'),
        t && String(t).replace(o, 'localhost')
      );
    }
    let u = Symbol('NextURLInternal');
    class c {
      constructor(e, t, r) {
        let n, i;
        (('object' == typeof t && 'pathname' in t) || 'string' == typeof t
          ? ((n = t), (i = r || {}))
          : (i = r || t || {}),
          (this[u] = { url: l(e, n ?? i.base), options: i, basePath: '' }),
          this.analyze());
      }
      analyze() {
        var e, t, r, i, o;
        let l = (0, a.getNextPathnameInfo)(this[u].url.pathname, {
            nextConfig: this[u].options.nextConfig,
            parseData: !0,
            i18nProvider: this[u].options.i18nProvider,
          }),
          c = (0, s.getHostname)(this[u].url, this[u].options.headers);
        this[u].domainLocale = this[u].options.i18nProvider
          ? this[u].options.i18nProvider.detectDomainLocale(c)
          : (0, n.detectDomainLocale)(
              null == (t = this[u].options.nextConfig) || null == (e = t.i18n)
                ? void 0
                : e.domains,
              c
            );
        let h =
          (null == (r = this[u].domainLocale) ? void 0 : r.defaultLocale) ||
          (null == (o = this[u].options.nextConfig) || null == (i = o.i18n)
            ? void 0
            : i.defaultLocale);
        ((this[u].url.pathname = l.pathname),
          (this[u].defaultLocale = h),
          (this[u].basePath = l.basePath ?? ''),
          (this[u].buildId = l.buildId),
          (this[u].locale = l.locale ?? h),
          (this[u].trailingSlash = l.trailingSlash));
      }
      formatPathname() {
        return (0, i.formatNextPathnameInfo)({
          basePath: this[u].basePath,
          buildId: this[u].buildId,
          defaultLocale: this[u].options.forceLocale
            ? void 0
            : this[u].defaultLocale,
          locale: this[u].locale,
          pathname: this[u].url.pathname,
          trailingSlash: this[u].trailingSlash,
        });
      }
      formatSearch() {
        return this[u].url.search;
      }
      get buildId() {
        return this[u].buildId;
      }
      set buildId(e) {
        this[u].buildId = e;
      }
      get locale() {
        return this[u].locale ?? '';
      }
      set locale(e) {
        var t, r;
        if (
          !this[u].locale ||
          !(null == (r = this[u].options.nextConfig) || null == (t = r.i18n)
            ? void 0
            : t.locales.includes(e))
        )
          throw Object.defineProperty(
            TypeError(`The NextURL configuration includes no locale "${e}"`),
            '__NEXT_ERROR_CODE',
            { value: 'E597', enumerable: !1, configurable: !0 }
          );
        this[u].locale = e;
      }
      get defaultLocale() {
        return this[u].defaultLocale;
      }
      get domainLocale() {
        return this[u].domainLocale;
      }
      get searchParams() {
        return this[u].url.searchParams;
      }
      get host() {
        return this[u].url.host;
      }
      set host(e) {
        this[u].url.host = e;
      }
      get hostname() {
        return this[u].url.hostname;
      }
      set hostname(e) {
        this[u].url.hostname = e;
      }
      get port() {
        return this[u].url.port;
      }
      set port(e) {
        this[u].url.port = e;
      }
      get protocol() {
        return this[u].url.protocol;
      }
      set protocol(e) {
        this[u].url.protocol = e;
      }
      get href() {
        let e = this.formatPathname(),
          t = this.formatSearch();
        return `${this.protocol}//${this.host}${e}${t}${this.hash}`;
      }
      set href(e) {
        ((this[u].url = l(e)), this.analyze());
      }
      get origin() {
        return this[u].url.origin;
      }
      get pathname() {
        return this[u].url.pathname;
      }
      set pathname(e) {
        this[u].url.pathname = e;
      }
      get hash() {
        return this[u].url.hash;
      }
      set hash(e) {
        this[u].url.hash = e;
      }
      get search() {
        return this[u].url.search;
      }
      set search(e) {
        this[u].url.search = e;
      }
      get password() {
        return this[u].url.password;
      }
      set password(e) {
        this[u].url.password = e;
      }
      get username() {
        return this[u].url.username;
      }
      set username(e) {
        this[u].url.username = e;
      }
      get basePath() {
        return this[u].basePath;
      }
      set basePath(e) {
        this[u].basePath = e.startsWith('/') ? e : `/${e}`;
      }
      toString() {
        return this.href;
      }
      toJSON() {
        return this.href;
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          href: this.href,
          origin: this.origin,
          protocol: this.protocol,
          username: this.username,
          password: this.password,
          host: this.host,
          hostname: this.hostname,
          port: this.port,
          pathname: this.pathname,
          search: this.search,
          searchParams: this.searchParams,
          hash: this.hash,
        };
      }
      clone() {
        return new c(String(this), this[u].options);
      }
    }
  },
  30009,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      ACTION_SUFFIX: function () {
        return m;
      },
      APP_DIR_ALIAS: function () {
        return U;
      },
      CACHE_ONE_YEAR: function () {
        return P;
      },
      DOT_NEXT_ALIAS: function () {
        return $;
      },
      ESLINT_DEFAULT_DIRS: function () {
        return ei;
      },
      GSP_NO_RETURNED_VALUE: function () {
        return Q;
      },
      GSSP_COMPONENT_MEMBER_ERROR: function () {
        return et;
      },
      GSSP_NO_RETURNED_VALUE: function () {
        return Z;
      },
      HTML_CONTENT_TYPE_HEADER: function () {
        return a;
      },
      INFINITE_CACHE: function () {
        return x;
      },
      INSTRUMENTATION_HOOK_FILENAME: function () {
        return j;
      },
      JSON_CONTENT_TYPE_HEADER: function () {
        return o;
      },
      MATCHED_PATH_HEADER: function () {
        return c;
      },
      MIDDLEWARE_FILENAME: function () {
        return A;
      },
      MIDDLEWARE_LOCATION_REGEXP: function () {
        return C;
      },
      NEXT_BODY_SUFFIX: function () {
        return v;
      },
      NEXT_CACHE_IMPLICIT_TAG_ID: function () {
        return k;
      },
      NEXT_CACHE_REVALIDATED_TAGS_HEADER: function () {
        return _;
      },
      NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function () {
        return E;
      },
      NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function () {
        return T;
      },
      NEXT_CACHE_TAGS_HEADER: function () {
        return w;
      },
      NEXT_CACHE_TAG_MAX_ITEMS: function () {
        return R;
      },
      NEXT_CACHE_TAG_MAX_LENGTH: function () {
        return O;
      },
      NEXT_DATA_SUFFIX: function () {
        return y;
      },
      NEXT_INTERCEPTION_MARKER_PREFIX: function () {
        return u;
      },
      NEXT_META_SUFFIX: function () {
        return b;
      },
      NEXT_QUERY_PARAM_PREFIX: function () {
        return l;
      },
      NEXT_RESUME_HEADER: function () {
        return S;
      },
      NON_STANDARD_NODE_ENV: function () {
        return er;
      },
      PAGES_DIR_ALIAS: function () {
        return D;
      },
      PRERENDER_REVALIDATE_HEADER: function () {
        return h;
      },
      PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function () {
        return d;
      },
      PROXY_FILENAME: function () {
        return I;
      },
      PROXY_LOCATION_REGEXP: function () {
        return N;
      },
      PUBLIC_DIR_MIDDLEWARE_CONFLICT: function () {
        return F;
      },
      ROOT_DIR_ALIAS: function () {
        return L;
      },
      RSC_ACTION_CLIENT_WRAPPER_ALIAS: function () {
        return H;
      },
      RSC_ACTION_ENCRYPTION_ALIAS: function () {
        return G;
      },
      RSC_ACTION_PROXY_ALIAS: function () {
        return q;
      },
      RSC_ACTION_VALIDATE_ALIAS: function () {
        return B;
      },
      RSC_CACHE_WRAPPER_ALIAS: function () {
        return V;
      },
      RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS: function () {
        return W;
      },
      RSC_MOD_REF_PROXY_ALIAS: function () {
        return M;
      },
      RSC_SEGMENTS_DIR_SUFFIX: function () {
        return p;
      },
      RSC_SEGMENT_SUFFIX: function () {
        return f;
      },
      RSC_SUFFIX: function () {
        return g;
      },
      SERVER_PROPS_EXPORT_ERROR: function () {
        return Y;
      },
      SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function () {
        return K;
      },
      SERVER_PROPS_SSG_CONFLICT: function () {
        return X;
      },
      SERVER_RUNTIME: function () {
        return es;
      },
      SSG_FALLBACK_EXPORT_ERROR: function () {
        return en;
      },
      SSG_GET_INITIAL_PROPS_CONFLICT: function () {
        return z;
      },
      STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function () {
        return J;
      },
      TEXT_PLAIN_CONTENT_TYPE_HEADER: function () {
        return s;
      },
      UNSTABLE_REVALIDATE_RENAME_ERROR: function () {
        return ee;
      },
      WEBPACK_LAYERS: function () {
        return el;
      },
      WEBPACK_RESOURCE_QUERIES: function () {
        return eu;
      },
      WEB_SOCKET_MAX_RECONNECTIONS: function () {
        return ea;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = 'text/plain',
      a = 'text/html; charset=utf-8',
      o = 'application/json; charset=utf-8',
      l = 'nxtP',
      u = 'nxtI',
      c = 'x-matched-path',
      h = 'x-prerender-revalidate',
      d = 'x-prerender-revalidate-if-generated',
      p = '.segments',
      f = '.segment.rsc',
      g = '.rsc',
      m = '.action',
      y = '.json',
      b = '.meta',
      v = '.body',
      w = 'x-next-cache-tags',
      _ = 'x-next-revalidated-tags',
      E = 'x-next-revalidate-tag-token',
      S = 'next-resume',
      R = 128,
      O = 256,
      T = 1024,
      k = '_N_T_',
      P = 31536e3,
      x = 0xfffffffe,
      A = 'middleware',
      C = `(?:src/)?${A}`,
      I = 'proxy',
      N = `(?:src/)?${I}`,
      j = 'instrumentation',
      D = 'private-next-pages',
      $ = 'private-dot-next',
      L = 'private-next-root-dir',
      U = 'private-next-app-dir',
      M = 'private-next-rsc-mod-ref-proxy',
      B = 'private-next-rsc-action-validate',
      q = 'private-next-rsc-server-reference',
      V = 'private-next-rsc-cache-wrapper',
      W = 'private-next-rsc-track-dynamic-import',
      G = 'private-next-rsc-action-encryption',
      H = 'private-next-rsc-action-client-wrapper',
      F =
        "You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict",
      z =
        'You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps',
      K =
        'You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.',
      X =
        'You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps',
      J =
        'can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props',
      Y =
        'pages with `getServerSideProps` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export',
      Q =
        'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?',
      Z =
        'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?',
      ee =
        'The `unstable_revalidate` property is available for general use.\nPlease use `revalidate` instead.',
      et =
        "can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member",
      er =
        'You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env',
      en =
        'Pages with `fallback` enabled in `getStaticPaths` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export',
      ei = ['app', 'pages', 'components', 'lib', 'src'],
      es = {
        edge: 'edge',
        experimentalEdge: 'experimental-edge',
        nodejs: 'nodejs',
      },
      ea = 12,
      eo = {
        shared: 'shared',
        reactServerComponents: 'rsc',
        serverSideRendering: 'ssr',
        actionBrowser: 'action-browser',
        apiNode: 'api-node',
        apiEdge: 'api-edge',
        middleware: 'middleware',
        instrument: 'instrument',
        edgeAsset: 'edge-asset',
        appPagesBrowser: 'app-pages-browser',
        pagesDirBrowser: 'pages-dir-browser',
        pagesDirEdge: 'pages-dir-edge',
        pagesDirNode: 'pages-dir-node',
      },
      el = {
        ...eo,
        GROUP: {
          builtinReact: [eo.reactServerComponents, eo.actionBrowser],
          serverOnly: [
            eo.reactServerComponents,
            eo.actionBrowser,
            eo.instrument,
            eo.middleware,
          ],
          neutralTarget: [eo.apiNode, eo.apiEdge],
          clientOnly: [eo.serverSideRendering, eo.appPagesBrowser],
          bundled: [
            eo.reactServerComponents,
            eo.actionBrowser,
            eo.serverSideRendering,
            eo.appPagesBrowser,
            eo.shared,
            eo.instrument,
            eo.middleware,
          ],
          appPages: [
            eo.reactServerComponents,
            eo.serverSideRendering,
            eo.appPagesBrowser,
            eo.actionBrowser,
          ],
        },
      },
      eu = {
        edgeSSREntry: '__next_edge_ssr_entry__',
        metadata: '__next_metadata__',
        metadataRoute: '__next_metadata_route__',
        metadataImageMeta: '__next_metadata_image_meta__',
      };
  },
  41296,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      fromNodeOutgoingHttpHeaders: function () {
        return a;
      },
      normalizeNextQueryParam: function () {
        return c;
      },
      splitCookiesString: function () {
        return o;
      },
      toNodeOutgoingHttpHeaders: function () {
        return l;
      },
      validateURL: function () {
        return u;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = e.r(30009);
    function a(e) {
      let t = new Headers();
      for (let [r, n] of Object.entries(e))
        for (let e of Array.isArray(n) ? n : [n])
          void 0 !== e &&
            ('number' == typeof e && (e = e.toString()), t.append(r, e));
      return t;
    }
    function o(e) {
      var t,
        r,
        n,
        i,
        s,
        a = [],
        o = 0;
      function l() {
        for (; o < e.length && /\s/.test(e.charAt(o)); ) o += 1;
        return o < e.length;
      }
      for (; o < e.length; ) {
        for (t = o, s = !1; l(); )
          if (',' === (r = e.charAt(o))) {
            for (
              n = o, o += 1, l(), i = o;
              o < e.length &&
              '=' !== (r = e.charAt(o)) &&
              ';' !== r &&
              ',' !== r;
            )
              o += 1;
            o < e.length && '=' === e.charAt(o)
              ? ((s = !0), (o = i), a.push(e.substring(t, n)), (t = o))
              : (o = n + 1);
          } else o += 1;
        (!s || o >= e.length) && a.push(e.substring(t, e.length));
      }
      return a;
    }
    function l(e) {
      let t = {},
        r = [];
      if (e)
        for (let [n, i] of e.entries())
          'set-cookie' === n.toLowerCase()
            ? (r.push(...o(i)), (t[n] = 1 === r.length ? r[0] : r))
            : (t[n] = i);
      return t;
    }
    function u(e) {
      try {
        return String(new URL(String(e)));
      } catch (t) {
        throw Object.defineProperty(
          Error(
            `URL is malformed "${String(e)}". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`,
            { cause: t }
          ),
          '__NEXT_ERROR_CODE',
          { value: 'E61', enumerable: !1, configurable: !0 }
        );
      }
    }
    function c(e) {
      for (let t of [
        s.NEXT_QUERY_PARAM_PREFIX,
        s.NEXT_INTERCEPTION_MARKER_PREFIX,
      ])
        if (e !== t && e.startsWith(t)) return e.substring(t.length);
      return null;
    }
  },
  43241,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      PageSignatureError: function () {
        return s;
      },
      RemovedPageError: function () {
        return a;
      },
      RemovedUAError: function () {
        return o;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    class s extends Error {
      constructor({ page: e }) {
        super(`The middleware "${e}" accepts an async API directly with the form:
  
  export function middleware(request, event) {
    return NextResponse.redirect('/new-location')
  }
  
  Read more: https://nextjs.org/docs/messages/middleware-new-signature
  `);
      }
    }
    class a extends Error {
      constructor() {
        super(`The request.page has been deprecated in favour of \`URLPattern\`.
  Read more: https://nextjs.org/docs/messages/middleware-request-page
  `);
      }
    }
    class o extends Error {
      constructor() {
        super(`The request.ua has been removed in favour of \`userAgent\` function.
  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
  `);
      }
    }
  },
  77312,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      RequestCookies: function () {
        return s.RequestCookies;
      },
      ResponseCookies: function () {
        return s.ResponseCookies;
      },
      stringifyCookie: function () {
        return s.stringifyCookie;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = e.r(9254);
  },
  75447,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      INTERNALS: function () {
        return u;
      },
      NextRequest: function () {
        return c;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = e.r(61400),
      a = e.r(41296),
      o = e.r(43241),
      l = e.r(77312),
      u = Symbol('internal request');
    class c extends Request {
      constructor(e, t = {}) {
        const r = 'string' != typeof e && 'url' in e ? e.url : String(e);
        ((0, a.validateURL)(r),
          t.body && 'half' !== t.duplex && (t.duplex = 'half'),
          e instanceof Request ? super(e, t) : super(r, t));
        const n = new s.NextURL(r, {
          headers: (0, a.toNodeOutgoingHttpHeaders)(this.headers),
          nextConfig: t.nextConfig,
        });
        this[u] = {
          cookies: new l.RequestCookies(this.headers),
          nextUrl: n,
          url: n.toString(),
        };
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          cookies: this.cookies,
          nextUrl: this.nextUrl,
          url: this.url,
          bodyUsed: this.bodyUsed,
          cache: this.cache,
          credentials: this.credentials,
          destination: this.destination,
          headers: Object.fromEntries(this.headers),
          integrity: this.integrity,
          keepalive: this.keepalive,
          method: this.method,
          mode: this.mode,
          redirect: this.redirect,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          signal: this.signal,
        };
      }
      get cookies() {
        return this[u].cookies;
      }
      get nextUrl() {
        return this[u].nextUrl;
      }
      get page() {
        throw new o.RemovedPageError();
      }
      get ua() {
        throw new o.RemovedUAError();
      }
      get url() {
        return this[u].url;
      }
    }
  },
  8126,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'ReflectAdapter', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
    class n {
      static get(e, t, r) {
        let n = Reflect.get(e, t, r);
        return 'function' == typeof n ? n.bind(e) : n;
      }
      static set(e, t, r, n) {
        return Reflect.set(e, t, r, n);
      }
      static has(e, t) {
        return Reflect.has(e, t);
      }
      static deleteProperty(e, t) {
        return Reflect.deleteProperty(e, t);
      }
    }
  },
  9052,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'NextResponse', {
        enumerable: !0,
        get: function () {
          return h;
        },
      }));
    let n = e.r(77312),
      i = e.r(61400),
      s = e.r(41296),
      a = e.r(8126),
      o = e.r(77312),
      l = Symbol('internal response'),
      u = new Set([301, 302, 303, 307, 308]);
    function c(e, t) {
      var r;
      if (null == e || null == (r = e.request) ? void 0 : r.headers) {
        if (!(e.request.headers instanceof Headers))
          throw Object.defineProperty(
            Error('request.headers must be an instance of Headers'),
            '__NEXT_ERROR_CODE',
            { value: 'E119', enumerable: !1, configurable: !0 }
          );
        let r = [];
        for (let [n, i] of e.request.headers)
          (t.set('x-middleware-request-' + n, i), r.push(n));
        t.set('x-middleware-override-headers', r.join(','));
      }
    }
    class h extends Response {
      constructor(e, t = {}) {
        super(e, t);
        const r = this.headers,
          u = new Proxy(new o.ResponseCookies(r), {
            get(e, i, s) {
              switch (i) {
                case 'delete':
                case 'set':
                  return (...s) => {
                    let a = Reflect.apply(e[i], e, s),
                      l = new Headers(r);
                    return (
                      a instanceof o.ResponseCookies &&
                        r.set(
                          'x-middleware-set-cookie',
                          a
                            .getAll()
                            .map((e) => (0, n.stringifyCookie)(e))
                            .join(',')
                        ),
                      c(t, l),
                      a
                    );
                  };
                default:
                  return a.ReflectAdapter.get(e, i, s);
              }
            },
          });
        this[l] = {
          cookies: u,
          url: t.url
            ? new i.NextURL(t.url, {
                headers: (0, s.toNodeOutgoingHttpHeaders)(r),
                nextConfig: t.nextConfig,
              })
            : void 0,
        };
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          cookies: this.cookies,
          url: this.url,
          body: this.body,
          bodyUsed: this.bodyUsed,
          headers: Object.fromEntries(this.headers),
          ok: this.ok,
          redirected: this.redirected,
          status: this.status,
          statusText: this.statusText,
          type: this.type,
        };
      }
      get cookies() {
        return this[l].cookies;
      }
      static json(e, t) {
        let r = Response.json(e, t);
        return new h(r.body, r);
      }
      static redirect(e, t) {
        let r =
          'number' == typeof t ? t : ((null == t ? void 0 : t.status) ?? 307);
        if (!u.has(r))
          throw Object.defineProperty(
            RangeError(
              'Failed to execute "redirect" on "response": Invalid status code'
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E529', enumerable: !1, configurable: !0 }
          );
        let n = 'object' == typeof t ? t : {},
          i = new Headers(null == n ? void 0 : n.headers);
        return (
          i.set('Location', (0, s.validateURL)(e)),
          new h(null, { ...n, headers: i, status: r })
        );
      }
      static rewrite(e, t) {
        let r = new Headers(null == t ? void 0 : t.headers);
        return (
          r.set('x-middleware-rewrite', (0, s.validateURL)(e)),
          c(t, r),
          new h(null, { ...t, headers: r })
        );
      }
      static next(e) {
        let t = new Headers(null == e ? void 0 : e.headers);
        return (
          t.set('x-middleware-next', '1'),
          c(e, t),
          new h(null, { ...e, headers: t })
        );
      }
    }
  },
  2075,
  (e, t, r) => {
    'use strict';
    function n() {
      throw Object.defineProperty(
        Error(
          'ImageResponse moved from "next/server" to "next/og" since Next.js 14, please import from "next/og" instead'
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E183', enumerable: !1, configurable: !0 }
      );
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'ImageResponse', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
  },
  6992,
  (e, t, r) => {
    var n = {
        226: function (t, r) {
          !(function (n, i) {
            'use strict';
            var s = 'function',
              a = 'undefined',
              o = 'object',
              l = 'string',
              u = 'major',
              c = 'model',
              h = 'name',
              d = 'type',
              p = 'vendor',
              f = 'version',
              g = 'architecture',
              m = 'console',
              y = 'mobile',
              b = 'tablet',
              v = 'smarttv',
              w = 'wearable',
              _ = 'embedded',
              E = 'Amazon',
              S = 'Apple',
              R = 'ASUS',
              O = 'BlackBerry',
              T = 'Browser',
              k = 'Chrome',
              P = 'Firefox',
              x = 'Google',
              A = 'Huawei',
              C = 'Microsoft',
              I = 'Motorola',
              N = 'Opera',
              j = 'Samsung',
              D = 'Sharp',
              $ = 'Sony',
              L = 'Xiaomi',
              U = 'Zebra',
              M = 'Facebook',
              B = 'Chromium OS',
              q = 'Mac OS',
              V = function (e, t) {
                var r = {};
                for (var n in e)
                  t[n] && t[n].length % 2 == 0
                    ? (r[n] = t[n].concat(e[n]))
                    : (r[n] = e[n]);
                return r;
              },
              W = function (e) {
                for (var t = {}, r = 0; r < e.length; r++)
                  t[e[r].toUpperCase()] = e[r];
                return t;
              },
              G = function (e, t) {
                return typeof e === l && -1 !== H(t).indexOf(H(e));
              },
              H = function (e) {
                return e.toLowerCase();
              },
              F = function (e, t) {
                if (typeof e === l)
                  return (
                    (e = e.replace(/^\s\s*/, '')),
                    typeof t === a ? e : e.substring(0, 350)
                  );
              },
              z = function (e, t) {
                for (var r, n, i, a, l, u, c = 0; c < t.length && !l; ) {
                  var h = t[c],
                    d = t[c + 1];
                  for (r = n = 0; r < h.length && !l && h[r]; )
                    if ((l = h[r++].exec(e)))
                      for (i = 0; i < d.length; i++)
                        ((u = l[++n]),
                          typeof (a = d[i]) === o && a.length > 0
                            ? 2 === a.length
                              ? typeof a[1] == s
                                ? (this[a[0]] = a[1].call(this, u))
                                : (this[a[0]] = a[1])
                              : 3 === a.length
                                ? typeof a[1] !== s || (a[1].exec && a[1].test)
                                  ? (this[a[0]] = u
                                      ? u.replace(a[1], a[2])
                                      : void 0)
                                  : (this[a[0]] = u
                                      ? a[1].call(this, u, a[2])
                                      : void 0)
                                : 4 === a.length &&
                                  (this[a[0]] = u
                                    ? a[3].call(this, u.replace(a[1], a[2]))
                                    : void 0)
                            : (this[a] = u || void 0));
                  c += 2;
                }
              },
              K = function (e, t) {
                for (var r in t)
                  if (typeof t[r] === o && t[r].length > 0) {
                    for (var n = 0; n < t[r].length; n++)
                      if (G(t[r][n], e)) return '?' === r ? void 0 : r;
                  } else if (G(t[r], e)) return '?' === r ? void 0 : r;
                return e;
              },
              X = {
                ME: '4.90',
                'NT 3.11': 'NT3.51',
                'NT 4.0': 'NT4.0',
                2e3: 'NT 5.0',
                XP: ['NT 5.1', 'NT 5.2'],
                Vista: 'NT 6.0',
                7: 'NT 6.1',
                8: 'NT 6.2',
                8.1: 'NT 6.3',
                10: ['NT 6.4', 'NT 10.0'],
                RT: 'ARM',
              },
              J = {
                browser: [
                  [/\b(?:crmo|crios)\/([\w\.]+)/i],
                  [f, [h, 'Chrome']],
                  [/edg(?:e|ios|a)?\/([\w\.]+)/i],
                  [f, [h, 'Edge']],
                  [
                    /(opera mini)\/([-\w\.]+)/i,
                    /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                    /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i,
                  ],
                  [h, f],
                  [/opios[\/ ]+([\w\.]+)/i],
                  [f, [h, N + ' Mini']],
                  [/\bopr\/([\w\.]+)/i],
                  [f, [h, N]],
                  [
                    /(kindle)\/([\w\.]+)/i,
                    /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
                    /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
                    /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
                    /(?:ms|\()(ie) ([\w\.]+)/i,
                    /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
                    /(heytap|ovi)browser\/([\d\.]+)/i,
                    /(weibo)__([\d\.]+)/i,
                  ],
                  [h, f],
                  [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],
                  [f, [h, 'UC' + T]],
                  [
                    /microm.+\bqbcore\/([\w\.]+)/i,
                    /\bqbcore\/([\w\.]+).+microm/i,
                  ],
                  [f, [h, 'WeChat(Win) Desktop']],
                  [/micromessenger\/([\w\.]+)/i],
                  [f, [h, 'WeChat']],
                  [/konqueror\/([\w\.]+)/i],
                  [f, [h, 'Konqueror']],
                  [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],
                  [f, [h, 'IE']],
                  [/ya(?:search)?browser\/([\w\.]+)/i],
                  [f, [h, 'Yandex']],
                  [/(avast|avg)\/([\w\.]+)/i],
                  [[h, /(.+)/, '$1 Secure ' + T], f],
                  [/\bfocus\/([\w\.]+)/i],
                  [f, [h, P + ' Focus']],
                  [/\bopt\/([\w\.]+)/i],
                  [f, [h, N + ' Touch']],
                  [/coc_coc\w+\/([\w\.]+)/i],
                  [f, [h, 'Coc Coc']],
                  [/dolfin\/([\w\.]+)/i],
                  [f, [h, 'Dolphin']],
                  [/coast\/([\w\.]+)/i],
                  [f, [h, N + ' Coast']],
                  [/miuibrowser\/([\w\.]+)/i],
                  [f, [h, 'MIUI ' + T]],
                  [/fxios\/([-\w\.]+)/i],
                  [f, [h, P]],
                  [/\bqihu|(qi?ho?o?|360)browser/i],
                  [[h, '360 ' + T]],
                  [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i],
                  [[h, /(.+)/, '$1 ' + T], f],
                  [/(comodo_dragon)\/([\w\.]+)/i],
                  [[h, /_/g, ' '], f],
                  [
                    /(electron)\/([\w\.]+) safari/i,
                    /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                    /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i,
                  ],
                  [h, f],
                  [
                    /(metasr)[\/ ]?([\w\.]+)/i,
                    /(lbbrowser)/i,
                    /\[(linkedin)app\]/i,
                  ],
                  [h],
                  [
                    /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i,
                  ],
                  [[h, M], f],
                  [
                    /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
                    /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
                    /safari (line)\/([\w\.]+)/i,
                    /\b(line)\/([\w\.]+)\/iab/i,
                    /(chromium|instagram)[\/ ]([-\w\.]+)/i,
                  ],
                  [h, f],
                  [/\bgsa\/([\w\.]+) .*safari\//i],
                  [f, [h, 'GSA']],
                  [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i],
                  [f, [h, 'TikTok']],
                  [/headlesschrome(?:\/([\w\.]+)| )/i],
                  [f, [h, k + ' Headless']],
                  [/ wv\).+(chrome)\/([\w\.]+)/i],
                  [[h, k + ' WebView'], f],
                  [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],
                  [f, [h, 'Android ' + T]],
                  [
                    /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i,
                  ],
                  [h, f],
                  [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],
                  [f, [h, 'Mobile Safari']],
                  [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],
                  [f, h],
                  [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],
                  [
                    h,
                    [
                      f,
                      K,
                      {
                        '1.0': '/8',
                        1.2: '/1',
                        1.3: '/3',
                        '2.0': '/412',
                        '2.0.2': '/416',
                        '2.0.3': '/417',
                        '2.0.4': '/419',
                        '?': '/',
                      },
                    ],
                  ],
                  [/(webkit|khtml)\/([\w\.]+)/i],
                  [h, f],
                  [/(navigator|netscape\d?)\/([-\w\.]+)/i],
                  [[h, 'Netscape'], f],
                  [/mobile vr; rv:([\w\.]+)\).+firefox/i],
                  [f, [h, P + ' Reality']],
                  [
                    /ekiohf.+(flow)\/([\w\.]+)/i,
                    /(swiftfox)/i,
                    /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                    /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                    /(firefox)\/([\w\.]+)/i,
                    /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
                    /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                    /(links) \(([\w\.]+)/i,
                    /panasonic;(viera)/i,
                  ],
                  [h, f],
                  [/(cobalt)\/([\w\.]+)/i],
                  [h, [f, /master.|lts./, '']],
                ],
                cpu: [
                  [/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],
                  [[g, 'amd64']],
                  [/(ia32(?=;))/i],
                  [[g, H]],
                  [/((?:i[346]|x)86)[;\)]/i],
                  [[g, 'ia32']],
                  [/\b(aarch64|arm(v?8e?l?|_?64))\b/i],
                  [[g, 'arm64']],
                  [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],
                  [[g, 'armhf']],
                  [/windows (ce|mobile); ppc;/i],
                  [[g, 'arm']],
                  [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],
                  [[g, /ower/, '', H]],
                  [/(sun4\w)[;\)]/i],
                  [[g, 'sparc']],
                  [
                    /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i,
                  ],
                  [[g, H]],
                ],
                device: [
                  [
                    /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i,
                  ],
                  [c, [p, j], [d, b]],
                  [
                    /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
                    /samsung[- ]([-\w]+)/i,
                    /sec-(sgh\w+)/i,
                  ],
                  [c, [p, j], [d, y]],
                  [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i],
                  [c, [p, S], [d, y]],
                  [
                    /\((ipad);[-\w\),; ]+apple/i,
                    /applecoremedia\/[\w\.]+ \((ipad)/i,
                    /\b(ipad)\d\d?,\d\d?[;\]].+ios/i,
                  ],
                  [c, [p, S], [d, b]],
                  [/(macintosh);/i],
                  [c, [p, S]],
                  [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],
                  [c, [p, D], [d, y]],
                  [
                    /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i,
                  ],
                  [c, [p, A], [d, b]],
                  [
                    /(?:huawei|honor)([-\w ]+)[;\)]/i,
                    /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i,
                  ],
                  [c, [p, A], [d, y]],
                  [
                    /\b(poco[\w ]+)(?: bui|\))/i,
                    /\b; (\w+) build\/hm\1/i,
                    /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                    /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                    /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i,
                  ],
                  [
                    [c, /_/g, ' '],
                    [p, L],
                    [d, y],
                  ],
                  [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],
                  [
                    [c, /_/g, ' '],
                    [p, L],
                    [d, b],
                  ],
                  [
                    /; (\w+) bui.+ oppo/i,
                    /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i,
                  ],
                  [c, [p, 'OPPO'], [d, y]],
                  [
                    /vivo (\w+)(?: bui|\))/i,
                    /\b(v[12]\d{3}\w?[at])(?: bui|;)/i,
                  ],
                  [c, [p, 'Vivo'], [d, y]],
                  [/\b(rmx[12]\d{3})(?: bui|;|\))/i],
                  [c, [p, 'Realme'], [d, y]],
                  [
                    /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                    /\bmot(?:orola)?[- ](\w*)/i,
                    /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i,
                  ],
                  [c, [p, I], [d, y]],
                  [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
                  [c, [p, I], [d, b]],
                  [
                    /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i,
                  ],
                  [c, [p, 'LG'], [d, b]],
                  [
                    /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                    /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
                    /\blg-?([\d\w]+) bui/i,
                  ],
                  [c, [p, 'LG'], [d, y]],
                  [
                    /(ideatab[-\w ]+)/i,
                    /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i,
                  ],
                  [c, [p, 'Lenovo'], [d, b]],
                  [
                    /(?:maemo|nokia).*(n900|lumia \d+)/i,
                    /nokia[-_ ]?([-\w\.]*)/i,
                  ],
                  [
                    [c, /_/g, ' '],
                    [p, 'Nokia'],
                    [d, y],
                  ],
                  [/(pixel c)\b/i],
                  [c, [p, x], [d, b]],
                  [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],
                  [c, [p, x], [d, y]],
                  [
                    /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i,
                  ],
                  [c, [p, $], [d, y]],
                  [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i],
                  [
                    [c, 'Xperia Tablet'],
                    [p, $],
                    [d, b],
                  ],
                  [
                    / (kb2005|in20[12]5|be20[12][59])\b/i,
                    /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i,
                  ],
                  [c, [p, 'OnePlus'], [d, y]],
                  [
                    /(alexa)webm/i,
                    /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i,
                    /(kf[a-z]+)( bui|\)).+silk\//i,
                  ],
                  [c, [p, E], [d, b]],
                  [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],
                  [
                    [c, /(.+)/g, 'Fire Phone $1'],
                    [p, E],
                    [d, y],
                  ],
                  [/(playbook);[-\w\),; ]+(rim)/i],
                  [c, p, [d, b]],
                  [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i],
                  [c, [p, O], [d, y]],
                  [
                    /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i,
                  ],
                  [c, [p, R], [d, b]],
                  [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
                  [c, [p, R], [d, y]],
                  [/(nexus 9)/i],
                  [c, [p, 'HTC'], [d, b]],
                  [
                    /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                    /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                    /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i,
                  ],
                  [p, [c, /_/g, ' '], [d, y]],
                  [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],
                  [c, [p, 'Acer'], [d, b]],
                  [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i],
                  [c, [p, 'Meizu'], [d, y]],
                  [
                    /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                    /(hp) ([\w ]+\w)/i,
                    /(asus)-?(\w+)/i,
                    /(microsoft); (lumia[\w ]+)/i,
                    /(lenovo)[-_ ]?([-\w]+)/i,
                    /(jolla)/i,
                    /(oppo) ?([\w ]+) bui/i,
                  ],
                  [p, c, [d, y]],
                  [
                    /(kobo)\s(ereader|touch)/i,
                    /(archos) (gamepad2?)/i,
                    /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                    /(kindle)\/([\w\.]+)/i,
                    /(nook)[\w ]+build\/(\w+)/i,
                    /(dell) (strea[kpr\d ]*[\dko])/i,
                    /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
                    /(trinity)[- ]*(t\d{3}) bui/i,
                    /(gigaset)[- ]+(q\w{1,9}) bui/i,
                    /(vodafone) ([\w ]+)(?:\)| bui)/i,
                  ],
                  [p, c, [d, b]],
                  [/(surface duo)/i],
                  [c, [p, C], [d, b]],
                  [/droid [\d\.]+; (fp\du?)(?: b|\))/i],
                  [c, [p, 'Fairphone'], [d, y]],
                  [/(u304aa)/i],
                  [c, [p, 'AT&T'], [d, y]],
                  [/\bsie-(\w*)/i],
                  [c, [p, 'Siemens'], [d, y]],
                  [/\b(rct\w+) b/i],
                  [c, [p, 'RCA'], [d, b]],
                  [/\b(venue[\d ]{2,7}) b/i],
                  [c, [p, 'Dell'], [d, b]],
                  [/\b(q(?:mv|ta)\w+) b/i],
                  [c, [p, 'Verizon'], [d, b]],
                  [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],
                  [c, [p, 'Barnes & Noble'], [d, b]],
                  [/\b(tm\d{3}\w+) b/i],
                  [c, [p, 'NuVision'], [d, b]],
                  [/\b(k88) b/i],
                  [c, [p, 'ZTE'], [d, b]],
                  [/\b(nx\d{3}j) b/i],
                  [c, [p, 'ZTE'], [d, y]],
                  [/\b(gen\d{3}) b.+49h/i],
                  [c, [p, 'Swiss'], [d, y]],
                  [/\b(zur\d{3}) b/i],
                  [c, [p, 'Swiss'], [d, b]],
                  [/\b((zeki)?tb.*\b) b/i],
                  [c, [p, 'Zeki'], [d, b]],
                  [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i],
                  [[p, 'Dragon Touch'], c, [d, b]],
                  [/\b(ns-?\w{0,9}) b/i],
                  [c, [p, 'Insignia'], [d, b]],
                  [/\b((nxa|next)-?\w{0,9}) b/i],
                  [c, [p, 'NextBook'], [d, b]],
                  [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],
                  [[p, 'Voice'], c, [d, y]],
                  [/\b(lvtel\-)?(v1[12]) b/i],
                  [[p, 'LvTel'], c, [d, y]],
                  [/\b(ph-1) /i],
                  [c, [p, 'Essential'], [d, y]],
                  [/\b(v(100md|700na|7011|917g).*\b) b/i],
                  [c, [p, 'Envizen'], [d, b]],
                  [/\b(trio[-\w\. ]+) b/i],
                  [c, [p, 'MachSpeed'], [d, b]],
                  [/\btu_(1491) b/i],
                  [c, [p, 'Rotor'], [d, b]],
                  [/(shield[\w ]+) b/i],
                  [c, [p, 'Nvidia'], [d, b]],
                  [/(sprint) (\w+)/i],
                  [p, c, [d, y]],
                  [/(kin\.[onetw]{3})/i],
                  [
                    [c, /\./g, ' '],
                    [p, C],
                    [d, y],
                  ],
                  [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],
                  [c, [p, U], [d, b]],
                  [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
                  [c, [p, U], [d, y]],
                  [/smart-tv.+(samsung)/i],
                  [p, [d, v]],
                  [/hbbtv.+maple;(\d+)/i],
                  [
                    [c, /^/, 'SmartTV'],
                    [p, j],
                    [d, v],
                  ],
                  [
                    /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i,
                  ],
                  [
                    [p, 'LG'],
                    [d, v],
                  ],
                  [/(apple) ?tv/i],
                  [p, [c, S + ' TV'], [d, v]],
                  [/crkey/i],
                  [
                    [c, k + 'cast'],
                    [p, x],
                    [d, v],
                  ],
                  [/droid.+aft(\w)( bui|\))/i],
                  [c, [p, E], [d, v]],
                  [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i],
                  [c, [p, D], [d, v]],
                  [/(bravia[\w ]+)( bui|\))/i],
                  [c, [p, $], [d, v]],
                  [/(mitv-\w{5}) bui/i],
                  [c, [p, L], [d, v]],
                  [/Hbbtv.*(technisat) (.*);/i],
                  [p, c, [d, v]],
                  [
                    /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                    /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i,
                  ],
                  [
                    [p, F],
                    [c, F],
                    [d, v],
                  ],
                  [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],
                  [[d, v]],
                  [/(ouya)/i, /(nintendo) ([wids3utch]+)/i],
                  [p, c, [d, m]],
                  [/droid.+; (shield) bui/i],
                  [c, [p, 'Nvidia'], [d, m]],
                  [/(playstation [345portablevi]+)/i],
                  [c, [p, $], [d, m]],
                  [/\b(xbox(?: one)?(?!; xbox))[\); ]/i],
                  [c, [p, C], [d, m]],
                  [/((pebble))app/i],
                  [p, c, [d, w]],
                  [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i],
                  [c, [p, S], [d, w]],
                  [/droid.+; (glass) \d/i],
                  [c, [p, x], [d, w]],
                  [/droid.+; (wt63?0{2,3})\)/i],
                  [c, [p, U], [d, w]],
                  [/(quest( 2| pro)?)/i],
                  [c, [p, M], [d, w]],
                  [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],
                  [p, [d, _]],
                  [/(aeobc)\b/i],
                  [c, [p, E], [d, _]],
                  [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i],
                  [c, [d, y]],
                  [
                    /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i,
                  ],
                  [c, [d, b]],
                  [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],
                  [[d, b]],
                  [
                    /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i,
                  ],
                  [[d, y]],
                  [/(android[-\w\. ]{0,9});.+buil/i],
                  [c, [p, 'Generic']],
                ],
                engine: [
                  [/windows.+ edge\/([\w\.]+)/i],
                  [f, [h, 'EdgeHTML']],
                  [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],
                  [f, [h, 'Blink']],
                  [
                    /(presto)\/([\w\.]+)/i,
                    /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
                    /ekioh(flow)\/([\w\.]+)/i,
                    /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                    /(icab)[\/ ]([23]\.[\d\.]+)/i,
                    /\b(libweb)/i,
                  ],
                  [h, f],
                  [/rv\:([\w\.]{1,9})\b.+(gecko)/i],
                  [f, h],
                ],
                os: [
                  [/microsoft (windows) (vista|xp)/i],
                  [h, f],
                  [
                    /(windows) nt 6\.2; (arm)/i,
                    /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
                    /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
                  ],
                  [h, [f, K, X]],
                  [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i],
                  [
                    [h, 'Windows'],
                    [f, K, X],
                  ],
                  [
                    /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
                    /ios;fbsv\/([\d\.]+)/i,
                    /cfnetwork\/.+darwin/i,
                  ],
                  [
                    [f, /_/g, '.'],
                    [h, 'iOS'],
                  ],
                  [
                    /(mac os x) ?([\w\. ]*)/i,
                    /(macintosh|mac_powerpc\b)(?!.+haiku)/i,
                  ],
                  [
                    [h, q],
                    [f, /_/g, '.'],
                  ],
                  [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],
                  [f, h],
                  [
                    /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
                    /(blackberry)\w*\/([\w\.]*)/i,
                    /(tizen|kaios)[\/ ]([\w\.]+)/i,
                    /\((series40);/i,
                  ],
                  [h, f],
                  [/\(bb(10);/i],
                  [f, [h, O]],
                  [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],
                  [f, [h, 'Symbian']],
                  [
                    /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i,
                  ],
                  [f, [h, P + ' OS']],
                  [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],
                  [f, [h, 'webOS']],
                  [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i],
                  [f, [h, 'watchOS']],
                  [/crkey\/([\d\.]+)/i],
                  [f, [h, k + 'cast']],
                  [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i],
                  [[h, B], f],
                  [
                    /panasonic;(viera)/i,
                    /(netrange)mmh/i,
                    /(nettv)\/(\d+\.[\w\.]+)/i,
                    /(nintendo|playstation) ([wids345portablevuch]+)/i,
                    /(xbox); +xbox ([^\);]+)/i,
                    /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                    /(mint)[\/\(\) ]?(\w*)/i,
                    /(mageia|vectorlinux)[; ]/i,
                    /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                    /(hurd|linux) ?([\w\.]*)/i,
                    /(gnu) ?([\w\.]*)/i,
                    /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                    /(haiku) (\w+)/i,
                  ],
                  [h, f],
                  [/(sunos) ?([\w\.\d]*)/i],
                  [[h, 'Solaris'], f],
                  [
                    /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                    /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
                    /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
                    /(unix) ?([\w\.]*)/i,
                  ],
                  [h, f],
                ],
              },
              Y = function (e, t) {
                if (
                  (typeof e === o && ((t = e), (e = void 0)),
                  !(this instanceof Y))
                )
                  return new Y(e, t).getResult();
                var r = typeof n !== a && n.navigator ? n.navigator : void 0,
                  i = e || (r && r.userAgent ? r.userAgent : ''),
                  m = r && r.userAgentData ? r.userAgentData : void 0,
                  v = t ? V(J, t) : J,
                  w = r && r.userAgent == i;
                return (
                  (this.getBrowser = function () {
                    var e,
                      t = {};
                    return (
                      (t[h] = void 0),
                      (t[f] = void 0),
                      z.call(t, i, v.browser),
                      (t[u] =
                        typeof (e = t[f]) === l
                          ? e.replace(/[^\d\.]/g, '').split('.')[0]
                          : void 0),
                      w &&
                        r &&
                        r.brave &&
                        typeof r.brave.isBrave == s &&
                        (t[h] = 'Brave'),
                      t
                    );
                  }),
                  (this.getCPU = function () {
                    var e = {};
                    return ((e[g] = void 0), z.call(e, i, v.cpu), e);
                  }),
                  (this.getDevice = function () {
                    var e = {};
                    return (
                      (e[p] = void 0),
                      (e[c] = void 0),
                      (e[d] = void 0),
                      z.call(e, i, v.device),
                      w && !e[d] && m && m.mobile && (e[d] = y),
                      w &&
                        'Macintosh' == e[c] &&
                        r &&
                        typeof r.standalone !== a &&
                        r.maxTouchPoints &&
                        r.maxTouchPoints > 2 &&
                        ((e[c] = 'iPad'), (e[d] = b)),
                      e
                    );
                  }),
                  (this.getEngine = function () {
                    var e = {};
                    return (
                      (e[h] = void 0),
                      (e[f] = void 0),
                      z.call(e, i, v.engine),
                      e
                    );
                  }),
                  (this.getOS = function () {
                    var e = {};
                    return (
                      (e[h] = void 0),
                      (e[f] = void 0),
                      z.call(e, i, v.os),
                      w &&
                        !e[h] &&
                        m &&
                        'Unknown' != m.platform &&
                        (e[h] = m.platform
                          .replace(/chrome os/i, B)
                          .replace(/macos/i, q)),
                      e
                    );
                  }),
                  (this.getResult = function () {
                    return {
                      ua: this.getUA(),
                      browser: this.getBrowser(),
                      engine: this.getEngine(),
                      os: this.getOS(),
                      device: this.getDevice(),
                      cpu: this.getCPU(),
                    };
                  }),
                  (this.getUA = function () {
                    return i;
                  }),
                  (this.setUA = function (e) {
                    return (
                      (i = typeof e === l && e.length > 350 ? F(e, 350) : e),
                      this
                    );
                  }),
                  this.setUA(i),
                  this
                );
              };
            if (
              ((Y.VERSION = '1.0.35'),
              (Y.BROWSER = W([h, f, u])),
              (Y.CPU = W([g])),
              (Y.DEVICE = W([c, p, d, m, y, v, b, w, _])),
              (Y.ENGINE = Y.OS = W([h, f])),
              typeof r !== a)
            )
              (t.exports && (r = t.exports = Y), (r.UAParser = Y));
            else if (typeof define === s && define.amd)
              (e.r, void 0 !== Y && e.v(Y));
            else typeof n !== a && (n.UAParser = Y);
            var Q = typeof n !== a && (n.jQuery || n.Zepto);
            if (Q && !Q.ua) {
              var Z = new Y();
              ((Q.ua = Z.getResult()),
                (Q.ua.get = function () {
                  return Z.getUA();
                }),
                (Q.ua.set = function (e) {
                  Z.setUA(e);
                  var t = Z.getResult();
                  for (var r in t) Q.ua[r] = t[r];
                }));
            }
          })(this);
        },
      },
      i = {};
    function s(e) {
      var t = i[e];
      if (void 0 !== t) return t.exports;
      var r = (i[e] = { exports: {} }),
        a = !0;
      try {
        (n[e].call(r.exports, r, r.exports, s), (a = !1));
      } finally {
        a && delete i[e];
      }
      return r.exports;
    }
    ((s.ab = '/ROOT/node_modules/next/dist/compiled/ua-parser-js/'),
      (t.exports = s(226)));
  },
  60567,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n,
      i = {
        isBot: function () {
          return o;
        },
        userAgent: function () {
          return u;
        },
        userAgentFromString: function () {
          return l;
        },
      };
    for (var s in i) Object.defineProperty(r, s, { enumerable: !0, get: i[s] });
    let a = (n = e.r(6992)) && n.__esModule ? n : { default: n };
    function o(e) {
      return /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Google-InspectionTool|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i.test(
        e
      );
    }
    function l(e) {
      return { ...(0, a.default)(e), isBot: void 0 !== e && o(e) };
    }
    function u({ headers: e }) {
      return l(e.get('user-agent') || void 0);
    }
  },
  98214,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'URLPattern', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
    let n = 'u' < typeof URLPattern ? void 0 : URLPattern;
  },
  66229,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'after', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = e.r(56704);
    function i(e) {
      let t = n.workAsyncStorage.getStore();
      if (!t)
        throw Object.defineProperty(
          Error(
            '`after` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context'
          ),
          '__NEXT_ERROR_CODE',
          { value: 'E468', enumerable: !1, configurable: !0 }
        );
      let { afterContext: r } = t;
      return r.after(e);
    }
  },
  3368,
  (e, t, r) => {
    'use strict';
    var n, i;
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      (n = e.r(66229)),
      (i = r),
      Object.keys(n).forEach(function (e) {
        'default' === e ||
          Object.prototype.hasOwnProperty.call(i, e) ||
          Object.defineProperty(i, e, {
            enumerable: !0,
            get: function () {
              return n[e];
            },
          });
      }));
  },
  39622,
  (e, t, r) => {
    'use strict';
    t.exports = e.r(18622);
  },
  49518,
  (e, t, r) => {
    'use strict';
    t.exports = e.r(39622).vendored['react-rsc'].React;
  },
  77753,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      DynamicServerError: function () {
        return a;
      },
      isDynamicServerError: function () {
        return o;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = 'DYNAMIC_SERVER_USAGE';
    class a extends Error {
      constructor(e) {
        (super(`Dynamic server usage: ${e}`),
          (this.description = e),
          (this.digest = s));
      }
    }
    function o(e) {
      return (
        'object' == typeof e &&
        null !== e &&
        'digest' in e &&
        'string' == typeof e.digest &&
        e.digest === s
      );
    }
    ('function' == typeof r.default ||
      ('object' == typeof r.default && null !== r.default)) &&
      void 0 === r.default.__esModule &&
      (Object.defineProperty(r.default, '__esModule', { value: !0 }),
      Object.assign(r.default, r),
      (t.exports = r.default));
  },
  80773,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      StaticGenBailoutError: function () {
        return a;
      },
      isStaticGenBailoutError: function () {
        return o;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = 'NEXT_STATIC_GEN_BAILOUT';
    class a extends Error {
      constructor(...e) {
        (super(...e), (this.code = s));
      }
    }
    function o(e) {
      return 'object' == typeof e && null !== e && 'code' in e && e.code === s;
    }
    ('function' == typeof r.default ||
      ('object' == typeof r.default && null !== r.default)) &&
      void 0 === r.default.__esModule &&
      (Object.defineProperty(r.default, '__esModule', { value: !0 }),
      Object.assign(r.default, r),
      (t.exports = r.default));
  },
  37138,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      isHangingPromiseRejectionError: function () {
        return s;
      },
      makeDevtoolsIOAwarePromise: function () {
        return h;
      },
      makeHangingPromise: function () {
        return u;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    function s(e) {
      return (
        'object' == typeof e && null !== e && 'digest' in e && e.digest === a
      );
    }
    let a = 'HANGING_PROMISE_REJECTION';
    class o extends Error {
      constructor(e, t) {
        (super(
          `During prerendering, ${t} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${t} to a different context by using \`setTimeout\`, \`after\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route "${e}".`
        ),
          (this.route = e),
          (this.expression = t),
          (this.digest = a));
      }
    }
    let l = new WeakMap();
    function u(e, t, r) {
      if (e.aborted) return Promise.reject(new o(t, r));
      {
        let n = new Promise((n, i) => {
          let s = i.bind(null, new o(t, r)),
            a = l.get(e);
          if (a) a.push(s);
          else {
            let t = [s];
            (l.set(e, t),
              e.addEventListener(
                'abort',
                () => {
                  for (let e = 0; e < t.length; e++) t[e]();
                },
                { once: !0 }
              ));
          }
        });
        return (n.catch(c), n);
      }
    }
    function c() {}
    function h(e, t, r) {
      return t.stagedRendering
        ? t.stagedRendering.delayUntilStage(r, void 0, e)
        : new Promise((t) => {
            setTimeout(() => {
              t(e);
            }, 0);
          });
    }
  },
  13332,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      METADATA_BOUNDARY_NAME: function () {
        return s;
      },
      OUTLET_BOUNDARY_NAME: function () {
        return o;
      },
      ROOT_LAYOUT_BOUNDARY_NAME: function () {
        return l;
      },
      VIEWPORT_BOUNDARY_NAME: function () {
        return a;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = '__next_metadata_boundary__',
      a = '__next_viewport_boundary__',
      o = '__next_outlet_boundary__',
      l = '__next_root_layout_boundary__';
  },
  18697,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      atLeastOneTask: function () {
        return o;
      },
      scheduleImmediate: function () {
        return a;
      },
      scheduleOnNextTick: function () {
        return s;
      },
      waitAtLeastOneReactRenderTask: function () {
        return l;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = (e) => {
        Promise.resolve().then(() => {
          process.nextTick(e);
        });
      },
      a = (e) => {
        setImmediate(e);
      };
    function o() {
      return new Promise((e) => a(e));
    }
    function l() {
      return new Promise((e) => setImmediate(e));
    }
  },
  39491,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      BailoutToCSRError: function () {
        return a;
      },
      isBailoutToCSRError: function () {
        return o;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';
    class a extends Error {
      constructor(e) {
        (super(`Bail out to client-side rendering: ${e}`),
          (this.reason = e),
          (this.digest = s));
      }
    }
    function o(e) {
      return (
        'object' == typeof e && null !== e && 'digest' in e && e.digest === s
      );
    }
  },
  35121,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'InvariantError', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
    class n extends Error {
      constructor(e, t) {
        (super(
          `Invariant: ${e.endsWith('.') ? e : e + '.'} This is a bug in Next.js.`,
          t
        ),
          (this.name = 'InvariantError'));
      }
    }
  },
  21401,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n,
      i,
      s = {
        Postpone: function () {
          return k;
        },
        PreludeState: function () {
          return Q;
        },
        abortAndThrowOnSynchronousRequestDataAccess: function () {
          return T;
        },
        abortOnSynchronousPlatformIOAccess: function () {
          return O;
        },
        accessedDynamicData: function () {
          return D;
        },
        annotateDynamicAccess: function () {
          return B;
        },
        consumeDynamicAccess: function () {
          return $;
        },
        createDynamicTrackingState: function () {
          return b;
        },
        createDynamicValidationState: function () {
          return v;
        },
        createHangingInputAbortSignal: function () {
          return M;
        },
        createRenderInBrowserAbortSignal: function () {
          return U;
        },
        delayUntilRuntimeStage: function () {
          return er;
        },
        formatDynamicAPIAccesses: function () {
          return L;
        },
        getFirstDynamicReason: function () {
          return w;
        },
        getStaticShellDisallowedDynamicReasons: function () {
          return et;
        },
        isDynamicPostpone: function () {
          return A;
        },
        isPrerenderInterruptedError: function () {
          return j;
        },
        logDisallowedDynamicError: function () {
          return Z;
        },
        markCurrentScopeAsDynamic: function () {
          return _;
        },
        postponeWithTracking: function () {
          return P;
        },
        throwIfDisallowedDynamic: function () {
          return ee;
        },
        throwToInterruptStaticGeneration: function () {
          return E;
        },
        trackAllowedDynamicAccess: function () {
          return K;
        },
        trackDynamicDataInDynamicRender: function () {
          return S;
        },
        trackDynamicHoleInRuntimeShell: function () {
          return X;
        },
        trackDynamicHoleInStaticShell: function () {
          return J;
        },
        useDynamicRouteParams: function () {
          return q;
        },
        useDynamicSearchParams: function () {
          return V;
        },
      };
    for (var a in s) Object.defineProperty(r, a, { enumerable: !0, get: s[a] });
    let o = (n = e.r(49518)) && n.__esModule ? n : { default: n },
      l = e.r(77753),
      u = e.r(80773),
      c = e.r(32319),
      h = e.r(56704),
      d = e.r(37138),
      p = e.r(13332),
      f = e.r(18697),
      g = e.r(39491),
      m = e.r(35121),
      y = 'function' == typeof o.default.unstable_postpone;
    function b(e) {
      return {
        isDebugDynamicAccesses: e,
        dynamicAccesses: [],
        syncDynamicErrorWithStack: null,
      };
    }
    function v() {
      return {
        hasSuspenseAboveBody: !1,
        hasDynamicMetadata: !1,
        dynamicMetadata: null,
        hasDynamicViewport: !1,
        hasAllowedDynamic: !1,
        dynamicErrors: [],
      };
    }
    function w(e) {
      var t;
      return null == (t = e.dynamicAccesses[0]) ? void 0 : t.expression;
    }
    function _(e, t, r) {
      if (t)
        switch (t.type) {
          case 'cache':
          case 'unstable-cache':
          case 'private-cache':
            return;
        }
      if (!e.forceDynamic && !e.forceStatic) {
        if (e.dynamicShouldError)
          throw Object.defineProperty(
            new u.StaticGenBailoutError(
              `Route ${e.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${r}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E553', enumerable: !1, configurable: !0 }
          );
        if (t)
          switch (t.type) {
            case 'prerender-ppr':
              return P(e.route, r, t.dynamicTracking);
            case 'prerender-legacy':
              t.revalidate = 0;
              let n = Object.defineProperty(
                new l.DynamicServerError(
                  `Route ${e.route} couldn't be rendered statically because it used ${r}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E550', enumerable: !1, configurable: !0 }
              );
              throw (
                (e.dynamicUsageDescription = r),
                (e.dynamicUsageStack = n.stack),
                n
              );
          }
      }
    }
    function E(e, t, r) {
      let n = Object.defineProperty(
        new l.DynamicServerError(
          `Route ${t.route} couldn't be rendered statically because it used \`${e}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E558', enumerable: !1, configurable: !0 }
      );
      throw (
        (r.revalidate = 0),
        (t.dynamicUsageDescription = e),
        (t.dynamicUsageStack = n.stack),
        n
      );
    }
    function S(e) {
      switch (e.type) {
        case 'cache':
        case 'unstable-cache':
        case 'private-cache':
          return;
      }
    }
    function R(e, t, r) {
      let n = N(
        `Route ${e} needs to bail out of prerendering at this point because it used ${t}.`
      );
      r.controller.abort(n);
      let i = r.dynamicTracking;
      i &&
        i.dynamicAccesses.push({
          stack: i.isDebugDynamicAccesses ? Error().stack : void 0,
          expression: t,
        });
    }
    function O(e, t, r, n) {
      let i = n.dynamicTracking;
      (R(e, t, n),
        i &&
          null === i.syncDynamicErrorWithStack &&
          (i.syncDynamicErrorWithStack = r));
    }
    function T(e, t, r, n) {
      if (!1 === n.controller.signal.aborted) {
        R(e, t, n);
        let i = n.dynamicTracking;
        i &&
          null === i.syncDynamicErrorWithStack &&
          (i.syncDynamicErrorWithStack = r);
      }
      throw N(
        `Route ${e} needs to bail out of prerendering at this point because it used ${t}.`
      );
    }
    function k({ reason: e, route: t }) {
      let r = c.workUnitAsyncStorage.getStore();
      P(t, e, r && 'prerender-ppr' === r.type ? r.dynamicTracking : null);
    }
    function P(e, t, r) {
      ((function () {
        if (!y)
          throw Object.defineProperty(
            Error(
              'Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js'
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E224', enumerable: !1, configurable: !0 }
          );
      })(),
        r &&
          r.dynamicAccesses.push({
            stack: r.isDebugDynamicAccesses ? Error().stack : void 0,
            expression: t,
          }),
        o.default.unstable_postpone(x(e, t)));
    }
    function x(e, t) {
      return `Route ${e} needs to bail out of prerendering at this point because it used ${t}. React throws this special object to indicate where. It should not be caught by your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
    }
    function A(e) {
      return (
        'object' == typeof e &&
        null !== e &&
        'string' == typeof e.message &&
        C(e.message)
      );
    }
    function C(e) {
      return (
        e.includes(
          'needs to bail out of prerendering at this point because it used'
        ) &&
        e.includes(
          'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'
        )
      );
    }
    if (!1 === C(x('%%%', '^^^')))
      throw Object.defineProperty(
        Error(
          'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E296', enumerable: !1, configurable: !0 }
      );
    let I = 'NEXT_PRERENDER_INTERRUPTED';
    function N(e) {
      let t = Object.defineProperty(Error(e), '__NEXT_ERROR_CODE', {
        value: 'E394',
        enumerable: !1,
        configurable: !0,
      });
      return ((t.digest = I), t);
    }
    function j(e) {
      return (
        'object' == typeof e &&
        null !== e &&
        e.digest === I &&
        'name' in e &&
        'message' in e &&
        e instanceof Error
      );
    }
    function D(e) {
      return e.length > 0;
    }
    function $(e, t) {
      return (e.dynamicAccesses.push(...t.dynamicAccesses), e.dynamicAccesses);
    }
    function L(e) {
      return e
        .filter((e) => 'string' == typeof e.stack && e.stack.length > 0)
        .map(
          ({ expression: e, stack: t }) => (
            (t = t
              .split('\n')
              .slice(4)
              .filter(
                (e) =>
                  !(
                    e.includes('node_modules/next/') ||
                    e.includes(' (<anonymous>)') ||
                    e.includes(' (node:')
                  )
              )
              .join('\n')),
            `Dynamic API Usage Debug - ${e}:
${t}`
          )
        );
    }
    function U() {
      let e = new AbortController();
      return (
        e.abort(
          Object.defineProperty(
            new g.BailoutToCSRError('Render in Browser'),
            '__NEXT_ERROR_CODE',
            { value: 'E721', enumerable: !1, configurable: !0 }
          )
        ),
        e.signal
      );
    }
    function M(e) {
      switch (e.type) {
        case 'prerender':
        case 'prerender-runtime':
          let t = new AbortController();
          if (e.cacheSignal)
            e.cacheSignal.inputReady().then(() => {
              t.abort();
            });
          else {
            let r = (0, c.getRuntimeStagePromise)(e);
            r
              ? r.then(() => (0, f.scheduleOnNextTick)(() => t.abort()))
              : (0, f.scheduleOnNextTick)(() => t.abort());
          }
          return t.signal;
        case 'prerender-client':
        case 'prerender-ppr':
        case 'prerender-legacy':
        case 'request':
        case 'cache':
        case 'private-cache':
        case 'unstable-cache':
          return;
      }
    }
    function B(e, t) {
      let r = t.dynamicTracking;
      r &&
        r.dynamicAccesses.push({
          stack: r.isDebugDynamicAccesses ? Error().stack : void 0,
          expression: e,
        });
    }
    function q(e) {
      let t = h.workAsyncStorage.getStore(),
        r = c.workUnitAsyncStorage.getStore();
      if (t && r)
        switch (r.type) {
          case 'prerender-client':
          case 'prerender': {
            let n = r.fallbackRouteParams;
            n &&
              n.size > 0 &&
              o.default.use(
                (0, d.makeHangingPromise)(r.renderSignal, t.route, e)
              );
            break;
          }
          case 'prerender-ppr': {
            let n = r.fallbackRouteParams;
            if (n && n.size > 0) return P(t.route, e, r.dynamicTracking);
            break;
          }
          case 'prerender-runtime':
            throw Object.defineProperty(
              new m.InvariantError(
                `\`${e}\` was called during a runtime prerender. Next.js should be preventing ${e} from being included in server components statically, but did not in this case.`
              ),
              '__NEXT_ERROR_CODE',
              { value: 'E771', enumerable: !1, configurable: !0 }
            );
          case 'cache':
          case 'private-cache':
            throw Object.defineProperty(
              new m.InvariantError(
                `\`${e}\` was called inside a cache scope. Next.js should be preventing ${e} from being included in server components statically, but did not in this case.`
              ),
              '__NEXT_ERROR_CODE',
              { value: 'E745', enumerable: !1, configurable: !0 }
            );
        }
    }
    function V(e) {
      let t = h.workAsyncStorage.getStore(),
        r = c.workUnitAsyncStorage.getStore();
      if (t)
        switch ((!r && (0, c.throwForMissingRequestStore)(e), r.type)) {
          case 'prerender-client':
            o.default.use(
              (0, d.makeHangingPromise)(r.renderSignal, t.route, e)
            );
            break;
          case 'prerender-legacy':
          case 'prerender-ppr':
            if (t.forceStatic) return;
            throw Object.defineProperty(
              new g.BailoutToCSRError(e),
              '__NEXT_ERROR_CODE',
              { value: 'E394', enumerable: !1, configurable: !0 }
            );
          case 'prerender':
          case 'prerender-runtime':
            throw Object.defineProperty(
              new m.InvariantError(
                `\`${e}\` was called from a Server Component. Next.js should be preventing ${e} from being included in server components statically, but did not in this case.`
              ),
              '__NEXT_ERROR_CODE',
              { value: 'E795', enumerable: !1, configurable: !0 }
            );
          case 'cache':
          case 'unstable-cache':
          case 'private-cache':
            throw Object.defineProperty(
              new m.InvariantError(
                `\`${e}\` was called inside a cache scope. Next.js should be preventing ${e} from being included in server components statically, but did not in this case.`
              ),
              '__NEXT_ERROR_CODE',
              { value: 'E745', enumerable: !1, configurable: !0 }
            );
          case 'request':
            return;
        }
    }
    let W = /\n\s+at Suspense \(<anonymous>\)/,
      G = RegExp(
        `\\n\\s+at Suspense \\(<anonymous>\\)(?:(?!\\n\\s+at (?:body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6) \\(<anonymous>\\))[\\s\\S])*?\\n\\s+at ${p.ROOT_LAYOUT_BOUNDARY_NAME} \\([^\\n]*\\)`
      ),
      H = RegExp(`\\n\\s+at ${p.METADATA_BOUNDARY_NAME}[\\n\\s]`),
      F = RegExp(`\\n\\s+at ${p.VIEWPORT_BOUNDARY_NAME}[\\n\\s]`),
      z = RegExp(`\\n\\s+at ${p.OUTLET_BOUNDARY_NAME}[\\n\\s]`);
    function K(e, t, r, n) {
      if (!z.test(t)) {
        if (H.test(t)) {
          r.hasDynamicMetadata = !0;
          return;
        }
        if (F.test(t)) {
          r.hasDynamicViewport = !0;
          return;
        }
        if (G.test(t)) {
          ((r.hasAllowedDynamic = !0), (r.hasSuspenseAboveBody = !0));
          return;
        } else if (W.test(t)) {
          r.hasAllowedDynamic = !0;
          return;
        } else {
          if (n.syncDynamicErrorWithStack)
            return void r.dynamicErrors.push(n.syncDynamicErrorWithStack);
          let i = Y(
            `Route "${e.route}": Uncached data was accessed outside of <Suspense>. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/blocking-route`,
            t
          );
          return void r.dynamicErrors.push(i);
        }
      }
    }
    function X(e, t, r, n) {
      if (!z.test(t)) {
        if (H.test(t)) {
          r.dynamicMetadata = Y(
            `Route "${e.route}": Uncached data or \`connection()\` was accessed inside \`generateMetadata\`. Except for this instance, the page would have been entirely prerenderable which may have been the intended behavior. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`,
            t
          );
          return;
        }
        if (F.test(t)) {
          let n = Y(
            `Route "${e.route}": Uncached data or \`connection()\` was accessed inside \`generateViewport\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`,
            t
          );
          r.dynamicErrors.push(n);
          return;
        }
        if (G.test(t)) {
          ((r.hasAllowedDynamic = !0), (r.hasSuspenseAboveBody = !0));
          return;
        } else if (W.test(t)) {
          r.hasAllowedDynamic = !0;
          return;
        } else {
          if (n.syncDynamicErrorWithStack)
            return void r.dynamicErrors.push(n.syncDynamicErrorWithStack);
          let i = Y(
            `Route "${e.route}": Uncached data or \`connection()\` was accessed outside of \`<Suspense>\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/blocking-route`,
            t
          );
          return void r.dynamicErrors.push(i);
        }
      }
    }
    function J(e, t, r, n) {
      if (!z.test(t)) {
        if (H.test(t)) {
          r.dynamicMetadata = Y(
            `Route "${e.route}": Runtime data such as \`cookies()\`, \`headers()\`, \`params\`, or \`searchParams\` was accessed inside \`generateMetadata\` or you have file-based metadata such as icons that depend on dynamic params segments. Except for this instance, the page would have been entirely prerenderable which may have been the intended behavior. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`,
            t
          );
          return;
        }
        if (F.test(t)) {
          let n = Y(
            `Route "${e.route}": Runtime data such as \`cookies()\`, \`headers()\`, \`params\`, or \`searchParams\` was accessed inside \`generateViewport\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`,
            t
          );
          r.dynamicErrors.push(n);
          return;
        }
        if (G.test(t)) {
          ((r.hasAllowedDynamic = !0), (r.hasSuspenseAboveBody = !0));
          return;
        } else if (W.test(t)) {
          r.hasAllowedDynamic = !0;
          return;
        } else {
          if (n.syncDynamicErrorWithStack)
            return void r.dynamicErrors.push(n.syncDynamicErrorWithStack);
          let i = Y(
            `Route "${e.route}": Runtime data such as \`cookies()\`, \`headers()\`, \`params\`, or \`searchParams\` was accessed outside of \`<Suspense>\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/blocking-route`,
            t
          );
          return void r.dynamicErrors.push(i);
        }
      }
    }
    function Y(e, t) {
      let r = Object.defineProperty(Error(e), '__NEXT_ERROR_CODE', {
        value: 'E394',
        enumerable: !1,
        configurable: !0,
      });
      return ((r.stack = r.name + ': ' + e + t), r);
    }
    var Q =
      (((i = {})[(i.Full = 0)] = 'Full'),
      (i[(i.Empty = 1)] = 'Empty'),
      (i[(i.Errored = 2)] = 'Errored'),
      i);
    function Z(e, t) {
      (console.error(t),
        e.dev ||
          (e.hasReadableErrorStacks
            ? console.error(
                `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \`next dev\`, then open "${e.route}" in your browser to investigate the error.`
              )
            : console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:
  - Start the app in development mode by running \`next dev\`, then open "${e.route}" in your browser to investigate the error.
  - Rerun the production build with \`next build --debug-prerender\` to generate better stack traces.`)));
    }
    function ee(e, t, r, n) {
      if (n.syncDynamicErrorWithStack)
        throw (
          Z(e, n.syncDynamicErrorWithStack),
          new u.StaticGenBailoutError()
        );
      if (0 !== t) {
        if (r.hasSuspenseAboveBody) return;
        let n = r.dynamicErrors;
        if (n.length > 0) {
          for (let t = 0; t < n.length; t++) Z(e, n[t]);
          throw new u.StaticGenBailoutError();
        }
        if (r.hasDynamicViewport)
          throw (
            console.error(
              `Route "${e.route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`
            ),
            new u.StaticGenBailoutError()
          );
        if (1 === t)
          throw (
            console.error(
              `Route "${e.route}" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`
            ),
            new u.StaticGenBailoutError()
          );
      } else if (!1 === r.hasAllowedDynamic && r.hasDynamicMetadata)
        throw (
          console.error(
            `Route "${e.route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`
          ),
          new u.StaticGenBailoutError()
        );
    }
    function et(e, t, r) {
      if (r.hasSuspenseAboveBody) return [];
      if (0 !== t) {
        let n = r.dynamicErrors;
        if (n.length > 0) return n;
        if (1 === t)
          return [
            Object.defineProperty(
              new m.InvariantError(
                `Route "${e.route}" did not produce a static shell and Next.js was unable to determine a reason.`
              ),
              '__NEXT_ERROR_CODE',
              { value: 'E936', enumerable: !1, configurable: !0 }
            ),
          ];
      } else if (
        !1 === r.hasAllowedDynamic &&
        0 === r.dynamicErrors.length &&
        r.dynamicMetadata
      )
        return [r.dynamicMetadata];
      return [];
    }
    function er(e, t) {
      return e.runtimeStagePromise ? e.runtimeStagePromise.then(() => t) : t;
    }
  },
  19048,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n = {
      isRequestAPICallableInsideAfter: function () {
        return u;
      },
      throwForSearchParamsAccessInUseCache: function () {
        return l;
      },
      throwWithStaticGenerationBailoutErrorWithDynamicError: function () {
        return o;
      },
    };
    for (var i in n) Object.defineProperty(r, i, { enumerable: !0, get: n[i] });
    let s = e.r(80773),
      a = e.r(24725);
    function o(e, t) {
      throw Object.defineProperty(
        new s.StaticGenBailoutError(
          `Route ${e} with \`dynamic = "error"\` couldn't be rendered statically because it used ${t}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E543', enumerable: !1, configurable: !0 }
      );
    }
    function l(e, t) {
      let r = Object.defineProperty(
        Error(
          `Route ${e.route} used \`searchParams\` inside "use cache". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \`searchParams\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E842', enumerable: !1, configurable: !0 }
      );
      throw (
        Error.captureStackTrace(r, t),
        (e.invalidDynamicUsageError ??= r),
        r
      );
    }
    function u() {
      let e = a.afterTaskAsyncStorage.getStore();
      return (null == e ? void 0 : e.rootTaskSpawnPhase) === 'action';
    }
  },
  45470,
  (e, t, r) => {
    'use strict';
    function n() {
      let e,
        t,
        r = new Promise((r, n) => {
          ((e = r), (t = n));
        });
      return { resolve: e, reject: t, promise: r };
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'createPromiseWithResolvers', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
  },
  98771,
  (e, t, r) => {
    'use strict';
    Object.defineProperty(r, '__esModule', { value: !0 });
    var n,
      i = {
        RenderStage: function () {
          return l;
        },
        StagedRenderingController: function () {
          return u;
        },
      };
    for (var s in i) Object.defineProperty(r, s, { enumerable: !0, get: i[s] });
    let a = e.r(35121),
      o = e.r(45470);
    var l =
      (((n = {})[(n.Before = 1)] = 'Before'),
      (n[(n.Static = 2)] = 'Static'),
      (n[(n.Runtime = 3)] = 'Runtime'),
      (n[(n.Dynamic = 4)] = 'Dynamic'),
      (n[(n.Abandoned = 5)] = 'Abandoned'),
      n);
    class u {
      constructor(e = null, t) {
        ((this.abortSignal = e),
          (this.hasRuntimePrefetch = t),
          (this.currentStage = 1),
          (this.staticInterruptReason = null),
          (this.runtimeInterruptReason = null),
          (this.staticStageEndTime = 1 / 0),
          (this.runtimeStageEndTime = 1 / 0),
          (this.runtimeStageListeners = []),
          (this.dynamicStageListeners = []),
          (this.runtimeStagePromise = (0, o.createPromiseWithResolvers)()),
          (this.dynamicStagePromise = (0, o.createPromiseWithResolvers)()),
          (this.mayAbandon = !1),
          e &&
            (e.addEventListener(
              'abort',
              () => {
                let { reason: t } = e;
                (this.currentStage < 3 &&
                  (this.runtimeStagePromise.promise.catch(c),
                  this.runtimeStagePromise.reject(t)),
                  (this.currentStage < 4 || 5 === this.currentStage) &&
                    (this.dynamicStagePromise.promise.catch(c),
                    this.dynamicStagePromise.reject(t)));
              },
              { once: !0 }
            ),
            (this.mayAbandon = !0)));
      }
      onStage(e, t) {
        if (this.currentStage >= e) t();
        else if (3 === e) this.runtimeStageListeners.push(t);
        else if (4 === e) this.dynamicStageListeners.push(t);
        else
          throw Object.defineProperty(
            new a.InvariantError(`Invalid render stage: ${e}`),
            '__NEXT_ERROR_CODE',
            { value: 'E881', enumerable: !1, configurable: !0 }
          );
      }
      canSyncInterrupt() {
        if (1 === this.currentStage) return !1;
        let e = this.hasRuntimePrefetch ? 4 : 3;
        return this.currentStage < e;
      }
      syncInterruptCurrentStageWithReason(e) {
        if (1 !== this.currentStage) {
          if (this.mayAbandon) return this.abandonRenderImpl();
          switch (this.currentStage) {
            case 2:
              ((this.staticInterruptReason = e), this.advanceStage(4));
              return;
            case 3:
              this.hasRuntimePrefetch &&
                ((this.runtimeInterruptReason = e), this.advanceStage(4));
              return;
          }
        }
      }
      getStaticInterruptReason() {
        return this.staticInterruptReason;
      }
      getRuntimeInterruptReason() {
        return this.runtimeInterruptReason;
      }
      getStaticStageEndTime() {
        return this.staticStageEndTime;
      }
      getRuntimeStageEndTime() {
        return this.runtimeStageEndTime;
      }
      abandonRender() {
        if (!this.mayAbandon)
          throw Object.defineProperty(
            new a.InvariantError(
              '`abandonRender` called on a stage controller that cannot be abandoned.'
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E938', enumerable: !1, configurable: !0 }
          );
        this.abandonRenderImpl();
      }
      abandonRenderImpl() {
        let { currentStage: e } = this;
        switch (e) {
          case 2:
            ((this.currentStage = 5), this.resolveRuntimeStage());
            return;
          case 3:
            this.currentStage = 5;
            return;
        }
      }
      advanceStage(e) {
        if (e <= this.currentStage) return;
        let t = this.currentStage;
        if (
          ((this.currentStage = e),
          t < 3 &&
            e >= 3 &&
            ((this.staticStageEndTime =
              performance.now() + performance.timeOrigin),
            this.resolveRuntimeStage()),
          t < 4 && e >= 4)
        ) {
          ((this.runtimeStageEndTime =
            performance.now() + performance.timeOrigin),
            this.resolveDynamicStage());
          return;
        }
      }
      resolveRuntimeStage() {
        let e = this.runtimeStageListeners;
        for (let t = 0; t < e.length; t++) e[t]();
        ((e.length = 0), this.runtimeStagePromise.resolve());
      }
      resolveDynamicStage() {
        let e = this.dynamicStageListeners;
        for (let t = 0; t < e.length; t++) e[t]();
        ((e.length = 0), this.dynamicStagePromise.resolve());
      }
      getStagePromise(e) {
        switch (e) {
          case 3:
            return this.runtimeStagePromise.promise;
          case 4:
            return this.dynamicStagePromise.promise;
          default:
            throw Object.defineProperty(
              new a.InvariantError(`Invalid render stage: ${e}`),
              '__NEXT_ERROR_CODE',
              { value: 'E881', enumerable: !1, configurable: !0 }
            );
        }
      }
      waitForStage(e) {
        return this.getStagePromise(e);
      }
      delayUntilStage(e, t, r) {
        var n, i, s;
        let a,
          o =
            ((n = this.getStagePromise(e)),
            (i = t),
            (s = r),
            (a = new Promise((e, t) => {
              n.then(e.bind(null, s), t);
            })),
            void 0 !== i && (a.displayName = i),
            a);
        return (this.abortSignal && o.catch(c), o);
      }
    }
    function c() {}
  },
  44822,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'connection', {
        enumerable: !0,
        get: function () {
          return u;
        },
      }));
    let n = e.r(56704),
      i = e.r(32319),
      s = e.r(21401),
      a = e.r(80773),
      o = e.r(37138),
      l = e.r(19048);
    function u() {
      let e = n.workAsyncStorage.getStore(),
        t = i.workUnitAsyncStorage.getStore();
      if (e) {
        if (
          t &&
          'after' === t.phase &&
          !(0, l.isRequestAPICallableInsideAfter)()
        )
          throw Object.defineProperty(
            Error(
              `Route ${e.route} used \`connection()\` inside \`after()\`. The \`connection()\` function is used to indicate the subsequent code must only run when there is an actual Request, but \`after()\` executes after the request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E827', enumerable: !1, configurable: !0 }
          );
        if (e.forceStatic) return Promise.resolve(void 0);
        if (e.dynamicShouldError)
          throw Object.defineProperty(
            new a.StaticGenBailoutError(
              `Route ${e.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`connection()\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E847', enumerable: !1, configurable: !0 }
          );
        if (t)
          switch (t.type) {
            case 'cache': {
              let t = Object.defineProperty(
                Error(
                  `Route ${e.route} used \`connection()\` inside "use cache". The \`connection()\` function is used to indicate the subsequent code must only run when there is an actual request, but caches must be able to be produced before a request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E841', enumerable: !1, configurable: !0 }
              );
              throw (
                Error.captureStackTrace(t, u),
                (e.invalidDynamicUsageError ??= t),
                t
              );
            }
            case 'private-cache': {
              let t = Object.defineProperty(
                Error(
                  `Route ${e.route} used \`connection()\` inside "use cache: private". The \`connection()\` function is used to indicate the subsequent code must only run when there is an actual navigation request, but caches must be able to be produced before a navigation request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E837', enumerable: !1, configurable: !0 }
              );
              throw (
                Error.captureStackTrace(t, u),
                (e.invalidDynamicUsageError ??= t),
                t
              );
            }
            case 'unstable-cache':
              throw Object.defineProperty(
                Error(
                  `Route ${e.route} used \`connection()\` inside a function cached with \`unstable_cache()\`. The \`connection()\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E840', enumerable: !1, configurable: !0 }
              );
            case 'prerender':
            case 'prerender-client':
            case 'prerender-runtime':
              return (0, o.makeHangingPromise)(
                t.renderSignal,
                e.route,
                '`connection()`'
              );
            case 'prerender-ppr':
              return (0, s.postponeWithTracking)(
                e.route,
                'connection',
                t.dynamicTracking
              );
            case 'prerender-legacy':
              return (0, s.throwToInterruptStaticGeneration)(
                'connection',
                e,
                t
              );
            case 'request':
              return (
                (0, s.trackDynamicDataInDynamicRender)(t),
                Promise.resolve(void 0)
              );
          }
      }
      (0, i.throwForMissingRequestStore)('connection');
    }
    e.r(98771);
  },
  55207,
  (e, t, r) => {
    let n = {
      NextRequest: e.r(75447).NextRequest,
      NextResponse: e.r(9052).NextResponse,
      ImageResponse: e.r(2075).ImageResponse,
      userAgentFromString: e.r(60567).userAgentFromString,
      userAgent: e.r(60567).userAgent,
      URLPattern: e.r(98214).URLPattern,
      after: e.r(3368).after,
      connection: e.r(44822).connection,
    };
    ((t.exports = n),
      (r.NextRequest = n.NextRequest),
      (r.NextResponse = n.NextResponse),
      (r.ImageResponse = n.ImageResponse),
      (r.userAgentFromString = n.userAgentFromString),
      (r.userAgent = n.userAgent),
      (r.URLPattern = n.URLPattern),
      (r.after = n.after),
      (r.connection = n.connection));
  },
  89997,
  (e) => {
    'use strict';
    let t, r, n;
    async function i() {
      return (
        '_ENTRIES' in globalThis &&
        _ENTRIES.middleware_instrumentation &&
        (await _ENTRIES.middleware_instrumentation)
      );
    }
    let s = null;
    async function a() {
      if ('phase-production-build' === process.env.NEXT_PHASE) return;
      s || (s = i());
      let e = await s;
      if (null == e ? void 0 : e.register)
        try {
          await e.register();
        } catch (e) {
          throw (
            (e.message = `An error occurred while loading instrumentation hook: ${e.message}`),
            e
          );
        }
    }
    async function o(...e) {
      let t = await i();
      try {
        var r;
        await (null == t || null == (r = t.onRequestError)
          ? void 0
          : r.call(t, ...e));
      } catch (e) {
        console.error('Error in instrumentation.onRequestError:', e);
      }
    }
    let l = null;
    class u extends Error {
      constructor({ page: e }) {
        super(`The middleware "${e}" accepts an async API directly with the form:
  
  export function middleware(request, event) {
    return NextResponse.redirect('/new-location')
  }
  
  Read more: https://nextjs.org/docs/messages/middleware-new-signature
  `);
      }
    }
    class c extends Error {
      constructor() {
        super(`The request.page has been deprecated in favour of \`URLPattern\`.
  Read more: https://nextjs.org/docs/messages/middleware-request-page
  `);
      }
    }
    class h extends Error {
      constructor() {
        super(`The request.ua has been removed in favour of \`userAgent\` function.
  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
  `);
      }
    }
    let d = '_N_T_',
      p = {
        shared: 'shared',
        reactServerComponents: 'rsc',
        serverSideRendering: 'ssr',
        actionBrowser: 'action-browser',
        apiNode: 'api-node',
        apiEdge: 'api-edge',
        middleware: 'middleware',
        instrument: 'instrument',
        edgeAsset: 'edge-asset',
        appPagesBrowser: 'app-pages-browser',
        pagesDirBrowser: 'pages-dir-browser',
        pagesDirEdge: 'pages-dir-edge',
        pagesDirNode: 'pages-dir-node',
      };
    function f(e) {
      var t,
        r,
        n,
        i,
        s,
        a = [],
        o = 0;
      function l() {
        for (; o < e.length && /\s/.test(e.charAt(o)); ) o += 1;
        return o < e.length;
      }
      for (; o < e.length; ) {
        for (t = o, s = !1; l(); )
          if (',' === (r = e.charAt(o))) {
            for (
              n = o, o += 1, l(), i = o;
              o < e.length &&
              '=' !== (r = e.charAt(o)) &&
              ';' !== r &&
              ',' !== r;
            )
              o += 1;
            o < e.length && '=' === e.charAt(o)
              ? ((s = !0), (o = i), a.push(e.substring(t, n)), (t = o))
              : (o = n + 1);
          } else o += 1;
        (!s || o >= e.length) && a.push(e.substring(t, e.length));
      }
      return a;
    }
    function g(e) {
      let t = {},
        r = [];
      if (e)
        for (let [n, i] of e.entries())
          'set-cookie' === n.toLowerCase()
            ? (r.push(...f(i)), (t[n] = 1 === r.length ? r[0] : r))
            : (t[n] = i);
      return t;
    }
    function m(e) {
      try {
        return String(new URL(String(e)));
      } catch (t) {
        throw Object.defineProperty(
          Error(
            `URL is malformed "${String(e)}". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`,
            { cause: t }
          ),
          '__NEXT_ERROR_CODE',
          { value: 'E61', enumerable: !1, configurable: !0 }
        );
      }
    }
    ({
      ...p,
      GROUP: {
        builtinReact: [p.reactServerComponents, p.actionBrowser],
        serverOnly: [
          p.reactServerComponents,
          p.actionBrowser,
          p.instrument,
          p.middleware,
        ],
        neutralTarget: [p.apiNode, p.apiEdge],
        clientOnly: [p.serverSideRendering, p.appPagesBrowser],
        bundled: [
          p.reactServerComponents,
          p.actionBrowser,
          p.serverSideRendering,
          p.appPagesBrowser,
          p.shared,
          p.instrument,
          p.middleware,
        ],
        appPages: [
          p.reactServerComponents,
          p.serverSideRendering,
          p.appPagesBrowser,
          p.actionBrowser,
        ],
      },
    });
    let y = Symbol('response'),
      b = Symbol('passThrough'),
      v = Symbol('waitUntil');
    class w {
      constructor(e, t) {
        ((this[b] = !1),
          (this[v] = t
            ? { kind: 'external', function: t }
            : { kind: 'internal', promises: [] }));
      }
      respondWith(e) {
        this[y] || (this[y] = Promise.resolve(e));
      }
      passThroughOnException() {
        this[b] = !0;
      }
      waitUntil(e) {
        if ('external' === this[v].kind) return (0, this[v].function)(e);
        this[v].promises.push(e);
      }
    }
    class _ extends w {
      constructor(e) {
        var t;
        (super(e.request, null == (t = e.context) ? void 0 : t.waitUntil),
          (this.sourcePage = e.page));
      }
      get request() {
        throw Object.defineProperty(
          new u({ page: this.sourcePage }),
          '__NEXT_ERROR_CODE',
          { value: 'E394', enumerable: !1, configurable: !0 }
        );
      }
      respondWith() {
        throw Object.defineProperty(
          new u({ page: this.sourcePage }),
          '__NEXT_ERROR_CODE',
          { value: 'E394', enumerable: !1, configurable: !0 }
        );
      }
    }
    function E(e) {
      return e.replace(/\/$/, '') || '/';
    }
    function S(e) {
      let t = e.indexOf('#'),
        r = e.indexOf('?'),
        n = r > -1 && (t < 0 || r < t);
      return n || t > -1
        ? {
            pathname: e.substring(0, n ? r : t),
            query: n ? e.substring(r, t > -1 ? t : void 0) : '',
            hash: t > -1 ? e.slice(t) : '',
          }
        : { pathname: e, query: '', hash: '' };
    }
    function R(e, t) {
      if (!e.startsWith('/') || !t) return e;
      let { pathname: r, query: n, hash: i } = S(e);
      return `${t}${r}${n}${i}`;
    }
    function O(e, t) {
      if (!e.startsWith('/') || !t) return e;
      let { pathname: r, query: n, hash: i } = S(e);
      return `${r}${t}${n}${i}`;
    }
    function T(e, t) {
      if ('string' != typeof e) return !1;
      let { pathname: r } = S(e);
      return r === t || r.startsWith(t + '/');
    }
    let k = new WeakMap();
    function P(e, t) {
      let r;
      if (!t) return { pathname: e };
      let n = k.get(t);
      n || ((n = t.map((e) => e.toLowerCase())), k.set(t, n));
      let i = e.split('/', 2);
      if (!i[1]) return { pathname: e };
      let s = i[1].toLowerCase(),
        a = n.indexOf(s);
      return a < 0
        ? { pathname: e }
        : ((r = t[a]),
          { pathname: (e = e.slice(r.length + 1) || '/'), detectedLocale: r });
    }
    let x =
      /(?!^https?:\/\/)(127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\[::1\]|localhost)/;
    function A(e, t) {
      return new URL(
        String(e).replace(x, 'localhost'),
        t && String(t).replace(x, 'localhost')
      );
    }
    let C = Symbol('NextURLInternal');
    class I {
      constructor(e, t, r) {
        let n, i;
        (('object' == typeof t && 'pathname' in t) || 'string' == typeof t
          ? ((n = t), (i = r || {}))
          : (i = r || t || {}),
          (this[C] = { url: A(e, n ?? i.base), options: i, basePath: '' }),
          this.analyze());
      }
      analyze() {
        var e, t, r, n, i;
        let s = (function (e, t) {
            let { basePath: r, i18n: n, trailingSlash: i } = t.nextConfig ?? {},
              s = {
                pathname: e,
                trailingSlash: '/' !== e ? e.endsWith('/') : i,
              };
            r &&
              T(s.pathname, r) &&
              ((s.pathname = (function (e, t) {
                if (!T(e, t)) return e;
                let r = e.slice(t.length);
                return r.startsWith('/') ? r : `/${r}`;
              })(s.pathname, r)),
              (s.basePath = r));
            let a = s.pathname;
            if (
              s.pathname.startsWith('/_next/data/') &&
              s.pathname.endsWith('.json')
            ) {
              let e = s.pathname
                .replace(/^\/_next\/data\//, '')
                .replace(/\.json$/, '')
                .split('/');
              ((s.buildId = e[0]),
                (a = 'index' !== e[1] ? `/${e.slice(1).join('/')}` : '/'),
                !0 === t.parseData && (s.pathname = a));
            }
            if (n) {
              let e = t.i18nProvider
                ? t.i18nProvider.analyze(s.pathname)
                : P(s.pathname, n.locales);
              ((s.locale = e.detectedLocale),
                (s.pathname = e.pathname ?? s.pathname),
                !e.detectedLocale &&
                  s.buildId &&
                  (e = t.i18nProvider
                    ? t.i18nProvider.analyze(a)
                    : P(a, n.locales)).detectedLocale &&
                  (s.locale = e.detectedLocale));
            }
            return s;
          })(this[C].url.pathname, {
            nextConfig: this[C].options.nextConfig,
            parseData: !0,
            i18nProvider: this[C].options.i18nProvider,
          }),
          a = (function (e, t) {
            let r;
            if (t?.host && !Array.isArray(t.host))
              r = t.host.toString().split(':', 1)[0];
            else {
              if (!e.hostname) return;
              r = e.hostname;
            }
            return r.toLowerCase();
          })(this[C].url, this[C].options.headers);
        this[C].domainLocale = this[C].options.i18nProvider
          ? this[C].options.i18nProvider.detectDomainLocale(a)
          : (function (e, t, r) {
              if (e) {
                for (let n of (r && (r = r.toLowerCase()), e))
                  if (
                    t === n.domain?.split(':', 1)[0].toLowerCase() ||
                    r === n.defaultLocale.toLowerCase() ||
                    n.locales?.some((e) => e.toLowerCase() === r)
                  )
                    return n;
              }
            })(
              null == (t = this[C].options.nextConfig) || null == (e = t.i18n)
                ? void 0
                : e.domains,
              a
            );
        let o =
          (null == (r = this[C].domainLocale) ? void 0 : r.defaultLocale) ||
          (null == (i = this[C].options.nextConfig) || null == (n = i.i18n)
            ? void 0
            : n.defaultLocale);
        ((this[C].url.pathname = s.pathname),
          (this[C].defaultLocale = o),
          (this[C].basePath = s.basePath ?? ''),
          (this[C].buildId = s.buildId),
          (this[C].locale = s.locale ?? o),
          (this[C].trailingSlash = s.trailingSlash));
      }
      formatPathname() {
        var e;
        let t;
        return (
          (t = (function (e, t, r, n) {
            if (!t || t === r) return e;
            let i = e.toLowerCase();
            return !n && (T(i, '/api') || T(i, `/${t.toLowerCase()}`))
              ? e
              : R(e, `/${t}`);
          })(
            (e = {
              basePath: this[C].basePath,
              buildId: this[C].buildId,
              defaultLocale: this[C].options.forceLocale
                ? void 0
                : this[C].defaultLocale,
              locale: this[C].locale,
              pathname: this[C].url.pathname,
              trailingSlash: this[C].trailingSlash,
            }).pathname,
            e.locale,
            e.buildId ? void 0 : e.defaultLocale,
            e.ignorePrefix
          )),
          (e.buildId || !e.trailingSlash) && (t = E(t)),
          e.buildId &&
            (t = O(
              R(t, `/_next/data/${e.buildId}`),
              '/' === e.pathname ? 'index.json' : '.json'
            )),
          (t = R(t, e.basePath)),
          !e.buildId && e.trailingSlash
            ? t.endsWith('/')
              ? t
              : O(t, '/')
            : E(t)
        );
      }
      formatSearch() {
        return this[C].url.search;
      }
      get buildId() {
        return this[C].buildId;
      }
      set buildId(e) {
        this[C].buildId = e;
      }
      get locale() {
        return this[C].locale ?? '';
      }
      set locale(e) {
        var t, r;
        if (
          !this[C].locale ||
          !(null == (r = this[C].options.nextConfig) || null == (t = r.i18n)
            ? void 0
            : t.locales.includes(e))
        )
          throw Object.defineProperty(
            TypeError(`The NextURL configuration includes no locale "${e}"`),
            '__NEXT_ERROR_CODE',
            { value: 'E597', enumerable: !1, configurable: !0 }
          );
        this[C].locale = e;
      }
      get defaultLocale() {
        return this[C].defaultLocale;
      }
      get domainLocale() {
        return this[C].domainLocale;
      }
      get searchParams() {
        return this[C].url.searchParams;
      }
      get host() {
        return this[C].url.host;
      }
      set host(e) {
        this[C].url.host = e;
      }
      get hostname() {
        return this[C].url.hostname;
      }
      set hostname(e) {
        this[C].url.hostname = e;
      }
      get port() {
        return this[C].url.port;
      }
      set port(e) {
        this[C].url.port = e;
      }
      get protocol() {
        return this[C].url.protocol;
      }
      set protocol(e) {
        this[C].url.protocol = e;
      }
      get href() {
        let e = this.formatPathname(),
          t = this.formatSearch();
        return `${this.protocol}//${this.host}${e}${t}${this.hash}`;
      }
      set href(e) {
        ((this[C].url = A(e)), this.analyze());
      }
      get origin() {
        return this[C].url.origin;
      }
      get pathname() {
        return this[C].url.pathname;
      }
      set pathname(e) {
        this[C].url.pathname = e;
      }
      get hash() {
        return this[C].url.hash;
      }
      set hash(e) {
        this[C].url.hash = e;
      }
      get search() {
        return this[C].url.search;
      }
      set search(e) {
        this[C].url.search = e;
      }
      get password() {
        return this[C].url.password;
      }
      set password(e) {
        this[C].url.password = e;
      }
      get username() {
        return this[C].url.username;
      }
      set username(e) {
        this[C].url.username = e;
      }
      get basePath() {
        return this[C].basePath;
      }
      set basePath(e) {
        this[C].basePath = e.startsWith('/') ? e : `/${e}`;
      }
      toString() {
        return this.href;
      }
      toJSON() {
        return this.href;
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          href: this.href,
          origin: this.origin,
          protocol: this.protocol,
          username: this.username,
          password: this.password,
          host: this.host,
          hostname: this.hostname,
          port: this.port,
          pathname: this.pathname,
          search: this.search,
          searchParams: this.searchParams,
          hash: this.hash,
        };
      }
      clone() {
        return new I(String(this), this[C].options);
      }
    }
    var N,
      j,
      D,
      $,
      L,
      U,
      M,
      B,
      q,
      V,
      W,
      G,
      H,
      F,
      z,
      K,
      X,
      J,
      Y,
      Q,
      Z,
      ee,
      et,
      er,
      en,
      ei,
      es,
      ea,
      eo,
      el,
      eu,
      ec,
      eh,
      ed = e.i(9254);
    let ep = Symbol('internal request');
    class ef extends Request {
      constructor(e, t = {}) {
        const r = 'string' != typeof e && 'url' in e ? e.url : String(e);
        (m(r),
          t.body && 'half' !== t.duplex && (t.duplex = 'half'),
          e instanceof Request ? super(e, t) : super(r, t));
        const n = new I(r, {
          headers: g(this.headers),
          nextConfig: t.nextConfig,
        });
        this[ep] = {
          cookies: new ed.RequestCookies(this.headers),
          nextUrl: n,
          url: n.toString(),
        };
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          cookies: this.cookies,
          nextUrl: this.nextUrl,
          url: this.url,
          bodyUsed: this.bodyUsed,
          cache: this.cache,
          credentials: this.credentials,
          destination: this.destination,
          headers: Object.fromEntries(this.headers),
          integrity: this.integrity,
          keepalive: this.keepalive,
          method: this.method,
          mode: this.mode,
          redirect: this.redirect,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          signal: this.signal,
        };
      }
      get cookies() {
        return this[ep].cookies;
      }
      get nextUrl() {
        return this[ep].nextUrl;
      }
      get page() {
        throw new c();
      }
      get ua() {
        throw new h();
      }
      get url() {
        return this[ep].url;
      }
    }
    class eg {
      static get(e, t, r) {
        let n = Reflect.get(e, t, r);
        return 'function' == typeof n ? n.bind(e) : n;
      }
      static set(e, t, r, n) {
        return Reflect.set(e, t, r, n);
      }
      static has(e, t) {
        return Reflect.has(e, t);
      }
      static deleteProperty(e, t) {
        return Reflect.deleteProperty(e, t);
      }
    }
    let em = Symbol('internal response'),
      ey = new Set([301, 302, 303, 307, 308]);
    function eb(e, t) {
      var r;
      if (null == e || null == (r = e.request) ? void 0 : r.headers) {
        if (!(e.request.headers instanceof Headers))
          throw Object.defineProperty(
            Error('request.headers must be an instance of Headers'),
            '__NEXT_ERROR_CODE',
            { value: 'E119', enumerable: !1, configurable: !0 }
          );
        let r = [];
        for (let [n, i] of e.request.headers)
          (t.set('x-middleware-request-' + n, i), r.push(n));
        t.set('x-middleware-override-headers', r.join(','));
      }
    }
    class ev extends Response {
      constructor(e, t = {}) {
        super(e, t);
        const r = this.headers,
          n = new Proxy(new ed.ResponseCookies(r), {
            get(e, n, i) {
              switch (n) {
                case 'delete':
                case 'set':
                  return (...i) => {
                    let s = Reflect.apply(e[n], e, i),
                      a = new Headers(r);
                    return (
                      s instanceof ed.ResponseCookies &&
                        r.set(
                          'x-middleware-set-cookie',
                          s
                            .getAll()
                            .map((e) => (0, ed.stringifyCookie)(e))
                            .join(',')
                        ),
                      eb(t, a),
                      s
                    );
                  };
                default:
                  return eg.get(e, n, i);
              }
            },
          });
        this[em] = {
          cookies: n,
          url: t.url
            ? new I(t.url, { headers: g(r), nextConfig: t.nextConfig })
            : void 0,
        };
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          cookies: this.cookies,
          url: this.url,
          body: this.body,
          bodyUsed: this.bodyUsed,
          headers: Object.fromEntries(this.headers),
          ok: this.ok,
          redirected: this.redirected,
          status: this.status,
          statusText: this.statusText,
          type: this.type,
        };
      }
      get cookies() {
        return this[em].cookies;
      }
      static json(e, t) {
        let r = Response.json(e, t);
        return new ev(r.body, r);
      }
      static redirect(e, t) {
        let r =
          'number' == typeof t ? t : ((null == t ? void 0 : t.status) ?? 307);
        if (!ey.has(r))
          throw Object.defineProperty(
            RangeError(
              'Failed to execute "redirect" on "response": Invalid status code'
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E529', enumerable: !1, configurable: !0 }
          );
        let n = 'object' == typeof t ? t : {},
          i = new Headers(null == n ? void 0 : n.headers);
        return (
          i.set('Location', m(e)),
          new ev(null, { ...n, headers: i, status: r })
        );
      }
      static rewrite(e, t) {
        let r = new Headers(null == t ? void 0 : t.headers);
        return (
          r.set('x-middleware-rewrite', m(e)),
          eb(t, r),
          new ev(null, { ...t, headers: r })
        );
      }
      static next(e) {
        let t = new Headers(null == e ? void 0 : e.headers);
        return (
          t.set('x-middleware-next', '1'),
          eb(e, t),
          new ev(null, { ...e, headers: t })
        );
      }
    }
    function ew(e, t) {
      let r = 'string' == typeof t ? new URL(t) : t,
        n = new URL(e, t),
        i = n.origin === r.origin;
      return {
        url: i ? n.toString().slice(r.origin.length) : n.toString(),
        isRelative: i,
      };
    }
    let e_ = 'next-router-prefetch',
      eE = [
        'rsc',
        'next-router-state-tree',
        e_,
        'next-hmr-refresh',
        'next-router-segment-prefetch',
      ],
      eS = '_rsc';
    class eR extends Error {
      constructor() {
        super(
          'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'
        );
      }
      static callable() {
        throw new eR();
      }
    }
    class eO extends Headers {
      constructor(e) {
        (super(),
          (this.headers = new Proxy(e, {
            get(t, r, n) {
              if ('symbol' == typeof r) return eg.get(t, r, n);
              let i = r.toLowerCase(),
                s = Object.keys(e).find((e) => e.toLowerCase() === i);
              if (void 0 !== s) return eg.get(t, s, n);
            },
            set(t, r, n, i) {
              if ('symbol' == typeof r) return eg.set(t, r, n, i);
              let s = r.toLowerCase(),
                a = Object.keys(e).find((e) => e.toLowerCase() === s);
              return eg.set(t, a ?? r, n, i);
            },
            has(t, r) {
              if ('symbol' == typeof r) return eg.has(t, r);
              let n = r.toLowerCase(),
                i = Object.keys(e).find((e) => e.toLowerCase() === n);
              return void 0 !== i && eg.has(t, i);
            },
            deleteProperty(t, r) {
              if ('symbol' == typeof r) return eg.deleteProperty(t, r);
              let n = r.toLowerCase(),
                i = Object.keys(e).find((e) => e.toLowerCase() === n);
              return void 0 === i || eg.deleteProperty(t, i);
            },
          })));
      }
      static seal(e) {
        return new Proxy(e, {
          get(e, t, r) {
            switch (t) {
              case 'append':
              case 'delete':
              case 'set':
                return eR.callable;
              default:
                return eg.get(e, t, r);
            }
          },
        });
      }
      merge(e) {
        return Array.isArray(e) ? e.join(', ') : e;
      }
      static from(e) {
        return e instanceof Headers ? e : new eO(e);
      }
      append(e, t) {
        let r = this.headers[e];
        'string' == typeof r
          ? (this.headers[e] = [r, t])
          : Array.isArray(r)
            ? r.push(t)
            : (this.headers[e] = t);
      }
      delete(e) {
        delete this.headers[e];
      }
      get(e) {
        let t = this.headers[e];
        return void 0 !== t ? this.merge(t) : null;
      }
      has(e) {
        return void 0 !== this.headers[e];
      }
      set(e, t) {
        this.headers[e] = t;
      }
      forEach(e, t) {
        for (let [r, n] of this.entries()) e.call(t, n, r, this);
      }
      *entries() {
        for (let e of Object.keys(this.headers)) {
          let t = e.toLowerCase(),
            r = this.get(t);
          yield [t, r];
        }
      }
      *keys() {
        for (let e of Object.keys(this.headers)) {
          let t = e.toLowerCase();
          yield t;
        }
      }
      *values() {
        for (let e of Object.keys(this.headers)) {
          let t = this.get(e);
          yield t;
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
    }
    var eT = e.i(56704);
    class ek extends Error {
      constructor() {
        super(
          'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'
        );
      }
      static callable() {
        throw new ek();
      }
    }
    class eP {
      static seal(e) {
        return new Proxy(e, {
          get(e, t, r) {
            switch (t) {
              case 'clear':
              case 'delete':
              case 'set':
                return ek.callable;
              default:
                return eg.get(e, t, r);
            }
          },
        });
      }
    }
    let ex = Symbol.for('next.mutated.cookies');
    class eA {
      static wrap(e, t) {
        let r = new ed.ResponseCookies(new Headers());
        for (let t of e.getAll()) r.set(t);
        let n = [],
          i = new Set(),
          s = () => {
            let e = eT.workAsyncStorage.getStore();
            if (
              (e && (e.pathWasRevalidated = 1),
              (n = r.getAll().filter((e) => i.has(e.name))),
              t)
            ) {
              let e = [];
              for (let t of n) {
                let r = new ed.ResponseCookies(new Headers());
                (r.set(t), e.push(r.toString()));
              }
              t(e);
            }
          },
          a = new Proxy(r, {
            get(e, t, r) {
              switch (t) {
                case ex:
                  return n;
                case 'delete':
                  return function (...t) {
                    i.add('string' == typeof t[0] ? t[0] : t[0].name);
                    try {
                      return (e.delete(...t), a);
                    } finally {
                      s();
                    }
                  };
                case 'set':
                  return function (...t) {
                    i.add('string' == typeof t[0] ? t[0] : t[0].name);
                    try {
                      return (e.set(...t), a);
                    } finally {
                      s();
                    }
                  };
                default:
                  return eg.get(e, t, r);
              }
            },
          });
        return a;
      }
    }
    function eC(e, t) {
      if ('action' !== e.phase) throw new ek();
    }
    var eI =
        (((N = eI || {}).handleRequest = 'BaseServer.handleRequest'),
        (N.run = 'BaseServer.run'),
        (N.pipe = 'BaseServer.pipe'),
        (N.getStaticHTML = 'BaseServer.getStaticHTML'),
        (N.render = 'BaseServer.render'),
        (N.renderToResponseWithComponents =
          'BaseServer.renderToResponseWithComponents'),
        (N.renderToResponse = 'BaseServer.renderToResponse'),
        (N.renderToHTML = 'BaseServer.renderToHTML'),
        (N.renderError = 'BaseServer.renderError'),
        (N.renderErrorToResponse = 'BaseServer.renderErrorToResponse'),
        (N.renderErrorToHTML = 'BaseServer.renderErrorToHTML'),
        (N.render404 = 'BaseServer.render404'),
        N),
      eN =
        (((j = eN || {}).loadDefaultErrorComponents =
          'LoadComponents.loadDefaultErrorComponents'),
        (j.loadComponents = 'LoadComponents.loadComponents'),
        j),
      ej =
        (((D = ej || {}).getRequestHandler = 'NextServer.getRequestHandler'),
        (D.getRequestHandlerWithMetadata =
          'NextServer.getRequestHandlerWithMetadata'),
        (D.getServer = 'NextServer.getServer'),
        (D.getServerRequestHandler = 'NextServer.getServerRequestHandler'),
        (D.createServer = 'createServer.createServer'),
        D),
      eD =
        ((($ = eD || {}).compression = 'NextNodeServer.compression'),
        ($.getBuildId = 'NextNodeServer.getBuildId'),
        ($.createComponentTree = 'NextNodeServer.createComponentTree'),
        ($.clientComponentLoading = 'NextNodeServer.clientComponentLoading'),
        ($.getLayoutOrPageModule = 'NextNodeServer.getLayoutOrPageModule'),
        ($.generateStaticRoutes = 'NextNodeServer.generateStaticRoutes'),
        ($.generateFsStaticRoutes = 'NextNodeServer.generateFsStaticRoutes'),
        ($.generatePublicRoutes = 'NextNodeServer.generatePublicRoutes'),
        ($.generateImageRoutes = 'NextNodeServer.generateImageRoutes.route'),
        ($.sendRenderResult = 'NextNodeServer.sendRenderResult'),
        ($.proxyRequest = 'NextNodeServer.proxyRequest'),
        ($.runApi = 'NextNodeServer.runApi'),
        ($.render = 'NextNodeServer.render'),
        ($.renderHTML = 'NextNodeServer.renderHTML'),
        ($.imageOptimizer = 'NextNodeServer.imageOptimizer'),
        ($.getPagePath = 'NextNodeServer.getPagePath'),
        ($.getRoutesManifest = 'NextNodeServer.getRoutesManifest'),
        ($.findPageComponents = 'NextNodeServer.findPageComponents'),
        ($.getFontManifest = 'NextNodeServer.getFontManifest'),
        ($.getServerComponentManifest =
          'NextNodeServer.getServerComponentManifest'),
        ($.getRequestHandler = 'NextNodeServer.getRequestHandler'),
        ($.renderToHTML = 'NextNodeServer.renderToHTML'),
        ($.renderError = 'NextNodeServer.renderError'),
        ($.renderErrorToHTML = 'NextNodeServer.renderErrorToHTML'),
        ($.render404 = 'NextNodeServer.render404'),
        ($.startResponse = 'NextNodeServer.startResponse'),
        ($.route = 'route'),
        ($.onProxyReq = 'onProxyReq'),
        ($.apiResolver = 'apiResolver'),
        ($.internalFetch = 'internalFetch'),
        $),
      e$ = (((L = e$ || {}).startServer = 'startServer.startServer'), L),
      eL =
        (((U = eL || {}).getServerSideProps = 'Render.getServerSideProps'),
        (U.getStaticProps = 'Render.getStaticProps'),
        (U.renderToString = 'Render.renderToString'),
        (U.renderDocument = 'Render.renderDocument'),
        (U.createBodyResult = 'Render.createBodyResult'),
        U),
      eU =
        (((M = eU || {}).renderToString = 'AppRender.renderToString'),
        (M.renderToReadableStream = 'AppRender.renderToReadableStream'),
        (M.getBodyResult = 'AppRender.getBodyResult'),
        (M.fetch = 'AppRender.fetch'),
        M),
      eM = (((B = eM || {}).executeRoute = 'Router.executeRoute'), B),
      eB = (((q = eB || {}).runHandler = 'Node.runHandler'), q),
      eq =
        (((V = eq || {}).runHandler = 'AppRouteRouteHandlers.runHandler'), V),
      eV =
        (((W = eV || {}).generateMetadata = 'ResolveMetadata.generateMetadata'),
        (W.generateViewport = 'ResolveMetadata.generateViewport'),
        W),
      eW = (((G = eW || {}).execute = 'Middleware.execute'), G);
    let eG = new Set([
        'Middleware.execute',
        'BaseServer.handleRequest',
        'Render.getServerSideProps',
        'Render.getStaticProps',
        'AppRender.fetch',
        'AppRender.getBodyResult',
        'Render.renderDocument',
        'Node.runHandler',
        'AppRouteRouteHandlers.runHandler',
        'ResolveMetadata.generateMetadata',
        'ResolveMetadata.generateViewport',
        'NextNodeServer.createComponentTree',
        'NextNodeServer.findPageComponents',
        'NextNodeServer.getLayoutOrPageModule',
        'NextNodeServer.startResponse',
        'NextNodeServer.clientComponentLoading',
      ]),
      eH = new Set([
        'NextNodeServer.findPageComponents',
        'NextNodeServer.createComponentTree',
        'NextNodeServer.clientComponentLoading',
      ]);
    function eF(e) {
      return (
        null !== e &&
        'object' == typeof e &&
        'then' in e &&
        'function' == typeof e.then
      );
    }
    let ez = process.env.NEXT_OTEL_PERFORMANCE_PREFIX;
    try {
      t = e.r(80317);
    } catch (r) {
      t = e.r(31387);
    }
    let {
      context: eK,
      propagation: eX,
      trace: eJ,
      SpanStatusCode: eY,
      SpanKind: eQ,
      ROOT_CONTEXT: eZ,
    } = t;
    class e0 extends Error {
      constructor(e, t) {
        (super(), (this.bubble = e), (this.result = t));
      }
    }
    let e1 = (e, t) => {
        ('object' == typeof t && null !== t && t instanceof e0 && t.bubble
          ? e.setAttribute('next.bubble', !0)
          : (t && (e.recordException(t), e.setAttribute('error.type', t.name)),
            e.setStatus({
              code: eY.ERROR,
              message: null == t ? void 0 : t.message,
            })),
          e.end());
      },
      e2 = new Map(),
      e3 = t.createContextKey('next.rootSpanId'),
      e4 = 0,
      e5 = {
        set(e, t, r) {
          e.push({ key: t, value: r });
        },
      },
      e6 =
        ((n = new (class e {
          getTracerInstance() {
            return eJ.getTracer('next.js', '0.0.1');
          }
          getContext() {
            return eK;
          }
          getTracePropagationData() {
            let e = eK.active(),
              t = [];
            return (eX.inject(e, t, e5), t);
          }
          getActiveScopeSpan() {
            return eJ.getSpan(null == eK ? void 0 : eK.active());
          }
          withPropagatedContext(e, t, r) {
            let n = eK.active();
            if (eJ.getSpanContext(n)) return t();
            let i = eX.extract(n, e, r);
            return eK.with(i, t);
          }
          trace(...e) {
            let [t, r, n] = e,
              { fn: i, options: s } =
                'function' == typeof r
                  ? { fn: r, options: {} }
                  : { fn: n, options: { ...r } },
              a = s.spanName ?? t;
            if (
              (!eG.has(t) && '1' !== process.env.NEXT_OTEL_VERBOSE) ||
              s.hideSpan
            )
              return i();
            let o = this.getSpanContext(
              (null == s ? void 0 : s.parentSpan) ?? this.getActiveScopeSpan()
            );
            o || (o = (null == eK ? void 0 : eK.active()) ?? eZ);
            let l = o.getValue(e3),
              u = 'number' != typeof l || !e2.has(l),
              c = e4++;
            return (
              (s.attributes = {
                'next.span_name': a,
                'next.span_type': t,
                ...s.attributes,
              }),
              eK.with(o.setValue(e3, c), () =>
                this.getTracerInstance().startActiveSpan(a, s, (e) => {
                  let r;
                  ez &&
                    t &&
                    eH.has(t) &&
                    (r =
                      'performance' in globalThis && 'measure' in performance
                        ? globalThis.performance.now()
                        : void 0);
                  let n = !1,
                    a = () => {
                      !n &&
                        ((n = !0),
                        e2.delete(c),
                        r &&
                          performance.measure(
                            `${ez}:next-${(t.split('.').pop() || '').replace(/[A-Z]/g, (e) => '-' + e.toLowerCase())}`,
                            { start: r, end: performance.now() }
                          ));
                    };
                  if (
                    (u &&
                      e2.set(c, new Map(Object.entries(s.attributes ?? {}))),
                    i.length > 1)
                  )
                    try {
                      return i(e, (t) => e1(e, t));
                    } catch (t) {
                      throw (e1(e, t), t);
                    } finally {
                      a();
                    }
                  try {
                    let t = i(e);
                    if (eF(t))
                      return t
                        .then((t) => (e.end(), t))
                        .catch((t) => {
                          throw (e1(e, t), t);
                        })
                        .finally(a);
                    return (e.end(), a(), t);
                  } catch (t) {
                    throw (e1(e, t), a(), t);
                  }
                })
              )
            );
          }
          wrap(...e) {
            let t = this,
              [r, n, i] = 3 === e.length ? e : [e[0], {}, e[1]];
            return eG.has(r) || '1' === process.env.NEXT_OTEL_VERBOSE
              ? function () {
                  let e = n;
                  'function' == typeof e &&
                    'function' == typeof i &&
                    (e = e.apply(this, arguments));
                  let s = arguments.length - 1,
                    a = arguments[s];
                  if ('function' != typeof a)
                    return t.trace(r, e, () => i.apply(this, arguments));
                  {
                    let n = t.getContext().bind(eK.active(), a);
                    return t.trace(
                      r,
                      e,
                      (e, t) => (
                        (arguments[s] = function (e) {
                          return (null == t || t(e), n.apply(this, arguments));
                        }),
                        i.apply(this, arguments)
                      )
                    );
                  }
                }
              : i;
          }
          startSpan(...e) {
            let [t, r] = e,
              n = this.getSpanContext(
                (null == r ? void 0 : r.parentSpan) ?? this.getActiveScopeSpan()
              );
            return this.getTracerInstance().startSpan(t, r, n);
          }
          getSpanContext(e) {
            return e ? eJ.setSpan(eK.active(), e) : void 0;
          }
          getRootSpanAttributes() {
            let e = eK.active().getValue(e3);
            return e2.get(e);
          }
          setRootSpanAttribute(e, t) {
            let r = eK.active().getValue(e3),
              n = e2.get(r);
            n && !n.has(e) && n.set(e, t);
          }
          withSpan(e, t) {
            let r = eJ.setSpan(eK.active(), e);
            return eK.with(r, t);
          }
        })()),
        () => n),
      e9 = '__prerender_bypass';
    (Symbol('__next_preview_data'), Symbol(e9));
    class e8 {
      constructor(e, t, r, n) {
        var i;
        const s =
            e &&
            (function (e, t) {
              let r = eO.from(e.headers);
              return {
                isOnDemandRevalidate:
                  r.get('x-prerender-revalidate') === t.previewModeId,
                revalidateOnlyGenerated: r.has(
                  'x-prerender-revalidate-if-generated'
                ),
              };
            })(t, e).isOnDemandRevalidate,
          a = null == (i = r.get(e9)) ? void 0 : i.value;
        ((this._isEnabled = !!(!s && a && e && a === e.previewModeId)),
          (this._previewModeId = null == e ? void 0 : e.previewModeId),
          (this._mutableCookies = n));
      }
      get isEnabled() {
        return this._isEnabled;
      }
      enable() {
        if (!this._previewModeId)
          throw Object.defineProperty(
            Error(
              'Invariant: previewProps missing previewModeId this should never happen'
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E93', enumerable: !1, configurable: !0 }
          );
        (this._mutableCookies.set({
          name: e9,
          value: this._previewModeId,
          httpOnly: !0,
          sameSite: 'none',
          secure: !0,
          path: '/',
        }),
          (this._isEnabled = !0));
      }
      disable() {
        (this._mutableCookies.set({
          name: e9,
          value: '',
          httpOnly: !0,
          sameSite: 'none',
          secure: !0,
          path: '/',
          expires: new Date(0),
        }),
          (this._isEnabled = !1));
      }
    }
    function e7(e, t) {
      if (
        'x-middleware-set-cookie' in e.headers &&
        'string' == typeof e.headers['x-middleware-set-cookie']
      ) {
        let r = e.headers['x-middleware-set-cookie'],
          n = new Headers();
        for (let e of f(r)) n.append('set-cookie', e);
        for (let e of new ed.ResponseCookies(n).getAll()) t.set(e);
      }
    }
    var te = e.i(32319),
      tt = e.i(47413);
    class tr extends Error {
      constructor(e, t) {
        (super(
          `Invariant: ${e.endsWith('.') ? e : e + '.'} This is a bug in Next.js.`,
          t
        ),
          (this.name = 'InvariantError'));
      }
    }
    (e.i(51187),
      process.env.NEXT_PRIVATE_DEBUG_CACHE,
      Symbol.for('@next/cache-handlers'));
    let tn = Symbol.for('@next/cache-handlers-map'),
      ti = Symbol.for('@next/cache-handlers-set'),
      ts = globalThis;
    function ta() {
      if (ts[tn]) return ts[tn].entries();
    }
    async function to(e, t) {
      if (!e) return t();
      let r = tl(e);
      try {
        return await t();
      } finally {
        var n, i;
        let t,
          s,
          a =
            ((n = r),
            (i = tl(e)),
            (t = new Set(
              n.pendingRevalidatedTags.map((e) => {
                let t =
                  'object' == typeof e.profile
                    ? JSON.stringify(e.profile)
                    : e.profile || '';
                return `${e.tag}:${t}`;
              })
            )),
            (s = new Set(n.pendingRevalidateWrites)),
            {
              pendingRevalidatedTags: i.pendingRevalidatedTags.filter((e) => {
                let r =
                  'object' == typeof e.profile
                    ? JSON.stringify(e.profile)
                    : e.profile || '';
                return !t.has(`${e.tag}:${r}`);
              }),
              pendingRevalidates: Object.fromEntries(
                Object.entries(i.pendingRevalidates).filter(
                  ([e]) => !(e in n.pendingRevalidates)
                )
              ),
              pendingRevalidateWrites: i.pendingRevalidateWrites.filter(
                (e) => !s.has(e)
              ),
            });
        await tc(e, a);
      }
    }
    function tl(e) {
      return {
        pendingRevalidatedTags: e.pendingRevalidatedTags
          ? [...e.pendingRevalidatedTags]
          : [],
        pendingRevalidates: { ...e.pendingRevalidates },
        pendingRevalidateWrites: e.pendingRevalidateWrites
          ? [...e.pendingRevalidateWrites]
          : [],
      };
    }
    async function tu(e, t, r) {
      if (0 === e.length) return;
      let n = (function () {
          if (ts[ti]) return ts[ti].values();
        })(),
        i = [],
        s = new Map();
      for (let t of e) {
        let e,
          r = t.profile;
        for (let [t] of s)
          if (
            ('string' == typeof t && 'string' == typeof r && t === r) ||
            ('object' == typeof t &&
              'object' == typeof r &&
              JSON.stringify(t) === JSON.stringify(r)) ||
            t === r
          ) {
            e = t;
            break;
          }
        let n = e || r;
        (s.has(n) || s.set(n, []), s.get(n).push(t.tag));
      }
      for (let [e, o] of s) {
        let s;
        if (e) {
          let t;
          if ('object' == typeof e) t = e;
          else if ('string' == typeof e) {
            var a;
            if (
              !(t =
                null == r || null == (a = r.cacheLifeProfiles) ? void 0 : a[e])
            )
              throw Object.defineProperty(
                Error(
                  `Invalid profile provided "${e}" must be configured under cacheLife in next.config or be "max"`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E873', enumerable: !1, configurable: !0 }
              );
          }
          t && (s = { expire: t.expire });
        }
        for (let t of n || [])
          e
            ? i.push(null == t.updateTags ? void 0 : t.updateTags.call(t, o, s))
            : i.push(null == t.updateTags ? void 0 : t.updateTags.call(t, o));
        t && i.push(t.revalidateTag(o, s));
      }
      await Promise.all(i);
    }
    async function tc(e, t) {
      let r =
          (null == t ? void 0 : t.pendingRevalidatedTags) ??
          e.pendingRevalidatedTags ??
          [],
        n =
          (null == t ? void 0 : t.pendingRevalidates) ??
          e.pendingRevalidates ??
          {},
        i =
          (null == t ? void 0 : t.pendingRevalidateWrites) ??
          e.pendingRevalidateWrites ??
          [];
      return Promise.all([
        tu(r, e.incrementalCache, e),
        ...Object.values(n),
        ...i,
      ]);
    }
    let th = Object.defineProperty(
      Error(
        'Invariant: AsyncLocalStorage accessed in runtime where it is not available'
      ),
      '__NEXT_ERROR_CODE',
      { value: 'E504', enumerable: !1, configurable: !0 }
    );
    class td {
      disable() {
        throw th;
      }
      getStore() {}
      run() {
        throw th;
      }
      exit() {
        throw th;
      }
      enterWith() {
        throw th;
      }
      static bind(e) {
        return e;
      }
    }
    let tp = 'u' > typeof globalThis && globalThis.AsyncLocalStorage;
    var tf = e.i(24725);
    class tg {
      constructor({ waitUntil: e, onClose: t, onTaskError: r }) {
        ((this.workUnitStores = new Set()),
          (this.waitUntil = e),
          (this.onClose = t),
          (this.onTaskError = r),
          (this.callbackQueue = new tt.default()),
          this.callbackQueue.pause());
      }
      after(e) {
        if (eF(e))
          (this.waitUntil || tm(),
            this.waitUntil(e.catch((e) => this.reportTaskError('promise', e))));
        else if ('function' == typeof e) this.addCallback(e);
        else
          throw Object.defineProperty(
            Error('`after()`: Argument must be a promise or a function'),
            '__NEXT_ERROR_CODE',
            { value: 'E50', enumerable: !1, configurable: !0 }
          );
      }
      addCallback(e) {
        var t;
        this.waitUntil || tm();
        let r = te.workUnitAsyncStorage.getStore();
        r && this.workUnitStores.add(r);
        let n = tf.afterTaskAsyncStorage.getStore(),
          i = n ? n.rootTaskSpawnPhase : null == r ? void 0 : r.phase;
        this.runCallbacksOnClosePromise ||
          ((this.runCallbacksOnClosePromise = this.runCallbacksOnClose()),
          this.waitUntil(this.runCallbacksOnClosePromise));
        let s =
          ((t = async () => {
            try {
              await tf.afterTaskAsyncStorage.run(
                { rootTaskSpawnPhase: i },
                () => e()
              );
            } catch (e) {
              this.reportTaskError('function', e);
            }
          }),
          tp ? tp.bind(t) : td.bind(t));
        this.callbackQueue.add(s);
      }
      async runCallbacksOnClose() {
        return (await new Promise((e) => this.onClose(e)), this.runCallbacks());
      }
      async runCallbacks() {
        if (0 === this.callbackQueue.size) return;
        for (let e of this.workUnitStores) e.phase = 'after';
        let e = eT.workAsyncStorage.getStore();
        if (!e)
          throw Object.defineProperty(
            new tr('Missing workStore in AfterContext.runCallbacks'),
            '__NEXT_ERROR_CODE',
            { value: 'E547', enumerable: !1, configurable: !0 }
          );
        return to(
          e,
          () => (this.callbackQueue.start(), this.callbackQueue.onIdle())
        );
      }
      reportTaskError(e, t) {
        if (
          (console.error(
            'promise' === e
              ? 'A promise passed to `after()` rejected:'
              : 'An error occurred in a function passed to `after()`:',
            t
          ),
          this.onTaskError)
        )
          try {
            null == this.onTaskError || this.onTaskError.call(this, t);
          } catch (e) {
            console.error(
              Object.defineProperty(
                new tr(
                  '`onTaskError` threw while handling an error thrown from an `after` task',
                  { cause: e }
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E569', enumerable: !1, configurable: !0 }
              )
            );
          }
      }
    }
    function tm() {
      throw Object.defineProperty(
        Error(
          '`after()` will not work correctly, because `waitUntil` is not available in the current environment.'
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E91', enumerable: !1, configurable: !0 }
      );
    }
    function ty(e) {
      let t,
        r = {
          then: (n, i) => (
            t || (t = Promise.resolve(e())),
            t
              .then((e) => {
                r.value = e;
              })
              .catch(() => {}),
            t.then(n, i)
          ),
        };
      return r;
    }
    class tb {
      onClose(e) {
        if (this.isClosed)
          throw Object.defineProperty(
            Error('Cannot subscribe to a closed CloseController'),
            '__NEXT_ERROR_CODE',
            { value: 'E365', enumerable: !1, configurable: !0 }
          );
        (this.target.addEventListener('close', e), this.listeners++);
      }
      dispatchClose() {
        if (this.isClosed)
          throw Object.defineProperty(
            Error('Cannot close a CloseController multiple times'),
            '__NEXT_ERROR_CODE',
            { value: 'E229', enumerable: !1, configurable: !0 }
          );
        (this.listeners > 0 && this.target.dispatchEvent(new Event('close')),
          (this.isClosed = !0));
      }
      constructor() {
        ((this.target = new EventTarget()),
          (this.listeners = 0),
          (this.isClosed = !1));
      }
    }
    function tv() {
      return {
        previewModeId: process.env.__NEXT_PREVIEW_MODE_ID || '',
        previewModeSigningKey:
          process.env.__NEXT_PREVIEW_MODE_SIGNING_KEY || '',
        previewModeEncryptionKey:
          process.env.__NEXT_PREVIEW_MODE_ENCRYPTION_KEY || '',
      };
    }
    let tw = Symbol.for('@next/request-context');
    async function t_(e, t, r) {
      let n = new Set();
      for (let t of ((e) => {
        let t = ['/layout'];
        if (e.startsWith('/')) {
          let r = e.split('/');
          for (let e = 1; e < r.length + 1; e++) {
            let n = r.slice(0, e).join('/');
            n &&
              (n.endsWith('/page') ||
                n.endsWith('/route') ||
                (n = `${n}${!n.endsWith('/') ? '/' : ''}layout`),
              t.push(n));
          }
        }
        return t;
      })(e))
        ((t = `${d}${t}`), n.add(t));
      if (t.pathname && (!r || 0 === r.size)) {
        let e = `${d}${t.pathname}`;
        n.add(e);
      }
      (n.has(`${d}/`) && n.add(`${d}/index`),
        n.has(`${d}/index`) && n.add(`${d}/`));
      let i = Array.from(n);
      return {
        tags: i,
        expirationsByCacheKind: (function (e) {
          let t = new Map(),
            r = ta();
          if (r)
            for (let [n, i] of r)
              'getExpiration' in i &&
                t.set(
                  n,
                  ty(async () => i.getExpiration(e))
                );
          return t;
        })(i),
      };
    }
    class tE extends ef {
      constructor(e) {
        (super(e.input, e.init), (this.sourcePage = e.page));
      }
      get request() {
        throw Object.defineProperty(
          new u({ page: this.sourcePage }),
          '__NEXT_ERROR_CODE',
          { value: 'E394', enumerable: !1, configurable: !0 }
        );
      }
      respondWith() {
        throw Object.defineProperty(
          new u({ page: this.sourcePage }),
          '__NEXT_ERROR_CODE',
          { value: 'E394', enumerable: !1, configurable: !0 }
        );
      }
      waitUntil() {
        throw Object.defineProperty(
          new u({ page: this.sourcePage }),
          '__NEXT_ERROR_CODE',
          { value: 'E394', enumerable: !1, configurable: !0 }
        );
      }
    }
    let tS = {
        keys: (e) => Array.from(e.keys()),
        get: (e, t) => e.get(t) ?? void 0,
      },
      tR = (e, t) => e6().withPropagatedContext(e.headers, t, tS),
      tO = !1;
    async function tT(t) {
      var r, n, i, s;
      let o, u, c, h, d;
      (!(function () {
        if (
          !tO &&
          ((tO = !0), 'true' === process.env.NEXT_PRIVATE_TEST_PROXY)
        ) {
          let { interceptTestApis: t, wrapRequestHandler: r } = e.r(76532);
          (t(), (tR = r(tR)));
        }
      })(),
        await (!l && (l = a()), l));
      let p = void 0 !== globalThis.__BUILD_MANIFEST;
      t.request.url = t.request.url.replace(/\.rsc($|\?)/, '$1');
      let f = t.bypassNextUrl
        ? new URL(t.request.url)
        : new I(t.request.url, {
            headers: t.request.headers,
            nextConfig: t.request.nextConfig,
          });
      for (let e of [...f.searchParams.keys()]) {
        let t = f.searchParams.getAll(e),
          r = (function (e) {
            for (let t of ['nxtP', 'nxtI'])
              if (e !== t && e.startsWith(t)) return e.substring(t.length);
            return null;
          })(e);
        if (r) {
          for (let e of (f.searchParams.delete(r), t))
            f.searchParams.append(r, e);
          f.searchParams.delete(e);
        }
      }
      let g = process.env.__NEXT_BUILD_ID || '';
      'buildId' in f && ((g = f.buildId || ''), (f.buildId = ''));
      let m = (function (e) {
          let t = new Headers();
          for (let [r, n] of Object.entries(e))
            for (let e of Array.isArray(n) ? n : [n])
              void 0 !== e &&
                ('number' == typeof e && (e = e.toString()), t.append(r, e));
          return t;
        })(t.request.headers),
        y = m.has('x-nextjs-data'),
        b = '1' === m.get('rsc');
      y && '/index' === f.pathname && (f.pathname = '/');
      let w = new Map();
      if (!p)
        for (let e of eE) {
          let t = m.get(e);
          null !== t && (w.set(e, t), m.delete(e));
        }
      let E = f.searchParams.get(eS),
        S = new tE({
          page: t.page,
          input: ((h = (c = 'string' == typeof f)
            ? new URL(f)
            : f).searchParams.delete(eS),
          c ? h.toString() : h).toString(),
          init: {
            body: t.request.body,
            headers: m,
            method: t.request.method,
            nextConfig: t.request.nextConfig,
            signal: t.request.signal,
          },
        });
      (y && Object.defineProperty(S, '__isData', { enumerable: !1, value: !0 }),
        !globalThis.__incrementalCacheShared &&
          t.IncrementalCache &&
          (globalThis.__incrementalCache = new t.IncrementalCache({
            CurCacheHandler: t.incrementalCacheHandler,
            minimalMode: !0,
            fetchCacheKeyPrefix: '',
            dev: !1,
            requestHeaders: t.request.headers,
            getPrerenderManifest: () => ({
              version: -1,
              routes: {},
              dynamicRoutes: {},
              notFoundRoutes: [],
              preview: tv(),
            }),
          })));
      let R =
          t.request.waitUntil ??
          (null == (r = null == (d = globalThis[tw]) ? void 0 : d.get())
            ? void 0
            : r.waitUntil),
        O = new _({
          request: S,
          page: t.page,
          context: R ? { waitUntil: R } : void 0,
        });
      if (
        (o = await tR(S, () => {
          if (
            '/middleware' === t.page ||
            '/src/middleware' === t.page ||
            '/proxy' === t.page ||
            '/src/proxy' === t.page
          ) {
            let e = O.waitUntil.bind(O),
              r = new tb();
            return e6().trace(
              eW.execute,
              {
                spanName: `middleware ${S.method}`,
                attributes: {
                  'http.target': S.nextUrl.pathname,
                  'http.method': S.method,
                },
              },
              async () => {
                try {
                  var n, i, s, a, o, l;
                  let c = tv(),
                    h = await t_('/', S.nextUrl, null),
                    d =
                      ((o = S.nextUrl),
                      (l = (e) => {
                        u = e;
                      }),
                      (function (e, t, r, n, i, s, a, o, l, u, c, h) {
                        function d(e) {
                          r && r.setHeader('Set-Cookie', e);
                        }
                        let p = {};
                        return {
                          type: 'request',
                          phase: e,
                          implicitTags: s,
                          url: { pathname: n.pathname, search: n.search ?? '' },
                          rootParams: i,
                          get headers() {
                            return (
                              p.headers ||
                                (p.headers = (function (e) {
                                  let t = eO.from(e);
                                  for (let e of eE) t.delete(e);
                                  return eO.seal(t);
                                })(t.headers)),
                              p.headers
                            );
                          },
                          get cookies() {
                            if (!p.cookies) {
                              let e = new ed.RequestCookies(eO.from(t.headers));
                              (e7(t, e), (p.cookies = eP.seal(e)));
                            }
                            return p.cookies;
                          },
                          set cookies(value) {
                            p.cookies = value;
                          },
                          get mutableCookies() {
                            if (!p.mutableCookies) {
                              var f, g;
                              let e,
                                n =
                                  ((f = t.headers),
                                  (g = a || (r ? d : void 0)),
                                  (e = new ed.RequestCookies(eO.from(f))),
                                  eA.wrap(e, g));
                              (e7(t, n), (p.mutableCookies = n));
                            }
                            return p.mutableCookies;
                          },
                          get userspaceMutableCookies() {
                            if (!p.userspaceMutableCookies) {
                              var m;
                              let e;
                              ((m = this),
                                (p.userspaceMutableCookies = e =
                                  new Proxy(m.mutableCookies, {
                                    get(t, r, n) {
                                      switch (r) {
                                        case 'delete':
                                          return function (...r) {
                                            return (
                                              eC(m, 'cookies().delete'),
                                              t.delete(...r),
                                              e
                                            );
                                          };
                                        case 'set':
                                          return function (...r) {
                                            return (
                                              eC(m, 'cookies().set'),
                                              t.set(...r),
                                              e
                                            );
                                          };
                                        default:
                                          return eg.get(t, r, n);
                                      }
                                    },
                                  })));
                            }
                            return p.userspaceMutableCookies;
                          },
                          get draftMode() {
                            return (
                              p.draftMode ||
                                (p.draftMode = new e8(
                                  l,
                                  t,
                                  this.cookies,
                                  this.mutableCookies
                                )),
                              p.draftMode
                            );
                          },
                          renderResumeDataCache: null,
                          isHmrRefresh: u,
                          serverComponentsHmrCache:
                            c || globalThis.__serverComponentsHmrCache,
                          devFallbackParams: null,
                        };
                      })(
                        'action',
                        S,
                        void 0,
                        o,
                        {},
                        h,
                        l,
                        null,
                        c,
                        !1,
                        void 0,
                        null
                      )),
                    p = (function ({
                      page: e,
                      renderOpts: t,
                      isPrefetchRequest: r,
                      buildId: n,
                      previouslyRevalidatedTags: i,
                      nonce: s,
                    }) {
                      var a;
                      let o =
                          !t.shouldWaitOnAllReady &&
                          !t.supportsDynamicResponse &&
                          !t.isDraftMode &&
                          !t.isPossibleServerAction,
                        l = t.dev ?? !1,
                        u =
                          l ||
                          (o &&
                            (!!process.env.NEXT_DEBUG_BUILD ||
                              '1' === process.env.NEXT_SSG_FETCH_METRICS)),
                        c = {
                          isStaticGeneration: o,
                          page: e,
                          route: (a = e
                            .split('/')
                            .reduce(
                              (e, t, r, n) =>
                                t
                                  ? ('(' === t[0] && t.endsWith(')')) ||
                                    '@' === t[0] ||
                                    (('page' === t || 'route' === t) &&
                                      r === n.length - 1)
                                    ? e
                                    : `${e}/${t}`
                                  : e,
                              ''
                            )).startsWith('/')
                            ? a
                            : `/${a}`,
                          incrementalCache:
                            t.incrementalCache || globalThis.__incrementalCache,
                          cacheLifeProfiles: t.cacheLifeProfiles,
                          isBuildTimePrerendering: t.nextExport,
                          hasReadableErrorStacks: t.hasReadableErrorStacks,
                          fetchCache: t.fetchCache,
                          isOnDemandRevalidate: t.isOnDemandRevalidate,
                          isDraftMode: t.isDraftMode,
                          isPrefetchRequest: r,
                          buildId: n,
                          reactLoadableManifest:
                            (null == t ? void 0 : t.reactLoadableManifest) ||
                            {},
                          assetPrefix:
                            (null == t ? void 0 : t.assetPrefix) || '',
                          nonce: s,
                          afterContext: (function (e) {
                            let {
                              waitUntil: t,
                              onClose: r,
                              onAfterTaskError: n,
                            } = e;
                            return new tg({
                              waitUntil: t,
                              onClose: r,
                              onTaskError: n,
                            });
                          })(t),
                          cacheComponentsEnabled: t.cacheComponents,
                          dev: l,
                          previouslyRevalidatedTags: i,
                          refreshTagsByCacheKind: (function () {
                            let e = new Map(),
                              t = ta();
                            if (t)
                              for (let [r, n] of t)
                                'refreshTags' in n &&
                                  e.set(
                                    r,
                                    ty(async () => n.refreshTags())
                                  );
                            return e;
                          })(),
                          runInCleanSnapshot: tp
                            ? tp.snapshot()
                            : function (e, ...t) {
                                return e(...t);
                              },
                          shouldTrackFetchMetrics: u,
                          reactServerErrorsByDigest: new Map(),
                        };
                      return ((t.store = c), c);
                    })({
                      page: '/',
                      renderOpts: {
                        cacheLifeProfiles:
                          null == (i = t.request.nextConfig) ||
                          null == (n = i.experimental)
                            ? void 0
                            : n.cacheLife,
                        cacheComponents: !1,
                        experimental: {
                          isRoutePPREnabled: !1,
                          authInterrupts: !!(null ==
                            (a = t.request.nextConfig) ||
                          null == (s = a.experimental)
                            ? void 0
                            : s.authInterrupts),
                        },
                        supportsDynamicResponse: !0,
                        waitUntil: e,
                        onClose: r.onClose.bind(r),
                        onAfterTaskError: void 0,
                      },
                      isPrefetchRequest: '1' === S.headers.get(e_),
                      buildId: g ?? '',
                      previouslyRevalidatedTags: [],
                    });
                  return await eT.workAsyncStorage.run(p, () =>
                    te.workUnitAsyncStorage.run(d, t.handler, S, O)
                  );
                } finally {
                  setTimeout(() => {
                    r.dispatchClose();
                  }, 0);
                }
              }
            );
          }
          return t.handler(S, O);
        })) &&
        !(o instanceof Response)
      )
        throw Object.defineProperty(
          TypeError('Expected an instance of Response to be returned'),
          '__NEXT_ERROR_CODE',
          { value: 'E567', enumerable: !1, configurable: !0 }
        );
      o && u && o.headers.set('set-cookie', u);
      let T = null == o ? void 0 : o.headers.get('x-middleware-rewrite');
      if (o && T && (b || !p)) {
        let e = new I(T, {
          forceLocale: !0,
          headers: t.request.headers,
          nextConfig: t.request.nextConfig,
        });
        p ||
          e.host !== S.nextUrl.host ||
          ((e.buildId = g || e.buildId),
          o.headers.set('x-middleware-rewrite', String(e)));
        let { url: r, isRelative: a } = ew(e.toString(), f.toString());
        !p && y && o.headers.set('x-nextjs-rewrite', r);
        let l =
          !a &&
          (null == (s = t.request.nextConfig) ||
          null == (i = s.experimental) ||
          null == (n = i.clientParamParsingOrigins)
            ? void 0
            : n.some((t) => new RegExp(t).test(e.origin)));
        b &&
          (a || l) &&
          (f.pathname !== e.pathname &&
            o.headers.set('x-nextjs-rewritten-path', e.pathname),
          f.search !== e.search &&
            o.headers.set('x-nextjs-rewritten-query', e.search.slice(1)));
      }
      if (o && T && b && E) {
        let e = new URL(T);
        e.searchParams.has(eS) ||
          (e.searchParams.set(eS, E),
          o.headers.set('x-middleware-rewrite', e.toString()));
      }
      let k = null == o ? void 0 : o.headers.get('Location');
      if (o && k && !p) {
        let e = new I(k, {
          forceLocale: !1,
          headers: t.request.headers,
          nextConfig: t.request.nextConfig,
        });
        ((o = new Response(o.body, o)),
          e.host === f.host &&
            ((e.buildId = g || e.buildId),
            o.headers.set('Location', ew(e, f).url)),
          y &&
            (o.headers.delete('Location'),
            o.headers.set(
              'x-nextjs-redirect',
              ew(e.toString(), f.toString()).url
            )));
      }
      let P = o || ev.next(),
        x = P.headers.get('x-middleware-override-headers'),
        A = [];
      if (x) {
        for (let [e, t] of w)
          (P.headers.set(`x-middleware-request-${e}`, t), A.push(e));
        A.length > 0 &&
          P.headers.set('x-middleware-override-headers', x + ',' + A.join(','));
      }
      return {
        response: P,
        waitUntil:
          ('internal' === O[v].kind
            ? Promise.all(O[v].promises).then(() => {})
            : void 0) ?? Promise.resolve(),
        fetchMetrics: S.fetchMetrics,
      };
    }
    var tk = e.i(9933);
    (tk.parse, tk.serialize);
    let tP = { path: '/', sameSite: 'lax', httpOnly: !1, maxAge: 3456e4 },
      tx = /^(.*)[.](0|[1-9][0-9]*)$/;
    function tA(e, t) {
      if (e === t) return !0;
      let r = e.match(tx);
      return !!r && r[1] === t;
    }
    function tC(e, t, r) {
      let n = r ?? 3180,
        i = encodeURIComponent(t);
      if (i.length <= n) return [{ name: e, value: t }];
      let s = [];
      for (; i.length > 0; ) {
        let e = i.slice(0, n),
          t = e.lastIndexOf('%');
        t > n - 3 && (e = e.slice(0, t));
        let r = '';
        for (; e.length > 0; )
          try {
            r = decodeURIComponent(e);
            break;
          } catch (t) {
            if (t instanceof URIError && '%' === e.at(-3) && e.length > 3)
              e = e.slice(0, e.length - 3);
            else throw t;
          }
        (s.push(r), (i = i.slice(e.length)));
      }
      return s.map((t, r) => ({ name: `${e}.${r}`, value: t }));
    }
    async function tI(e, t) {
      let r = await t(e);
      if (r) return r;
      let n = [];
      for (let r = 0; ; r++) {
        let i = `${e}.${r}`,
          s = await t(i);
        if (!s) break;
        n.push(s);
      }
      return n.length > 0 ? n.join('') : null;
    }
    let tN =
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split(
          ''
        ),
      tj = ' 	\n\r='.split(''),
      tD = (() => {
        let e = Array(128);
        for (let t = 0; t < e.length; t += 1) e[t] = -1;
        for (let t = 0; t < tj.length; t += 1) e[tj[t].charCodeAt(0)] = -2;
        for (let t = 0; t < tN.length; t += 1) e[tN[t].charCodeAt(0)] = t;
        return e;
      })();
    function t$(e) {
      let t = [],
        r = 0,
        n = 0;
      if (
        ((function (e, t) {
          for (let r = 0; r < e.length; r += 1) {
            let n = e.charCodeAt(r);
            if (n > 55295 && n <= 56319) {
              let t = ((n - 55296) * 1024) & 65535;
              ((n = (((e.charCodeAt(r + 1) - 56320) & 65535) | t) + 65536),
                (r += 1));
            }
            !(function (e, t) {
              if (e <= 127) return t(e);
              if (e <= 2047) {
                (t(192 | (e >> 6)), t(128 | (63 & e)));
                return;
              }
              if (e <= 65535) {
                (t(224 | (e >> 12)),
                  t(128 | ((e >> 6) & 63)),
                  t(128 | (63 & e)));
                return;
              }
              if (e <= 1114111) {
                (t(240 | (e >> 18)),
                  t(128 | ((e >> 12) & 63)),
                  t(128 | ((e >> 6) & 63)),
                  t(128 | (63 & e)));
                return;
              }
              throw Error(`Unrecognized Unicode codepoint: ${e.toString(16)}`);
            })(n, t);
          }
        })(e, (e) => {
          for (r = (r << 8) | e, n += 8; n >= 6; ) {
            let e = (r >> (n - 6)) & 63;
            (t.push(tN[e]), (n -= 6));
          }
        }),
        n > 0)
      )
        for (r <<= 6 - n, n = 6; n >= 6; ) {
          let e = (r >> (n - 6)) & 63;
          (t.push(tN[e]), (n -= 6));
        }
      return t.join('');
    }
    function tL(e) {
      let t = [],
        r = (e) => {
          t.push(String.fromCodePoint(e));
        },
        n = { utf8seq: 0, codepoint: 0 },
        i = 0,
        s = 0;
      for (let t = 0; t < e.length; t += 1) {
        let a = tD[e.charCodeAt(t)];
        if (a > -1)
          for (i = (i << 6) | a, s += 6; s >= 8; )
            ((function (e, t, r) {
              if (0 === t.utf8seq) {
                if (e <= 127) return r(e);
                for (let r = 1; r < 6; r += 1)
                  if (((e >> (7 - r)) & 1) == 0) {
                    t.utf8seq = r;
                    break;
                  }
                if (2 === t.utf8seq) t.codepoint = 31 & e;
                else if (3 === t.utf8seq) t.codepoint = 15 & e;
                else if (4 === t.utf8seq) t.codepoint = 7 & e;
                else throw Error('Invalid UTF-8 sequence');
                t.utf8seq -= 1;
              } else if (t.utf8seq > 0) {
                if (e <= 127) throw Error('Invalid UTF-8 sequence');
                ((t.codepoint = (t.codepoint << 6) | (63 & e)),
                  (t.utf8seq -= 1),
                  0 === t.utf8seq && r(t.codepoint));
              }
            })((i >> (s - 8)) & 255, n, r),
              (s -= 8));
        else if (-2 === a) continue;
        else
          throw Error(
            `Invalid Base64-URL character "${e.at(t)}" at position ${t}`
          );
      }
      return t.join('');
    }
    let tU = 'base64-';
    async function tM(
      { getAll: e, setAll: t, setItems: r, removedItems: n },
      i
    ) {
      let s = i.cookieEncoding,
        a = i.cookieOptions ?? null,
        o = await e([
          ...(r ? Object.keys(r) : []),
          ...(n ? Object.keys(n) : []),
        ]),
        l = o?.map(({ name: e }) => e) || [],
        u = Object.keys(n).flatMap((e) => l.filter((t) => tA(t, e))),
        c = Object.keys(r).flatMap((e) => {
          let t = new Set(l.filter((t) => tA(t, e))),
            n = r[e];
          'base64url' === s && (n = tU + t$(n));
          let i = tC(e, n);
          return (
            i.forEach((e) => {
              t.delete(e.name);
            }),
            u.push(...t),
            i
          );
        }),
        h = { ...tP, ...a, maxAge: 0 },
        d = { ...tP, ...a, maxAge: tP.maxAge };
      (delete h.name,
        delete d.name,
        await t([
          ...u.map((e) => ({ name: e, value: '', options: h })),
          ...c.map(({ name: e, value: t }) => ({
            name: e,
            value: t,
            options: d,
          })),
        ]));
    }
    class tB extends Error {
      constructor(e, t = 'FunctionsError', r) {
        (super(e), (this.name = t), (this.context = r));
      }
    }
    class tq extends tB {
      constructor(e) {
        super(
          'Failed to send a request to the Edge Function',
          'FunctionsFetchError',
          e
        );
      }
    }
    class tV extends tB {
      constructor(e) {
        super(
          'Relay Error invoking the Edge Function',
          'FunctionsRelayError',
          e
        );
      }
    }
    class tW extends tB {
      constructor(e) {
        super(
          'Edge Function returned a non-2xx status code',
          'FunctionsHttpError',
          e
        );
      }
    }
    (((H = et || (et = {})).Any = 'any'),
      (H.ApNortheast1 = 'ap-northeast-1'),
      (H.ApNortheast2 = 'ap-northeast-2'),
      (H.ApSouth1 = 'ap-south-1'),
      (H.ApSoutheast1 = 'ap-southeast-1'),
      (H.ApSoutheast2 = 'ap-southeast-2'),
      (H.CaCentral1 = 'ca-central-1'),
      (H.EuCentral1 = 'eu-central-1'),
      (H.EuWest1 = 'eu-west-1'),
      (H.EuWest2 = 'eu-west-2'),
      (H.EuWest3 = 'eu-west-3'),
      (H.SaEast1 = 'sa-east-1'),
      (H.UsEast1 = 'us-east-1'),
      (H.UsWest1 = 'us-west-1'),
      (H.UsWest2 = 'us-west-2'));
    function tG(e, t) {
      var r = {};
      for (var n in e)
        Object.prototype.hasOwnProperty.call(e, n) &&
          0 > t.indexOf(n) &&
          (r[n] = e[n]);
      if (null != e && 'function' == typeof Object.getOwnPropertySymbols)
        for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
          0 > t.indexOf(n[i]) &&
            Object.prototype.propertyIsEnumerable.call(e, n[i]) &&
            (r[n[i]] = e[n[i]]);
      return r;
    }
    'function' == typeof SuppressedError && SuppressedError;
    class tH {
      constructor(
        e,
        { headers: t = {}, customFetch: r, region: n = et.Any } = {}
      ) {
        ((this.url = e),
          (this.headers = t),
          (this.region = n),
          (this.fetch = ((e) =>
            e ? (...t) => e(...t) : (...e) => fetch(...e))(r)));
      }
      setAuth(e) {
        this.headers.Authorization = `Bearer ${e}`;
      }
      invoke(e) {
        var t, r, n, i;
        return (
          (t = this),
          (r = arguments),
          (n = void 0),
          (i = function* (e, t = {}) {
            var r;
            let n, i;
            try {
              let s,
                { headers: a, method: o, body: l, signal: u, timeout: c } = t,
                h = {},
                { region: d } = t;
              d || (d = this.region);
              let p = new URL(`${this.url}/${e}`);
              (d &&
                'any' !== d &&
                ((h['x-region'] = d),
                p.searchParams.set('forceFunctionRegion', d)),
                l &&
                ((a &&
                  !Object.prototype.hasOwnProperty.call(a, 'Content-Type')) ||
                  !a)
                  ? ('u' > typeof Blob && l instanceof Blob) ||
                    l instanceof ArrayBuffer
                    ? ((h['Content-Type'] = 'application/octet-stream'),
                      (s = l))
                    : 'string' == typeof l
                      ? ((h['Content-Type'] = 'text/plain'), (s = l))
                      : 'u' > typeof FormData && l instanceof FormData
                        ? (s = l)
                        : ((h['Content-Type'] = 'application/json'),
                          (s = JSON.stringify(l)))
                  : (s =
                      !l ||
                      'string' == typeof l ||
                      ('u' > typeof Blob && l instanceof Blob) ||
                      l instanceof ArrayBuffer ||
                      ('u' > typeof FormData && l instanceof FormData)
                        ? l
                        : JSON.stringify(l)));
              let f = u;
              c &&
                ((i = new AbortController()),
                (n = setTimeout(() => i.abort(), c)),
                u
                  ? ((f = i.signal),
                    u.addEventListener('abort', () => i.abort()))
                  : (f = i.signal));
              let g = yield this.fetch(p.toString(), {
                  method: o || 'POST',
                  headers: Object.assign(
                    Object.assign(Object.assign({}, h), this.headers),
                    a
                  ),
                  body: s,
                  signal: f,
                }).catch((e) => {
                  throw new tq(e);
                }),
                m = g.headers.get('x-relay-error');
              if (m && 'true' === m) throw new tV(g);
              if (!g.ok) throw new tW(g);
              let y = (
                null != (r = g.headers.get('Content-Type')) ? r : 'text/plain'
              )
                .split(';')[0]
                .trim();
              return {
                data:
                  'application/json' === y
                    ? yield g.json()
                    : 'application/octet-stream' === y ||
                        'application/pdf' === y
                      ? yield g.blob()
                      : 'text/event-stream' === y
                        ? g
                        : 'multipart/form-data' === y
                          ? yield g.formData()
                          : yield g.text(),
                error: null,
                response: g,
              };
            } catch (e) {
              return {
                data: null,
                error: e,
                response:
                  e instanceof tW || e instanceof tV ? e.context : void 0,
              };
            } finally {
              n && clearTimeout(n);
            }
          }),
          new (n || (n = Promise))(function (e, s) {
            function a(e) {
              try {
                l(i.next(e));
              } catch (e) {
                s(e);
              }
            }
            function o(e) {
              try {
                l(i.throw(e));
              } catch (e) {
                s(e);
              }
            }
            function l(t) {
              var r;
              t.done
                ? e(t.value)
                : ((r = t.value) instanceof n
                    ? r
                    : new n(function (e) {
                        e(r);
                      })
                  ).then(a, o);
            }
            l((i = i.apply(t, r || [])).next());
          })
        );
      }
    }
    var tF = class extends Error {
        constructor(e) {
          (super(e.message),
            (this.name = 'PostgrestError'),
            (this.details = e.details),
            (this.hint = e.hint),
            (this.code = e.code));
        }
      },
      tz = class {
        constructor(e) {
          var t, r;
          ((this.shouldThrowOnError = !1),
            (this.method = e.method),
            (this.url = e.url),
            (this.headers = new Headers(e.headers)),
            (this.schema = e.schema),
            (this.body = e.body),
            (this.shouldThrowOnError = null != (t = e.shouldThrowOnError) && t),
            (this.signal = e.signal),
            (this.isMaybeSingle = null != (r = e.isMaybeSingle) && r),
            e.fetch ? (this.fetch = e.fetch) : (this.fetch = fetch));
        }
        throwOnError() {
          return ((this.shouldThrowOnError = !0), this);
        }
        setHeader(e, t) {
          return (
            (this.headers = new Headers(this.headers)),
            this.headers.set(e, t),
            this
          );
        }
        then(e, t) {
          var r = this;
          (void 0 === this.schema ||
            (['GET', 'HEAD'].includes(this.method)
              ? this.headers.set('Accept-Profile', this.schema)
              : this.headers.set('Content-Profile', this.schema)),
            'GET' !== this.method &&
              'HEAD' !== this.method &&
              this.headers.set('Content-Type', 'application/json'));
          let n = (0, this.fetch)(this.url.toString(), {
            method: this.method,
            headers: this.headers,
            body: JSON.stringify(this.body),
            signal: this.signal,
          }).then(async (e) => {
            var t, n, i, s;
            let a = null,
              o = null,
              l = null,
              u = e.status,
              c = e.statusText;
            if (e.ok) {
              if ('HEAD' !== r.method) {
                let t = await e.text();
                '' === t ||
                  (o =
                    'text/csv' === r.headers.get('Accept') ||
                    (r.headers.get('Accept') &&
                      (null == (i = r.headers.get('Accept'))
                        ? void 0
                        : i.includes('application/vnd.pgrst.plan+text')))
                      ? t
                      : JSON.parse(t));
              }
              let s =
                  null == (t = r.headers.get('Prefer'))
                    ? void 0
                    : t.match(/count=(exact|planned|estimated)/),
                h =
                  null == (n = e.headers.get('content-range'))
                    ? void 0
                    : n.split('/');
              (s && h && h.length > 1 && (l = parseInt(h[1])),
                r.isMaybeSingle &&
                  'GET' === r.method &&
                  Array.isArray(o) &&
                  (o.length > 1
                    ? ((a = {
                        code: 'PGRST116',
                        details: `Results contain ${o.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                        hint: null,
                        message:
                          'JSON object requested, multiple (or no) rows returned',
                      }),
                      (o = null),
                      (l = null),
                      (u = 406),
                      (c = 'Not Acceptable'))
                    : (o = 1 === o.length ? o[0] : null)));
            } else {
              let t = await e.text();
              try {
                ((a = JSON.parse(t)),
                  Array.isArray(a) &&
                    404 === e.status &&
                    ((o = []), (a = null), (u = 200), (c = 'OK')));
              } catch (r) {
                404 === e.status && '' === t
                  ? ((u = 204), (c = 'No Content'))
                  : (a = { message: t });
              }
              if (
                (a &&
                  r.isMaybeSingle &&
                  (null == a || null == (s = a.details)
                    ? void 0
                    : s.includes('0 rows')) &&
                  ((a = null), (u = 200), (c = 'OK')),
                a && r.shouldThrowOnError)
              )
                throw new tF(a);
            }
            return { error: a, data: o, count: l, status: u, statusText: c };
          });
          return (
            this.shouldThrowOnError ||
              (n = n.catch((e) => {
                var t, r, n, i, s, a;
                let o = '',
                  l = null == e ? void 0 : e.cause;
                if (l) {
                  let t = null != (r = null == l ? void 0 : l.message) ? r : '',
                    a = null != (n = null == l ? void 0 : l.code) ? n : '';
                  ((o = `${null != (i = null == e ? void 0 : e.name) ? i : 'FetchError'}: ${null == e ? void 0 : e.message}

Caused by: ${null != (s = null == l ? void 0 : l.name) ? s : 'Error'}: ${t}`),
                    a && (o += ` (${a})`),
                    (null == l ? void 0 : l.stack) &&
                      (o += `
${l.stack}`));
                } else o = null != (a = null == e ? void 0 : e.stack) ? a : '';
                return {
                  error: {
                    message: `${null != (t = null == e ? void 0 : e.name) ? t : 'FetchError'}: ${null == e ? void 0 : e.message}`,
                    details: o,
                    hint: '',
                    code: '',
                  },
                  data: null,
                  count: null,
                  status: 0,
                  statusText: '',
                };
              })),
            n.then(e, t)
          );
        }
        returns() {
          return this;
        }
        overrideTypes() {
          return this;
        }
      },
      tK = class extends tz {
        select(e) {
          let t = !1,
            r = (null != e ? e : '*')
              .split('')
              .map((e) =>
                /\s/.test(e) && !t ? '' : ('"' === e && (t = !t), e)
              )
              .join('');
          return (
            this.url.searchParams.set('select', r),
            this.headers.append('Prefer', 'return=representation'),
            this
          );
        }
        order(
          e,
          {
            ascending: t = !0,
            nullsFirst: r,
            foreignTable: n,
            referencedTable: i = n,
          } = {}
        ) {
          let s = i ? `${i}.order` : 'order',
            a = this.url.searchParams.get(s);
          return (
            this.url.searchParams.set(
              s,
              `${a ? `${a},` : ''}${e}.${t ? 'asc' : 'desc'}${void 0 === r ? '' : r ? '.nullsfirst' : '.nullslast'}`
            ),
            this
          );
        }
        limit(e, { foreignTable: t, referencedTable: r = t } = {}) {
          let n = void 0 === r ? 'limit' : `${r}.limit`;
          return (this.url.searchParams.set(n, `${e}`), this);
        }
        range(e, t, { foreignTable: r, referencedTable: n = r } = {}) {
          let i = void 0 === n ? 'offset' : `${n}.offset`,
            s = void 0 === n ? 'limit' : `${n}.limit`;
          return (
            this.url.searchParams.set(i, `${e}`),
            this.url.searchParams.set(s, `${t - e + 1}`),
            this
          );
        }
        abortSignal(e) {
          return ((this.signal = e), this);
        }
        single() {
          return (
            this.headers.set('Accept', 'application/vnd.pgrst.object+json'),
            this
          );
        }
        maybeSingle() {
          return (
            'GET' === this.method
              ? this.headers.set('Accept', 'application/json')
              : this.headers.set('Accept', 'application/vnd.pgrst.object+json'),
            (this.isMaybeSingle = !0),
            this
          );
        }
        csv() {
          return (this.headers.set('Accept', 'text/csv'), this);
        }
        geojson() {
          return (this.headers.set('Accept', 'application/geo+json'), this);
        }
        explain({
          analyze: e = !1,
          verbose: t = !1,
          settings: r = !1,
          buffers: n = !1,
          wal: i = !1,
          format: s = 'text',
        } = {}) {
          var a;
          let o = [
              e ? 'analyze' : null,
              t ? 'verbose' : null,
              r ? 'settings' : null,
              n ? 'buffers' : null,
              i ? 'wal' : null,
            ]
              .filter(Boolean)
              .join('|'),
            l =
              null != (a = this.headers.get('Accept')) ? a : 'application/json';
          return (
            this.headers.set(
              'Accept',
              `application/vnd.pgrst.plan+${s}; for="${l}"; options=${o};`
            ),
            this
          );
        }
        rollback() {
          return (this.headers.append('Prefer', 'tx=rollback'), this);
        }
        returns() {
          return this;
        }
        maxAffected(e) {
          return (
            this.headers.append('Prefer', 'handling=strict'),
            this.headers.append('Prefer', `max-affected=${e}`),
            this
          );
        }
      };
    let tX = RegExp('[,()]');
    var tJ = class extends tK {
        eq(e, t) {
          return (this.url.searchParams.append(e, `eq.${t}`), this);
        }
        neq(e, t) {
          return (this.url.searchParams.append(e, `neq.${t}`), this);
        }
        gt(e, t) {
          return (this.url.searchParams.append(e, `gt.${t}`), this);
        }
        gte(e, t) {
          return (this.url.searchParams.append(e, `gte.${t}`), this);
        }
        lt(e, t) {
          return (this.url.searchParams.append(e, `lt.${t}`), this);
        }
        lte(e, t) {
          return (this.url.searchParams.append(e, `lte.${t}`), this);
        }
        like(e, t) {
          return (this.url.searchParams.append(e, `like.${t}`), this);
        }
        likeAllOf(e, t) {
          return (
            this.url.searchParams.append(e, `like(all).{${t.join(',')}}`),
            this
          );
        }
        likeAnyOf(e, t) {
          return (
            this.url.searchParams.append(e, `like(any).{${t.join(',')}}`),
            this
          );
        }
        ilike(e, t) {
          return (this.url.searchParams.append(e, `ilike.${t}`), this);
        }
        ilikeAllOf(e, t) {
          return (
            this.url.searchParams.append(e, `ilike(all).{${t.join(',')}}`),
            this
          );
        }
        ilikeAnyOf(e, t) {
          return (
            this.url.searchParams.append(e, `ilike(any).{${t.join(',')}}`),
            this
          );
        }
        regexMatch(e, t) {
          return (this.url.searchParams.append(e, `match.${t}`), this);
        }
        regexIMatch(e, t) {
          return (this.url.searchParams.append(e, `imatch.${t}`), this);
        }
        is(e, t) {
          return (this.url.searchParams.append(e, `is.${t}`), this);
        }
        isDistinct(e, t) {
          return (this.url.searchParams.append(e, `isdistinct.${t}`), this);
        }
        in(e, t) {
          let r = Array.from(new Set(t))
            .map((e) =>
              'string' == typeof e && tX.test(e) ? `"${e}"` : `${e}`
            )
            .join(',');
          return (this.url.searchParams.append(e, `in.(${r})`), this);
        }
        notIn(e, t) {
          let r = Array.from(new Set(t))
            .map((e) =>
              'string' == typeof e && tX.test(e) ? `"${e}"` : `${e}`
            )
            .join(',');
          return (this.url.searchParams.append(e, `not.in.(${r})`), this);
        }
        contains(e, t) {
          return (
            'string' == typeof t
              ? this.url.searchParams.append(e, `cs.${t}`)
              : Array.isArray(t)
                ? this.url.searchParams.append(e, `cs.{${t.join(',')}}`)
                : this.url.searchParams.append(e, `cs.${JSON.stringify(t)}`),
            this
          );
        }
        containedBy(e, t) {
          return (
            'string' == typeof t
              ? this.url.searchParams.append(e, `cd.${t}`)
              : Array.isArray(t)
                ? this.url.searchParams.append(e, `cd.{${t.join(',')}}`)
                : this.url.searchParams.append(e, `cd.${JSON.stringify(t)}`),
            this
          );
        }
        rangeGt(e, t) {
          return (this.url.searchParams.append(e, `sr.${t}`), this);
        }
        rangeGte(e, t) {
          return (this.url.searchParams.append(e, `nxl.${t}`), this);
        }
        rangeLt(e, t) {
          return (this.url.searchParams.append(e, `sl.${t}`), this);
        }
        rangeLte(e, t) {
          return (this.url.searchParams.append(e, `nxr.${t}`), this);
        }
        rangeAdjacent(e, t) {
          return (this.url.searchParams.append(e, `adj.${t}`), this);
        }
        overlaps(e, t) {
          return (
            'string' == typeof t
              ? this.url.searchParams.append(e, `ov.${t}`)
              : this.url.searchParams.append(e, `ov.{${t.join(',')}}`),
            this
          );
        }
        textSearch(e, t, { config: r, type: n } = {}) {
          let i = '';
          'plain' === n
            ? (i = 'pl')
            : 'phrase' === n
              ? (i = 'ph')
              : 'websearch' === n && (i = 'w');
          let s = void 0 === r ? '' : `(${r})`;
          return (this.url.searchParams.append(e, `${i}fts${s}.${t}`), this);
        }
        match(e) {
          return (
            Object.entries(e).forEach(([e, t]) => {
              this.url.searchParams.append(e, `eq.${t}`);
            }),
            this
          );
        }
        not(e, t, r) {
          return (this.url.searchParams.append(e, `not.${t}.${r}`), this);
        }
        or(e, { foreignTable: t, referencedTable: r = t } = {}) {
          let n = r ? `${r}.or` : 'or';
          return (this.url.searchParams.append(n, `(${e})`), this);
        }
        filter(e, t, r) {
          return (this.url.searchParams.append(e, `${t}.${r}`), this);
        }
      },
      tY = class {
        constructor(e, { headers: t = {}, schema: r, fetch: n }) {
          ((this.url = e),
            (this.headers = new Headers(t)),
            (this.schema = r),
            (this.fetch = n));
        }
        cloneRequestState() {
          return {
            url: new URL(this.url.toString()),
            headers: new Headers(this.headers),
          };
        }
        select(e, t) {
          let { head: r = !1, count: n } = null != t ? t : {},
            i = !1,
            s = (null != e ? e : '*')
              .split('')
              .map((e) =>
                /\s/.test(e) && !i ? '' : ('"' === e && (i = !i), e)
              )
              .join(''),
            { url: a, headers: o } = this.cloneRequestState();
          return (
            a.searchParams.set('select', s),
            n && o.append('Prefer', `count=${n}`),
            new tJ({
              method: r ? 'HEAD' : 'GET',
              url: a,
              headers: o,
              schema: this.schema,
              fetch: this.fetch,
            })
          );
        }
        insert(e, { count: t, defaultToNull: r = !0 } = {}) {
          var n;
          let { url: i, headers: s } = this.cloneRequestState();
          if (
            (t && s.append('Prefer', `count=${t}`),
            r || s.append('Prefer', 'missing=default'),
            Array.isArray(e))
          ) {
            let t = e.reduce((e, t) => e.concat(Object.keys(t)), []);
            if (t.length > 0) {
              let e = [...new Set(t)].map((e) => `"${e}"`);
              i.searchParams.set('columns', e.join(','));
            }
          }
          return new tJ({
            method: 'POST',
            url: i,
            headers: s,
            schema: this.schema,
            body: e,
            fetch: null != (n = this.fetch) ? n : fetch,
          });
        }
        upsert(
          e,
          {
            onConflict: t,
            ignoreDuplicates: r = !1,
            count: n,
            defaultToNull: i = !0,
          } = {}
        ) {
          var s;
          let { url: a, headers: o } = this.cloneRequestState();
          if (
            (o.append(
              'Prefer',
              `resolution=${r ? 'ignore' : 'merge'}-duplicates`
            ),
            void 0 !== t && a.searchParams.set('on_conflict', t),
            n && o.append('Prefer', `count=${n}`),
            i || o.append('Prefer', 'missing=default'),
            Array.isArray(e))
          ) {
            let t = e.reduce((e, t) => e.concat(Object.keys(t)), []);
            if (t.length > 0) {
              let e = [...new Set(t)].map((e) => `"${e}"`);
              a.searchParams.set('columns', e.join(','));
            }
          }
          return new tJ({
            method: 'POST',
            url: a,
            headers: o,
            schema: this.schema,
            body: e,
            fetch: null != (s = this.fetch) ? s : fetch,
          });
        }
        update(e, { count: t } = {}) {
          var r;
          let { url: n, headers: i } = this.cloneRequestState();
          return (
            t && i.append('Prefer', `count=${t}`),
            new tJ({
              method: 'PATCH',
              url: n,
              headers: i,
              schema: this.schema,
              body: e,
              fetch: null != (r = this.fetch) ? r : fetch,
            })
          );
        }
        delete({ count: e } = {}) {
          var t;
          let { url: r, headers: n } = this.cloneRequestState();
          return (
            e && n.append('Prefer', `count=${e}`),
            new tJ({
              method: 'DELETE',
              url: r,
              headers: n,
              schema: this.schema,
              fetch: null != (t = this.fetch) ? t : fetch,
            })
          );
        }
      },
      tQ = class e {
        constructor(e, { headers: t = {}, schema: r, fetch: n } = {}) {
          ((this.url = e),
            (this.headers = new Headers(t)),
            (this.schemaName = r),
            (this.fetch = n));
        }
        from(e) {
          if (!e || 'string' != typeof e || '' === e.trim())
            throw Error(
              'Invalid relation name: relation must be a non-empty string.'
            );
          return new tY(new URL(`${this.url}/${e}`), {
            headers: new Headers(this.headers),
            schema: this.schemaName,
            fetch: this.fetch,
          });
        }
        schema(t) {
          return new e(this.url, {
            headers: this.headers,
            schema: t,
            fetch: this.fetch,
          });
        }
        rpc(e, t = {}, { head: r = !1, get: n = !1, count: i } = {}) {
          var s;
          let a,
            o,
            l = new URL(`${this.url}/rpc/${e}`),
            u = (e) =>
              null !== e &&
              'object' == typeof e &&
              (!Array.isArray(e) || e.some(u)),
            c = r && Object.values(t).some(u);
          c
            ? ((a = 'POST'), (o = t))
            : r || n
              ? ((a = r ? 'HEAD' : 'GET'),
                Object.entries(t)
                  .filter(([e, t]) => void 0 !== t)
                  .map(([e, t]) => [
                    e,
                    Array.isArray(t) ? `{${t.join(',')}}` : `${t}`,
                  ])
                  .forEach(([e, t]) => {
                    l.searchParams.append(e, t);
                  }))
              : ((a = 'POST'), (o = t));
          let h = new Headers(this.headers);
          return (
            c
              ? h.set(
                  'Prefer',
                  i ? `count=${i},return=minimal` : 'return=minimal'
                )
              : i && h.set('Prefer', `count=${i}`),
            new tJ({
              method: a,
              url: l,
              headers: h,
              schema: this.schemaName,
              body: o,
              fetch: null != (s = this.fetch) ? s : fetch,
            })
          );
        }
      };
    let tZ = class {
        static detectEnvironment() {
          var t;
          if ('u' > typeof WebSocket)
            return { type: 'native', constructor: WebSocket };
          if ('u' > typeof globalThis && void 0 !== globalThis.WebSocket)
            return { type: 'native', constructor: globalThis.WebSocket };
          if (void 0 !== e.g.WebSocket)
            return { type: 'native', constructor: e.g.WebSocket };
          if (
            'u' > typeof globalThis &&
            void 0 !== globalThis.WebSocketPair &&
            void 0 === globalThis.WebSocket
          )
            return {
              type: 'cloudflare',
              error:
                'Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.',
              workaround:
                'Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime.',
            };
          if (
            ('u' > typeof globalThis && globalThis.EdgeRuntime) ||
            ('u' > typeof navigator &&
              (null == (t = navigator.userAgent)
                ? void 0
                : t.includes('Vercel-Edge')))
          )
            return {
              type: 'unsupported',
              error:
                'Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.',
              workaround:
                'Use serverless functions or a different deployment target for WebSocket functionality.',
            };
          let r = globalThis.process;
          if (r) {
            let e = r.versions;
            if (e && e.node) {
              let t = parseInt(e.node.replace(/^v/, '').split('.')[0]);
              return t >= 22
                ? void 0 !== globalThis.WebSocket
                  ? { type: 'native', constructor: globalThis.WebSocket }
                  : {
                      type: 'unsupported',
                      error: `Node.js ${t} detected but native WebSocket not found.`,
                      workaround:
                        'Provide a WebSocket implementation via the transport option.',
                    }
                : {
                    type: 'unsupported',
                    error: `Node.js ${t} detected without native WebSocket support.`,
                    workaround:
                      'For Node.js < 22, install "ws" package and provide it via the transport option:\nimport ws from "ws"\nnew RealtimeClient(url, { transport: ws })',
                  };
            }
          }
          return {
            type: 'unsupported',
            error: 'Unknown JavaScript runtime without WebSocket support.',
            workaround:
              "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation.",
          };
        }
        static getWebSocketConstructor() {
          let e = this.detectEnvironment();
          if (e.constructor) return e.constructor;
          let t = e.error || 'WebSocket not supported in this environment.';
          throw (
            e.workaround &&
              (t += `

Suggested solution: ${e.workaround}`),
            Error(t)
          );
        }
        static createWebSocket(e, t) {
          return new (this.getWebSocketConstructor())(e, t);
        }
        static isWebSocketSupported() {
          try {
            let e = this.detectEnvironment();
            return 'native' === e.type || 'ws' === e.type;
          } catch (e) {
            return !1;
          }
        }
      },
      t0 = '2.0.0';
    (((F = er || (er = {}))[(F.connecting = 0)] = 'connecting'),
      (F[(F.open = 1)] = 'open'),
      (F[(F.closing = 2)] = 'closing'),
      (F[(F.closed = 3)] = 'closed'),
      ((z = en || (en = {})).closed = 'closed'),
      (z.errored = 'errored'),
      (z.joined = 'joined'),
      (z.joining = 'joining'),
      (z.leaving = 'leaving'),
      ((K = ei || (ei = {})).close = 'phx_close'),
      (K.error = 'phx_error'),
      (K.join = 'phx_join'),
      (K.reply = 'phx_reply'),
      (K.leave = 'phx_leave'),
      (K.access_token = 'access_token'),
      ((es || (es = {})).websocket = 'websocket'),
      ((X = ea || (ea = {})).Connecting = 'connecting'),
      (X.Open = 'open'),
      (X.Closing = 'closing'),
      (X.Closed = 'closed'));
    class t1 {
      constructor(e) {
        ((this.HEADER_LENGTH = 1),
          (this.USER_BROADCAST_PUSH_META_LENGTH = 6),
          (this.KINDS = { userBroadcastPush: 3, userBroadcast: 4 }),
          (this.BINARY_ENCODING = 0),
          (this.JSON_ENCODING = 1),
          (this.BROADCAST_EVENT = 'broadcast'),
          (this.allowedMetadataKeys = []),
          (this.allowedMetadataKeys = null != e ? e : []));
      }
      encode(e, t) {
        return e.event !== this.BROADCAST_EVENT ||
          e.payload instanceof ArrayBuffer ||
          'string' != typeof e.payload.event
          ? t(JSON.stringify([e.join_ref, e.ref, e.topic, e.event, e.payload]))
          : t(this._binaryEncodeUserBroadcastPush(e));
      }
      _binaryEncodeUserBroadcastPush(e) {
        var t;
        return this._isArrayBuffer(null == (t = e.payload) ? void 0 : t.payload)
          ? this._encodeBinaryUserBroadcastPush(e)
          : this._encodeJsonUserBroadcastPush(e);
      }
      _encodeBinaryUserBroadcastPush(e) {
        var t, r;
        let n =
          null != (r = null == (t = e.payload) ? void 0 : t.payload)
            ? r
            : new ArrayBuffer(0);
        return this._encodeUserBroadcastPush(e, this.BINARY_ENCODING, n);
      }
      _encodeJsonUserBroadcastPush(e) {
        var t, r;
        let n =
            null != (r = null == (t = e.payload) ? void 0 : t.payload) ? r : {},
          i = new TextEncoder().encode(JSON.stringify(n)).buffer;
        return this._encodeUserBroadcastPush(e, this.JSON_ENCODING, i);
      }
      _encodeUserBroadcastPush(e, t, r) {
        let n = e.topic,
          i = null != (p = e.ref) ? p : '',
          s = null != (f = e.join_ref) ? f : '',
          a = e.payload.event,
          o = this.allowedMetadataKeys
            ? this._pick(e.payload, this.allowedMetadataKeys)
            : {},
          l = 0 === Object.keys(o).length ? '' : JSON.stringify(o);
        if (s.length > 255)
          throw Error(`joinRef length ${s.length} exceeds maximum of 255`);
        if (i.length > 255)
          throw Error(`ref length ${i.length} exceeds maximum of 255`);
        if (n.length > 255)
          throw Error(`topic length ${n.length} exceeds maximum of 255`);
        if (a.length > 255)
          throw Error(`userEvent length ${a.length} exceeds maximum of 255`);
        if (l.length > 255)
          throw Error(`metadata length ${l.length} exceeds maximum of 255`);
        let u =
            this.USER_BROADCAST_PUSH_META_LENGTH +
            s.length +
            i.length +
            n.length +
            a.length +
            l.length,
          c = new ArrayBuffer(this.HEADER_LENGTH + u),
          h = new DataView(c),
          d = 0;
        (h.setUint8(d++, this.KINDS.userBroadcastPush),
          h.setUint8(d++, s.length),
          h.setUint8(d++, i.length),
          h.setUint8(d++, n.length),
          h.setUint8(d++, a.length),
          h.setUint8(d++, l.length),
          h.setUint8(d++, t),
          Array.from(s, (e) => h.setUint8(d++, e.charCodeAt(0))),
          Array.from(i, (e) => h.setUint8(d++, e.charCodeAt(0))),
          Array.from(n, (e) => h.setUint8(d++, e.charCodeAt(0))),
          Array.from(a, (e) => h.setUint8(d++, e.charCodeAt(0))),
          Array.from(l, (e) => h.setUint8(d++, e.charCodeAt(0))));
        var p,
          f,
          g = new Uint8Array(c.byteLength + r.byteLength);
        return (
          g.set(new Uint8Array(c), 0),
          g.set(new Uint8Array(r), c.byteLength),
          g.buffer
        );
      }
      decode(e, t) {
        if (this._isArrayBuffer(e)) return t(this._binaryDecode(e));
        if ('string' == typeof e) {
          let [r, n, i, s, a] = JSON.parse(e);
          return t({ join_ref: r, ref: n, topic: i, event: s, payload: a });
        }
        return t({});
      }
      _binaryDecode(e) {
        let t = new DataView(e),
          r = t.getUint8(0),
          n = new TextDecoder();
        if (r === this.KINDS.userBroadcast)
          return this._decodeUserBroadcast(e, t, n);
      }
      _decodeUserBroadcast(e, t, r) {
        let n = t.getUint8(1),
          i = t.getUint8(2),
          s = t.getUint8(3),
          a = t.getUint8(4),
          o = this.HEADER_LENGTH + 4,
          l = r.decode(e.slice(o, o + n));
        o += n;
        let u = r.decode(e.slice(o, o + i));
        o += i;
        let c = r.decode(e.slice(o, o + s));
        o += s;
        let h = e.slice(o, e.byteLength),
          d = a === this.JSON_ENCODING ? JSON.parse(r.decode(h)) : h,
          p = { type: this.BROADCAST_EVENT, event: u, payload: d };
        return (
          s > 0 && (p.meta = JSON.parse(c)),
          {
            join_ref: null,
            ref: null,
            topic: l,
            event: this.BROADCAST_EVENT,
            payload: p,
          }
        );
      }
      _isArrayBuffer(e) {
        var t;
        return (
          e instanceof ArrayBuffer ||
          (null == (t = null == e ? void 0 : e.constructor)
            ? void 0
            : t.name) === 'ArrayBuffer'
        );
      }
      _pick(e, t) {
        return e && 'object' == typeof e
          ? Object.fromEntries(Object.entries(e).filter(([e]) => t.includes(e)))
          : {};
      }
    }
    class t2 {
      constructor(e, t) {
        ((this.callback = e),
          (this.timerCalc = t),
          (this.timer = void 0),
          (this.tries = 0),
          (this.callback = e),
          (this.timerCalc = t));
      }
      reset() {
        ((this.tries = 0), clearTimeout(this.timer), (this.timer = void 0));
      }
      scheduleTimeout() {
        (clearTimeout(this.timer),
          (this.timer = setTimeout(
            () => {
              ((this.tries = this.tries + 1), this.callback());
            },
            this.timerCalc(this.tries + 1)
          )));
      }
    }
    (((J = eo || (eo = {})).abstime = 'abstime'),
      (J.bool = 'bool'),
      (J.date = 'date'),
      (J.daterange = 'daterange'),
      (J.float4 = 'float4'),
      (J.float8 = 'float8'),
      (J.int2 = 'int2'),
      (J.int4 = 'int4'),
      (J.int4range = 'int4range'),
      (J.int8 = 'int8'),
      (J.int8range = 'int8range'),
      (J.json = 'json'),
      (J.jsonb = 'jsonb'),
      (J.money = 'money'),
      (J.numeric = 'numeric'),
      (J.oid = 'oid'),
      (J.reltime = 'reltime'),
      (J.text = 'text'),
      (J.time = 'time'),
      (J.timestamp = 'timestamp'),
      (J.timestamptz = 'timestamptz'),
      (J.timetz = 'timetz'),
      (J.tsrange = 'tsrange'),
      (J.tstzrange = 'tstzrange'));
    let t3 = (e, t, r = {}) => {
        var n;
        let i = null != (n = r.skipTypes) ? n : [];
        return t
          ? Object.keys(t).reduce((r, n) => ((r[n] = t4(n, e, t, i)), r), {})
          : {};
      },
      t4 = (e, t, r, n) => {
        let i = t.find((t) => t.name === e),
          s = null == i ? void 0 : i.type,
          a = r[e];
        return s && !n.includes(s) ? t5(s, a) : t6(a);
      },
      t5 = (e, t) => {
        if ('_' === e.charAt(0)) return re(t, e.slice(1, e.length));
        switch (e) {
          case eo.bool:
            return t9(t);
          case eo.float4:
          case eo.float8:
          case eo.int2:
          case eo.int4:
          case eo.int8:
          case eo.numeric:
          case eo.oid:
            return t8(t);
          case eo.json:
          case eo.jsonb:
            return t7(t);
          case eo.timestamp:
            return rt(t);
          case eo.abstime:
          case eo.date:
          case eo.daterange:
          case eo.int4range:
          case eo.int8range:
          case eo.money:
          case eo.reltime:
          case eo.text:
          case eo.time:
          case eo.timestamptz:
          case eo.timetz:
          case eo.tsrange:
          case eo.tstzrange:
          default:
            return t6(t);
        }
      },
      t6 = (e) => e,
      t9 = (e) => {
        switch (e) {
          case 't':
            return !0;
          case 'f':
            return !1;
          default:
            return e;
        }
      },
      t8 = (e) => {
        if ('string' == typeof e) {
          let t = parseFloat(e);
          if (!Number.isNaN(t)) return t;
        }
        return e;
      },
      t7 = (e) => {
        if ('string' == typeof e)
          try {
            return JSON.parse(e);
          } catch (e) {}
        return e;
      },
      re = (e, t) => {
        if ('string' != typeof e) return e;
        let r = e.length - 1,
          n = e[r];
        if ('{' === e[0] && '}' === n) {
          let n,
            i = e.slice(1, r);
          try {
            n = JSON.parse('[' + i + ']');
          } catch (e) {
            n = i ? i.split(',') : [];
          }
          return n.map((e) => t5(t, e));
        }
        return e;
      },
      rt = (e) => ('string' == typeof e ? e.replace(' ', 'T') : e),
      rr = (e) => {
        let t = new URL(e);
        return (
          (t.protocol = t.protocol.replace(/^ws/i, 'http')),
          (t.pathname = t.pathname
            .replace(/\/+$/, '')
            .replace(/\/socket\/websocket$/i, '')
            .replace(/\/socket$/i, '')
            .replace(/\/websocket$/i, '')),
          '' === t.pathname || '/' === t.pathname
            ? (t.pathname = '/api/broadcast')
            : (t.pathname = t.pathname + '/api/broadcast'),
          t.href
        );
      };
    class rn {
      constructor(e, t, r = {}, n = 1e4) {
        ((this.channel = e),
          (this.event = t),
          (this.payload = r),
          (this.timeout = n),
          (this.sent = !1),
          (this.timeoutTimer = void 0),
          (this.ref = ''),
          (this.receivedResp = null),
          (this.recHooks = []),
          (this.refEvent = null));
      }
      resend(e) {
        ((this.timeout = e),
          this._cancelRefEvent(),
          (this.ref = ''),
          (this.refEvent = null),
          (this.receivedResp = null),
          (this.sent = !1),
          this.send());
      }
      send() {
        this._hasReceived('timeout') ||
          (this.startTimeout(),
          (this.sent = !0),
          this.channel.socket.push({
            topic: this.channel.topic,
            event: this.event,
            payload: this.payload,
            ref: this.ref,
            join_ref: this.channel._joinRef(),
          }));
      }
      updatePayload(e) {
        this.payload = Object.assign(Object.assign({}, this.payload), e);
      }
      receive(e, t) {
        var r;
        return (
          this._hasReceived(e) &&
            t(null == (r = this.receivedResp) ? void 0 : r.response),
          this.recHooks.push({ status: e, callback: t }),
          this
        );
      }
      startTimeout() {
        if (this.timeoutTimer) return;
        ((this.ref = this.channel.socket._makeRef()),
          (this.refEvent = this.channel._replyEventName(this.ref)));
        let e = (e) => {
          (this._cancelRefEvent(),
            this._cancelTimeout(),
            (this.receivedResp = e),
            this._matchReceive(e));
        };
        (this.channel._on(this.refEvent, {}, e),
          (this.timeoutTimer = setTimeout(() => {
            this.trigger('timeout', {});
          }, this.timeout)));
      }
      trigger(e, t) {
        this.refEvent &&
          this.channel._trigger(this.refEvent, { status: e, response: t });
      }
      destroy() {
        (this._cancelRefEvent(), this._cancelTimeout());
      }
      _cancelRefEvent() {
        this.refEvent && this.channel._off(this.refEvent, {});
      }
      _cancelTimeout() {
        (clearTimeout(this.timeoutTimer), (this.timeoutTimer = void 0));
      }
      _matchReceive({ status: e, response: t }) {
        this.recHooks
          .filter((t) => t.status === e)
          .forEach((e) => e.callback(t));
      }
      _hasReceived(e) {
        return this.receivedResp && this.receivedResp.status === e;
      }
    }
    (((Y = el || (el = {})).SYNC = 'sync'),
      (Y.JOIN = 'join'),
      (Y.LEAVE = 'leave'));
    class ri {
      constructor(e, t) {
        ((this.channel = e),
          (this.state = {}),
          (this.pendingDiffs = []),
          (this.joinRef = null),
          (this.enabled = !1),
          (this.caller = {
            onJoin: () => {},
            onLeave: () => {},
            onSync: () => {},
          }));
        const r = (null == t ? void 0 : t.events) || {
          state: 'presence_state',
          diff: 'presence_diff',
        };
        (this.channel._on(r.state, {}, (e) => {
          let { onJoin: t, onLeave: r, onSync: n } = this.caller;
          ((this.joinRef = this.channel._joinRef()),
            (this.state = ri.syncState(this.state, e, t, r)),
            this.pendingDiffs.forEach((e) => {
              this.state = ri.syncDiff(this.state, e, t, r);
            }),
            (this.pendingDiffs = []),
            n());
        }),
          this.channel._on(r.diff, {}, (e) => {
            let { onJoin: t, onLeave: r, onSync: n } = this.caller;
            this.inPendingSyncState()
              ? this.pendingDiffs.push(e)
              : ((this.state = ri.syncDiff(this.state, e, t, r)), n());
          }),
          this.onJoin((e, t, r) => {
            this.channel._trigger('presence', {
              event: 'join',
              key: e,
              currentPresences: t,
              newPresences: r,
            });
          }),
          this.onLeave((e, t, r) => {
            this.channel._trigger('presence', {
              event: 'leave',
              key: e,
              currentPresences: t,
              leftPresences: r,
            });
          }),
          this.onSync(() => {
            this.channel._trigger('presence', { event: 'sync' });
          }));
      }
      static syncState(e, t, r, n) {
        let i = this.cloneDeep(e),
          s = this.transformState(t),
          a = {},
          o = {};
        return (
          this.map(i, (e, t) => {
            s[e] || (o[e] = t);
          }),
          this.map(s, (e, t) => {
            let r = i[e];
            if (r) {
              let n = t.map((e) => e.presence_ref),
                i = r.map((e) => e.presence_ref),
                s = t.filter((e) => 0 > i.indexOf(e.presence_ref)),
                l = r.filter((e) => 0 > n.indexOf(e.presence_ref));
              (s.length > 0 && (a[e] = s), l.length > 0 && (o[e] = l));
            } else a[e] = t;
          }),
          this.syncDiff(i, { joins: a, leaves: o }, r, n)
        );
      }
      static syncDiff(e, t, r, n) {
        let { joins: i, leaves: s } = {
          joins: this.transformState(t.joins),
          leaves: this.transformState(t.leaves),
        };
        return (
          r || (r = () => {}),
          n || (n = () => {}),
          this.map(i, (t, n) => {
            var i;
            let s = null != (i = e[t]) ? i : [];
            if (((e[t] = this.cloneDeep(n)), s.length > 0)) {
              let r = e[t].map((e) => e.presence_ref),
                n = s.filter((e) => 0 > r.indexOf(e.presence_ref));
              e[t].unshift(...n);
            }
            r(t, s, n);
          }),
          this.map(s, (t, r) => {
            let i = e[t];
            if (!i) return;
            let s = r.map((e) => e.presence_ref);
            ((i = i.filter((e) => 0 > s.indexOf(e.presence_ref))),
              (e[t] = i),
              n(t, i, r),
              0 === i.length && delete e[t]);
          }),
          e
        );
      }
      static map(e, t) {
        return Object.getOwnPropertyNames(e).map((r) => t(r, e[r]));
      }
      static transformState(e) {
        return Object.getOwnPropertyNames((e = this.cloneDeep(e))).reduce(
          (t, r) => {
            let n = e[r];
            return (
              'metas' in n
                ? (t[r] = n.metas.map(
                    (e) => (
                      (e.presence_ref = e.phx_ref),
                      delete e.phx_ref,
                      delete e.phx_ref_prev,
                      e
                    )
                  ))
                : (t[r] = n),
              t
            );
          },
          {}
        );
      }
      static cloneDeep(e) {
        return JSON.parse(JSON.stringify(e));
      }
      onJoin(e) {
        this.caller.onJoin = e;
      }
      onLeave(e) {
        this.caller.onLeave = e;
      }
      onSync(e) {
        this.caller.onSync = e;
      }
      inPendingSyncState() {
        return !this.joinRef || this.joinRef !== this.channel._joinRef();
      }
    }
    (((Q = eu || (eu = {})).ALL = '*'),
      (Q.INSERT = 'INSERT'),
      (Q.UPDATE = 'UPDATE'),
      (Q.DELETE = 'DELETE'),
      ((Z = ec || (ec = {})).BROADCAST = 'broadcast'),
      (Z.PRESENCE = 'presence'),
      (Z.POSTGRES_CHANGES = 'postgres_changes'),
      (Z.SYSTEM = 'system'),
      ((ee = eh || (eh = {})).SUBSCRIBED = 'SUBSCRIBED'),
      (ee.TIMED_OUT = 'TIMED_OUT'),
      (ee.CLOSED = 'CLOSED'),
      (ee.CHANNEL_ERROR = 'CHANNEL_ERROR'));
    class rs {
      constructor(e, t = { config: {} }, r) {
        var n, i;
        if (
          ((this.topic = e),
          (this.params = t),
          (this.socket = r),
          (this.bindings = {}),
          (this.state = en.closed),
          (this.joinedOnce = !1),
          (this.pushBuffer = []),
          (this.subTopic = e.replace(/^realtime:/i, '')),
          (this.params.config = Object.assign(
            {
              broadcast: { ack: !1, self: !1 },
              presence: { key: '', enabled: !1 },
              private: !1,
            },
            t.config
          )),
          (this.timeout = this.socket.timeout),
          (this.joinPush = new rn(this, ei.join, this.params, this.timeout)),
          (this.rejoinTimer = new t2(
            () => this._rejoinUntilConnected(),
            this.socket.reconnectAfterMs
          )),
          this.joinPush.receive('ok', () => {
            ((this.state = en.joined),
              this.rejoinTimer.reset(),
              this.pushBuffer.forEach((e) => e.send()),
              (this.pushBuffer = []));
          }),
          this._onClose(() => {
            (this.rejoinTimer.reset(),
              this.socket.log(
                'channel',
                `close ${this.topic} ${this._joinRef()}`
              ),
              (this.state = en.closed),
              this.socket._remove(this));
          }),
          this._onError((e) => {
            this._isLeaving() ||
              this._isClosed() ||
              (this.socket.log('channel', `error ${this.topic}`, e),
              (this.state = en.errored),
              this.rejoinTimer.scheduleTimeout());
          }),
          this.joinPush.receive('timeout', () => {
            this._isJoining() &&
              (this.socket.log(
                'channel',
                `timeout ${this.topic}`,
                this.joinPush.timeout
              ),
              (this.state = en.errored),
              this.rejoinTimer.scheduleTimeout());
          }),
          this.joinPush.receive('error', (e) => {
            this._isLeaving() ||
              this._isClosed() ||
              (this.socket.log('channel', `error ${this.topic}`, e),
              (this.state = en.errored),
              this.rejoinTimer.scheduleTimeout());
          }),
          this._on(ei.reply, {}, (e, t) => {
            this._trigger(this._replyEventName(t), e);
          }),
          (this.presence = new ri(this)),
          (this.broadcastEndpointURL = rr(this.socket.endPoint)),
          (this.private = this.params.config.private || !1),
          !this.private &&
            (null ==
            (i = null == (n = this.params.config) ? void 0 : n.broadcast)
              ? void 0
              : i.replay))
        )
          throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
      }
      subscribe(e, t = this.timeout) {
        var r, n, i;
        if (
          (this.socket.isConnected() || this.socket.connect(),
          this.state == en.closed)
        ) {
          let {
              config: { broadcast: s, presence: a, private: o },
            } = this.params,
            l =
              null !=
              (n =
                null == (r = this.bindings.postgres_changes)
                  ? void 0
                  : r.map((e) => e.filter))
                ? n
                : [],
            u =
              (!!this.bindings[ec.PRESENCE] &&
                this.bindings[ec.PRESENCE].length > 0) ||
              (null == (i = this.params.config.presence)
                ? void 0
                : i.enabled) === !0,
            c = {},
            h = {
              broadcast: s,
              presence: Object.assign(Object.assign({}, a), { enabled: u }),
              postgres_changes: l,
              private: o,
            };
          (this.socket.accessTokenValue &&
            (c.access_token = this.socket.accessTokenValue),
            this._onError((t) => (null == e ? void 0 : e(eh.CHANNEL_ERROR, t))),
            this._onClose(() => (null == e ? void 0 : e(eh.CLOSED))),
            this.updateJoinPayload(Object.assign({ config: h }, c)),
            (this.joinedOnce = !0),
            this._rejoin(t),
            this.joinPush
              .receive('ok', async ({ postgres_changes: t }) => {
                var r;
                if (
                  (this.socket._isManualToken() || this.socket.setAuth(),
                  void 0 === t)
                ) {
                  null == e || e(eh.SUBSCRIBED);
                  return;
                }
                {
                  let n = this.bindings.postgres_changes,
                    i = null != (r = null == n ? void 0 : n.length) ? r : 0,
                    s = [];
                  for (let r = 0; r < i; r++) {
                    let i = n[r],
                      {
                        filter: { event: a, schema: o, table: l, filter: u },
                      } = i,
                      c = t && t[r];
                    if (
                      c &&
                      c.event === a &&
                      rs.isFilterValueEqual(c.schema, o) &&
                      rs.isFilterValueEqual(c.table, l) &&
                      rs.isFilterValueEqual(c.filter, u)
                    )
                      s.push(Object.assign(Object.assign({}, i), { id: c.id }));
                    else {
                      (this.unsubscribe(),
                        (this.state = en.errored),
                        null == e ||
                          e(
                            eh.CHANNEL_ERROR,
                            Error(
                              'mismatch between server and client bindings for postgres changes'
                            )
                          ));
                      return;
                    }
                  }
                  ((this.bindings.postgres_changes = s), e && e(eh.SUBSCRIBED));
                  return;
                }
              })
              .receive('error', (t) => {
                ((this.state = en.errored),
                  null == e ||
                    e(
                      eh.CHANNEL_ERROR,
                      Error(
                        JSON.stringify(Object.values(t).join(', ') || 'error')
                      )
                    ));
              })
              .receive('timeout', () => {
                null == e || e(eh.TIMED_OUT);
              }));
        }
        return this;
      }
      presenceState() {
        return this.presence.state;
      }
      async track(e, t = {}) {
        return await this.send(
          { type: 'presence', event: 'track', payload: e },
          t.timeout || this.timeout
        );
      }
      async untrack(e = {}) {
        return await this.send({ type: 'presence', event: 'untrack' }, e);
      }
      on(e, t, r) {
        return (
          this.state === en.joined &&
            e === ec.PRESENCE &&
            (this.socket.log(
              'channel',
              `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`
            ),
            this.unsubscribe().then(async () => await this.subscribe())),
          this._on(e, t, r)
        );
      }
      async httpSend(e, t, r = {}) {
        var n;
        if (null == t)
          return Promise.reject('Payload is required for httpSend()');
        let i = {
          apikey: this.socket.apiKey ? this.socket.apiKey : '',
          'Content-Type': 'application/json',
        };
        this.socket.accessTokenValue &&
          (i.Authorization = `Bearer ${this.socket.accessTokenValue}`);
        let s = {
            method: 'POST',
            headers: i,
            body: JSON.stringify({
              messages: [
                {
                  topic: this.subTopic,
                  event: e,
                  payload: t,
                  private: this.private,
                },
              ],
            }),
          },
          a = await this._fetchWithTimeout(
            this.broadcastEndpointURL,
            s,
            null != (n = r.timeout) ? n : this.timeout
          );
        if (202 === a.status) return { success: !0 };
        let o = a.statusText;
        try {
          let e = await a.json();
          o = e.error || e.message || o;
        } catch (e) {}
        return Promise.reject(Error(o));
      }
      async send(e, t = {}) {
        var r, n;
        if (this._canPush() || 'broadcast' !== e.type)
          return new Promise((r) => {
            var n, i, s;
            let a = this._push(e.type, e, t.timeout || this.timeout);
            ('broadcast' !== e.type ||
              (null ==
              (s =
                null == (i = null == (n = this.params) ? void 0 : n.config)
                  ? void 0
                  : i.broadcast)
                ? void 0
                : s.ack) ||
              r('ok'),
              a.receive('ok', () => r('ok')),
              a.receive('error', () => r('error')),
              a.receive('timeout', () => r('timed out')));
          });
        {
          console.warn(
            'Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.'
          );
          let { event: i, payload: s } = e,
            a = {
              apikey: this.socket.apiKey ? this.socket.apiKey : '',
              'Content-Type': 'application/json',
            };
          this.socket.accessTokenValue &&
            (a.Authorization = `Bearer ${this.socket.accessTokenValue}`);
          let o = {
            method: 'POST',
            headers: a,
            body: JSON.stringify({
              messages: [
                {
                  topic: this.subTopic,
                  event: i,
                  payload: s,
                  private: this.private,
                },
              ],
            }),
          };
          try {
            let e = await this._fetchWithTimeout(
              this.broadcastEndpointURL,
              o,
              null != (r = t.timeout) ? r : this.timeout
            );
            return (
              await (null == (n = e.body) ? void 0 : n.cancel()),
              e.ok ? 'ok' : 'error'
            );
          } catch (e) {
            if ('AbortError' === e.name) return 'timed out';
            return 'error';
          }
        }
      }
      updateJoinPayload(e) {
        this.joinPush.updatePayload(e);
      }
      unsubscribe(e = this.timeout) {
        this.state = en.leaving;
        let t = () => {
          (this.socket.log('channel', `leave ${this.topic}`),
            this._trigger(ei.close, 'leave', this._joinRef()));
        };
        this.joinPush.destroy();
        let r = null;
        return new Promise((n) => {
          ((r = new rn(this, ei.leave, {}, e))
            .receive('ok', () => {
              (t(), n('ok'));
            })
            .receive('timeout', () => {
              (t(), n('timed out'));
            })
            .receive('error', () => {
              n('error');
            }),
            r.send(),
            this._canPush() || r.trigger('ok', {}));
        }).finally(() => {
          null == r || r.destroy();
        });
      }
      teardown() {
        (this.pushBuffer.forEach((e) => e.destroy()),
          (this.pushBuffer = []),
          this.rejoinTimer.reset(),
          this.joinPush.destroy(),
          (this.state = en.closed),
          (this.bindings = {}));
      }
      async _fetchWithTimeout(e, t, r) {
        let n = new AbortController(),
          i = setTimeout(() => n.abort(), r),
          s = await this.socket.fetch(
            e,
            Object.assign(Object.assign({}, t), { signal: n.signal })
          );
        return (clearTimeout(i), s);
      }
      _push(e, t, r = this.timeout) {
        if (!this.joinedOnce)
          throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
        let n = new rn(this, e, t, r);
        return (this._canPush() ? n.send() : this._addToPushBuffer(n), n);
      }
      _addToPushBuffer(e) {
        if (
          (e.startTimeout(),
          this.pushBuffer.push(e),
          this.pushBuffer.length > 100)
        ) {
          let e = this.pushBuffer.shift();
          e &&
            (e.destroy(),
            this.socket.log(
              'channel',
              `discarded push due to buffer overflow: ${e.event}`,
              e.payload
            ));
        }
      }
      _onMessage(e, t, r) {
        return t;
      }
      _isMember(e) {
        return this.topic === e;
      }
      _joinRef() {
        return this.joinPush.ref;
      }
      _trigger(e, t, r) {
        var n, i;
        let s = e.toLocaleLowerCase(),
          { close: a, error: o, leave: l, join: u } = ei;
        if (r && [a, o, l, u].indexOf(s) >= 0 && r !== this._joinRef()) return;
        let c = this._onMessage(s, t, r);
        if (t && !c)
          throw 'channel onMessage callbacks must return the payload, modified or unmodified';
        ['insert', 'update', 'delete'].includes(s)
          ? null == (n = this.bindings.postgres_changes) ||
            n
              .filter((e) => {
                var t, r, n;
                return (
                  (null == (t = e.filter) ? void 0 : t.event) === '*' ||
                  (null == (n = null == (r = e.filter) ? void 0 : r.event)
                    ? void 0
                    : n.toLocaleLowerCase()) === s
                );
              })
              .map((e) => e.callback(c, r))
          : null == (i = this.bindings[s]) ||
            i
              .filter((e) => {
                var r, n, i, a, o, l, u, c;
                if (!['broadcast', 'presence', 'postgres_changes'].includes(s))
                  return e.type.toLocaleLowerCase() === s;
                if ('id' in e) {
                  let s = e.id,
                    l = null == (r = e.filter) ? void 0 : r.event;
                  return (
                    s &&
                    (null == (n = t.ids) ? void 0 : n.includes(s)) &&
                    ('*' === l ||
                      (null == l ? void 0 : l.toLocaleLowerCase()) ===
                        (null == (i = t.data)
                          ? void 0
                          : i.type.toLocaleLowerCase())) &&
                    (!(null == (a = e.filter) ? void 0 : a.table) ||
                      e.filter.table ===
                        (null == (o = t.data) ? void 0 : o.table))
                  );
                }
                {
                  let r =
                    null ==
                    (u =
                      null == (l = null == e ? void 0 : e.filter)
                        ? void 0
                        : l.event)
                      ? void 0
                      : u.toLocaleLowerCase();
                  return (
                    '*' === r ||
                    r ===
                      (null == (c = null == t ? void 0 : t.event)
                        ? void 0
                        : c.toLocaleLowerCase())
                  );
                }
              })
              .map((e) => {
                if ('object' == typeof c && 'ids' in c) {
                  let e = c.data,
                    {
                      schema: t,
                      table: r,
                      commit_timestamp: n,
                      type: i,
                      errors: s,
                    } = e;
                  c = Object.assign(
                    Object.assign(
                      {},
                      {
                        schema: t,
                        table: r,
                        commit_timestamp: n,
                        eventType: i,
                        new: {},
                        old: {},
                        errors: s,
                      }
                    ),
                    this._getPayloadRecords(e)
                  );
                }
                e.callback(c, r);
              });
      }
      _isClosed() {
        return this.state === en.closed;
      }
      _isJoined() {
        return this.state === en.joined;
      }
      _isJoining() {
        return this.state === en.joining;
      }
      _isLeaving() {
        return this.state === en.leaving;
      }
      _replyEventName(e) {
        return `chan_reply_${e}`;
      }
      _on(e, t, r) {
        let n = e.toLocaleLowerCase(),
          i = { type: n, filter: t, callback: r };
        return (
          this.bindings[n]
            ? this.bindings[n].push(i)
            : (this.bindings[n] = [i]),
          this
        );
      }
      _off(e, t) {
        let r = e.toLocaleLowerCase();
        return (
          this.bindings[r] &&
            (this.bindings[r] = this.bindings[r].filter((e) => {
              var n;
              return !(
                (null == (n = e.type) ? void 0 : n.toLocaleLowerCase()) === r &&
                rs.isEqual(e.filter, t)
              );
            })),
          this
        );
      }
      static isEqual(e, t) {
        if (Object.keys(e).length !== Object.keys(t).length) return !1;
        for (let r in e) if (e[r] !== t[r]) return !1;
        return !0;
      }
      static isFilterValueEqual(e, t) {
        return (null != e ? e : void 0) === (null != t ? t : void 0);
      }
      _rejoinUntilConnected() {
        (this.rejoinTimer.scheduleTimeout(),
          this.socket.isConnected() && this._rejoin());
      }
      _onClose(e) {
        this._on(ei.close, {}, e);
      }
      _onError(e) {
        this._on(ei.error, {}, (t) => e(t));
      }
      _canPush() {
        return this.socket.isConnected() && this._isJoined();
      }
      _rejoin(e = this.timeout) {
        this._isLeaving() ||
          (this.socket._leaveOpenTopic(this.topic),
          (this.state = en.joining),
          this.joinPush.resend(e));
      }
      _getPayloadRecords(e) {
        let t = { new: {}, old: {} };
        return (
          ('INSERT' === e.type || 'UPDATE' === e.type) &&
            (t.new = t3(e.columns, e.record)),
          ('UPDATE' === e.type || 'DELETE' === e.type) &&
            (t.old = t3(e.columns, e.old_record)),
          t
        );
      }
    }
    let ra = () => {},
      ro = [1e3, 2e3, 5e3, 1e4],
      rl = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
    class ru {
      constructor(e, t) {
        var r;
        if (
          ((this.accessTokenValue = null),
          (this.apiKey = null),
          (this._manuallySetToken = !1),
          (this.channels = []),
          (this.endPoint = ''),
          (this.httpEndpoint = ''),
          (this.headers = {}),
          (this.params = {}),
          (this.timeout = 1e4),
          (this.transport = null),
          (this.heartbeatIntervalMs = 25e3),
          (this.heartbeatTimer = void 0),
          (this.pendingHeartbeatRef = null),
          (this.heartbeatCallback = ra),
          (this.ref = 0),
          (this.reconnectTimer = null),
          (this.vsn = t0),
          (this.logger = ra),
          (this.conn = null),
          (this.sendBuffer = []),
          (this.serializer = new t1()),
          (this.stateChangeCallbacks = {
            open: [],
            close: [],
            error: [],
            message: [],
          }),
          (this.accessToken = null),
          (this._connectionState = 'disconnected'),
          (this._wasManualDisconnect = !1),
          (this._authPromise = null),
          (this._heartbeatSentAt = null),
          (this._resolveFetch = (e) =>
            e ? (...t) => e(...t) : (...e) => fetch(...e)),
          !(null == (r = null == t ? void 0 : t.params) ? void 0 : r.apikey))
        )
          throw Error('API key is required to connect to Realtime');
        ((this.apiKey = t.params.apikey),
          (this.endPoint = `${e}/${es.websocket}`),
          (this.httpEndpoint = rr(e)),
          this._initializeOptions(t),
          this._setupReconnectionTimer(),
          (this.fetch = this._resolveFetch(null == t ? void 0 : t.fetch)));
      }
      connect() {
        if (
          !(
            this.isConnecting() ||
            this.isDisconnecting() ||
            (null !== this.conn && this.isConnected())
          )
        ) {
          if (
            (this._setConnectionState('connecting'),
            this.accessToken &&
              !this._authPromise &&
              this._setAuthSafely('connect'),
            this.transport)
          )
            this.conn = new this.transport(this.endpointURL());
          else
            try {
              this.conn = tZ.createWebSocket(this.endpointURL());
            } catch (t) {
              this._setConnectionState('disconnected');
              let e = t.message;
              if (e.includes('Node.js'))
                throw Error(`${e}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  ppnpm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`);
              throw Error(`WebSocket not available: ${e}`);
            }
          this._setupConnectionHandlers();
        }
      }
      endpointURL() {
        return this._appendParams(
          this.endPoint,
          Object.assign({}, this.params, { vsn: this.vsn })
        );
      }
      disconnect(e, t) {
        if (!this.isDisconnecting())
          if ((this._setConnectionState('disconnecting', !0), this.conn)) {
            let r = setTimeout(() => {
              this._setConnectionState('disconnected');
            }, 100);
            ((this.conn.onclose = () => {
              (clearTimeout(r), this._setConnectionState('disconnected'));
            }),
              'function' == typeof this.conn.close &&
                (e
                  ? this.conn.close(e, null != t ? t : '')
                  : this.conn.close()),
              this._teardownConnection());
          } else this._setConnectionState('disconnected');
      }
      getChannels() {
        return this.channels;
      }
      async removeChannel(e) {
        let t = await e.unsubscribe();
        return (0 === this.channels.length && this.disconnect(), t);
      }
      async removeAllChannels() {
        let e = await Promise.all(this.channels.map((e) => e.unsubscribe()));
        return ((this.channels = []), this.disconnect(), e);
      }
      log(e, t, r) {
        this.logger(e, t, r);
      }
      connectionState() {
        switch (this.conn && this.conn.readyState) {
          case er.connecting:
            return ea.Connecting;
          case er.open:
            return ea.Open;
          case er.closing:
            return ea.Closing;
          default:
            return ea.Closed;
        }
      }
      isConnected() {
        return this.connectionState() === ea.Open;
      }
      isConnecting() {
        return 'connecting' === this._connectionState;
      }
      isDisconnecting() {
        return 'disconnecting' === this._connectionState;
      }
      channel(e, t = { config: {} }) {
        let r = `realtime:${e}`,
          n = this.getChannels().find((e) => e.topic === r);
        if (n) return n;
        {
          let r = new rs(`realtime:${e}`, t, this);
          return (this.channels.push(r), r);
        }
      }
      push(e) {
        let { topic: t, event: r, payload: n, ref: i } = e,
          s = () => {
            this.encode(e, (e) => {
              var t;
              null == (t = this.conn) || t.send(e);
            });
          };
        (this.log('push', `${t} ${r} (${i})`, n),
          this.isConnected() ? s() : this.sendBuffer.push(s));
      }
      async setAuth(e = null) {
        this._authPromise = this._performAuth(e);
        try {
          await this._authPromise;
        } finally {
          this._authPromise = null;
        }
      }
      _isManualToken() {
        return this._manuallySetToken;
      }
      async sendHeartbeat() {
        var e;
        if (!this.isConnected()) {
          try {
            this.heartbeatCallback('disconnected');
          } catch (e) {
            this.log('error', 'error in heartbeat callback', e);
          }
          return;
        }
        if (this.pendingHeartbeatRef) {
          ((this.pendingHeartbeatRef = null),
            (this._heartbeatSentAt = null),
            this.log(
              'transport',
              'heartbeat timeout. Attempting to re-establish connection'
            ));
          try {
            this.heartbeatCallback('timeout');
          } catch (e) {
            this.log('error', 'error in heartbeat callback', e);
          }
          ((this._wasManualDisconnect = !1),
            null == (e = this.conn) || e.close(1e3, 'heartbeat timeout'),
            setTimeout(() => {
              var e;
              this.isConnected() ||
                null == (e = this.reconnectTimer) ||
                e.scheduleTimeout();
            }, 100));
          return;
        }
        ((this._heartbeatSentAt = Date.now()),
          (this.pendingHeartbeatRef = this._makeRef()),
          this.push({
            topic: 'phoenix',
            event: 'heartbeat',
            payload: {},
            ref: this.pendingHeartbeatRef,
          }));
        try {
          this.heartbeatCallback('sent');
        } catch (e) {
          this.log('error', 'error in heartbeat callback', e);
        }
        this._setAuthSafely('heartbeat');
      }
      onHeartbeat(e) {
        this.heartbeatCallback = e;
      }
      flushSendBuffer() {
        this.isConnected() &&
          this.sendBuffer.length > 0 &&
          (this.sendBuffer.forEach((e) => e()), (this.sendBuffer = []));
      }
      _makeRef() {
        let e = this.ref + 1;
        return (
          e === this.ref ? (this.ref = 0) : (this.ref = e),
          this.ref.toString()
        );
      }
      _leaveOpenTopic(e) {
        let t = this.channels.find(
          (t) => t.topic === e && (t._isJoined() || t._isJoining())
        );
        t &&
          (this.log('transport', `leaving duplicate topic "${e}"`),
          t.unsubscribe());
      }
      _remove(e) {
        this.channels = this.channels.filter((t) => t.topic !== e.topic);
      }
      _onConnMessage(e) {
        this.decode(e.data, (e) => {
          if (
            'phoenix' === e.topic &&
            'phx_reply' === e.event &&
            e.ref &&
            e.ref === this.pendingHeartbeatRef
          ) {
            let t = this._heartbeatSentAt
              ? Date.now() - this._heartbeatSentAt
              : void 0;
            try {
              this.heartbeatCallback(
                'ok' === e.payload.status ? 'ok' : 'error',
                t
              );
            } catch (e) {
              this.log('error', 'error in heartbeat callback', e);
            }
            ((this._heartbeatSentAt = null), (this.pendingHeartbeatRef = null));
          }
          let { topic: t, event: r, payload: n, ref: i } = e,
            s = i ? `(${i})` : '',
            a = n.status || '';
          (this.log('receive', `${a} ${t} ${r} ${s}`.trim(), n),
            this.channels
              .filter((e) => e._isMember(t))
              .forEach((e) => e._trigger(r, n, i)),
            this._triggerStateCallbacks('message', e));
        });
      }
      _clearTimer(e) {
        var t;
        'heartbeat' === e && this.heartbeatTimer
          ? (clearInterval(this.heartbeatTimer), (this.heartbeatTimer = void 0))
          : 'reconnect' === e &&
            (null == (t = this.reconnectTimer) || t.reset());
      }
      _clearAllTimers() {
        (this._clearTimer('heartbeat'), this._clearTimer('reconnect'));
      }
      _setupConnectionHandlers() {
        this.conn &&
          ('binaryType' in this.conn && (this.conn.binaryType = 'arraybuffer'),
          (this.conn.onopen = () => this._onConnOpen()),
          (this.conn.onerror = (e) => this._onConnError(e)),
          (this.conn.onmessage = (e) => this._onConnMessage(e)),
          (this.conn.onclose = (e) => this._onConnClose(e)),
          this.conn.readyState === er.open && this._onConnOpen());
      }
      _teardownConnection() {
        if (this.conn) {
          if (
            this.conn.readyState === er.open ||
            this.conn.readyState === er.connecting
          )
            try {
              this.conn.close();
            } catch (e) {
              this.log('error', 'Error closing connection', e);
            }
          ((this.conn.onopen = null),
            (this.conn.onerror = null),
            (this.conn.onmessage = null),
            (this.conn.onclose = null),
            (this.conn = null));
        }
        (this._clearAllTimers(),
          this._terminateWorker(),
          this.channels.forEach((e) => e.teardown()));
      }
      _onConnOpen() {
        (this._setConnectionState('connected'),
          this.log('transport', `connected to ${this.endpointURL()}`),
          (
            this._authPromise ||
            (this.accessToken && !this.accessTokenValue
              ? this.setAuth()
              : Promise.resolve())
          )
            .then(() => {
              this.flushSendBuffer();
            })
            .catch((e) => {
              (this.log('error', 'error waiting for auth on connect', e),
                this.flushSendBuffer());
            }),
          this._clearTimer('reconnect'),
          this.worker
            ? this.workerRef || this._startWorkerHeartbeat()
            : this._startHeartbeat(),
          this._triggerStateCallbacks('open'));
      }
      _startHeartbeat() {
        (this.heartbeatTimer && clearInterval(this.heartbeatTimer),
          (this.heartbeatTimer = setInterval(
            () => this.sendHeartbeat(),
            this.heartbeatIntervalMs
          )));
      }
      _startWorkerHeartbeat() {
        this.workerUrl
          ? this.log('worker', `starting worker for from ${this.workerUrl}`)
          : this.log('worker', 'starting default worker');
        let e = this._workerObjectUrl(this.workerUrl);
        ((this.workerRef = new Worker(e)),
          (this.workerRef.onerror = (e) => {
            (this.log('worker', 'worker error', e.message),
              this._terminateWorker());
          }),
          (this.workerRef.onmessage = (e) => {
            'keepAlive' === e.data.event && this.sendHeartbeat();
          }),
          this.workerRef.postMessage({
            event: 'start',
            interval: this.heartbeatIntervalMs,
          }));
      }
      _terminateWorker() {
        this.workerRef &&
          (this.log('worker', 'terminating worker'),
          this.workerRef.terminate(),
          (this.workerRef = void 0));
      }
      _onConnClose(e) {
        var t;
        (this._setConnectionState('disconnected'),
          this.log('transport', 'close', e),
          this._triggerChanError(),
          this._clearTimer('heartbeat'),
          this._wasManualDisconnect ||
            null == (t = this.reconnectTimer) ||
            t.scheduleTimeout(),
          this._triggerStateCallbacks('close', e));
      }
      _onConnError(e) {
        (this._setConnectionState('disconnected'),
          this.log('transport', `${e}`),
          this._triggerChanError(),
          this._triggerStateCallbacks('error', e));
      }
      _triggerChanError() {
        this.channels.forEach((e) => e._trigger(ei.error));
      }
      _appendParams(e, t) {
        if (0 === Object.keys(t).length) return e;
        let r = e.match(/\?/) ? '&' : '?',
          n = new URLSearchParams(t);
        return `${e}${r}${n}`;
      }
      _workerObjectUrl(e) {
        let t;
        if (e) t = e;
        else {
          let e = new Blob([rl], { type: 'application/javascript' });
          t = URL.createObjectURL(e);
        }
        return t;
      }
      _setConnectionState(e, t = !1) {
        ((this._connectionState = e),
          'connecting' === e
            ? (this._wasManualDisconnect = !1)
            : 'disconnecting' === e && (this._wasManualDisconnect = t));
      }
      async _performAuth(e = null) {
        let t,
          r = !1;
        if (e) ((t = e), (r = !0));
        else if (this.accessToken)
          try {
            t = await this.accessToken();
          } catch (e) {
            (this.log('error', 'Error fetching access token from callback', e),
              (t = this.accessTokenValue));
          }
        else t = this.accessTokenValue;
        (r
          ? (this._manuallySetToken = !0)
          : this.accessToken && (this._manuallySetToken = !1),
          this.accessTokenValue != t &&
            ((this.accessTokenValue = t),
            this.channels.forEach((e) => {
              let r = { access_token: t, version: 'realtime-js/2.91.1' };
              (t && e.updateJoinPayload(r),
                e.joinedOnce &&
                  e._isJoined() &&
                  e._push(ei.access_token, { access_token: t }));
            })));
      }
      async _waitForAuthIfNeeded() {
        this._authPromise && (await this._authPromise);
      }
      _setAuthSafely(e = 'general') {
        this._isManualToken() ||
          this.setAuth().catch((t) => {
            this.log('error', `Error setting auth in ${e}`, t);
          });
      }
      _triggerStateCallbacks(e, t) {
        try {
          this.stateChangeCallbacks[e].forEach((r) => {
            try {
              r(t);
            } catch (t) {
              this.log('error', `error in ${e} callback`, t);
            }
          });
        } catch (t) {
          this.log('error', `error triggering ${e} callbacks`, t);
        }
      }
      _setupReconnectionTimer() {
        this.reconnectTimer = new t2(async () => {
          setTimeout(async () => {
            (await this._waitForAuthIfNeeded(),
              this.isConnected() || this.connect());
          }, 10);
        }, this.reconnectAfterMs);
      }
      _initializeOptions(e) {
        var t, r, n, i, s, a, o, l, u, c, h, d;
        switch (
          ((this.transport =
            null != (t = null == e ? void 0 : e.transport) ? t : null),
          (this.timeout =
            null != (r = null == e ? void 0 : e.timeout) ? r : 1e4),
          (this.heartbeatIntervalMs =
            null != (n = null == e ? void 0 : e.heartbeatIntervalMs)
              ? n
              : 25e3),
          (this.worker = null != (i = null == e ? void 0 : e.worker) && i),
          (this.accessToken =
            null != (s = null == e ? void 0 : e.accessToken) ? s : null),
          (this.heartbeatCallback =
            null != (a = null == e ? void 0 : e.heartbeatCallback) ? a : ra),
          (this.vsn = null != (o = null == e ? void 0 : e.vsn) ? o : t0),
          (null == e ? void 0 : e.params) && (this.params = e.params),
          (null == e ? void 0 : e.logger) && (this.logger = e.logger),
          ((null == e ? void 0 : e.logLevel) ||
            (null == e ? void 0 : e.log_level)) &&
            ((this.logLevel = e.logLevel || e.log_level),
            (this.params = Object.assign(Object.assign({}, this.params), {
              log_level: this.logLevel,
            }))),
          (this.reconnectAfterMs =
            null != (l = null == e ? void 0 : e.reconnectAfterMs)
              ? l
              : (e) => ro[e - 1] || 1e4),
          this.vsn)
        ) {
          case '1.0.0':
            ((this.encode =
              null != (u = null == e ? void 0 : e.encode)
                ? u
                : (e, t) => t(JSON.stringify(e))),
              (this.decode =
                null != (c = null == e ? void 0 : e.decode)
                  ? c
                  : (e, t) => t(JSON.parse(e))));
            break;
          case t0:
            ((this.encode =
              null != (h = null == e ? void 0 : e.encode)
                ? h
                : this.serializer.encode.bind(this.serializer)),
              (this.decode =
                null != (d = null == e ? void 0 : e.decode)
                  ? d
                  : this.serializer.decode.bind(this.serializer)));
            break;
          default:
            throw Error(`Unsupported serializer version: ${this.vsn}`);
        }
        this.worker && (this.workerUrl = null == e ? void 0 : e.workerUrl);
      }
    }
    var rc = class extends Error {
      constructor(e, t) {
        (super(e),
          (this.name = 'IcebergError'),
          (this.status = t.status),
          (this.icebergType = t.icebergType),
          (this.icebergCode = t.icebergCode),
          (this.details = t.details),
          (this.isCommitStateUnknown =
            'CommitStateUnknownException' === t.icebergType ||
            ([500, 502, 504].includes(t.status) &&
              t.icebergType?.includes('CommitState') === !0)));
      }
      isNotFound() {
        return 404 === this.status;
      }
      isConflict() {
        return 409 === this.status;
      }
      isAuthenticationTimeout() {
        return 419 === this.status;
      }
    };
    async function rh(e) {
      return e && 'none' !== e.type
        ? 'bearer' === e.type
          ? { Authorization: `Bearer ${e.token}` }
          : 'header' === e.type
            ? { [e.name]: e.value }
            : 'custom' === e.type
              ? await e.getHeaders()
              : {}
        : {};
    }
    function rd(e) {
      return e.join('\x1f');
    }
    var rp = class {
      constructor(e, t = '') {
        ((this.client = e), (this.prefix = t));
      }
      async listNamespaces(e) {
        let t = e ? { parent: rd(e.namespace) } : void 0;
        return (
          await this.client.request({
            method: 'GET',
            path: `${this.prefix}/namespaces`,
            query: t,
          })
        ).data.namespaces.map((e) => ({ namespace: e }));
      }
      async createNamespace(e, t) {
        let r = { namespace: e.namespace, properties: t?.properties };
        return (
          await this.client.request({
            method: 'POST',
            path: `${this.prefix}/namespaces`,
            body: r,
          })
        ).data;
      }
      async dropNamespace(e) {
        await this.client.request({
          method: 'DELETE',
          path: `${this.prefix}/namespaces/${rd(e.namespace)}`,
        });
      }
      async loadNamespaceMetadata(e) {
        return {
          properties: (
            await this.client.request({
              method: 'GET',
              path: `${this.prefix}/namespaces/${rd(e.namespace)}`,
            })
          ).data.properties,
        };
      }
      async namespaceExists(e) {
        try {
          return (
            await this.client.request({
              method: 'HEAD',
              path: `${this.prefix}/namespaces/${rd(e.namespace)}`,
            }),
            !0
          );
        } catch (e) {
          if (e instanceof rc && 404 === e.status) return !1;
          throw e;
        }
      }
      async createNamespaceIfNotExists(e, t) {
        try {
          return await this.createNamespace(e, t);
        } catch (e) {
          if (e instanceof rc && 409 === e.status) return;
          throw e;
        }
      }
    };
    function rf(e) {
      return e.join('\x1f');
    }
    var rg = class {
        constructor(e, t = '', r) {
          ((this.client = e), (this.prefix = t), (this.accessDelegation = r));
        }
        async listTables(e) {
          return (
            await this.client.request({
              method: 'GET',
              path: `${this.prefix}/namespaces/${rf(e.namespace)}/tables`,
            })
          ).data.identifiers;
        }
        async createTable(e, t) {
          let r = {};
          return (
            this.accessDelegation &&
              (r['X-Iceberg-Access-Delegation'] = this.accessDelegation),
            (
              await this.client.request({
                method: 'POST',
                path: `${this.prefix}/namespaces/${rf(e.namespace)}/tables`,
                body: t,
                headers: r,
              })
            ).data.metadata
          );
        }
        async updateTable(e, t) {
          let r = await this.client.request({
            method: 'POST',
            path: `${this.prefix}/namespaces/${rf(e.namespace)}/tables/${e.name}`,
            body: t,
          });
          return {
            'metadata-location': r.data['metadata-location'],
            metadata: r.data.metadata,
          };
        }
        async dropTable(e, t) {
          await this.client.request({
            method: 'DELETE',
            path: `${this.prefix}/namespaces/${rf(e.namespace)}/tables/${e.name}`,
            query: { purgeRequested: String(t?.purge ?? !1) },
          });
        }
        async loadTable(e) {
          let t = {};
          return (
            this.accessDelegation &&
              (t['X-Iceberg-Access-Delegation'] = this.accessDelegation),
            (
              await this.client.request({
                method: 'GET',
                path: `${this.prefix}/namespaces/${rf(e.namespace)}/tables/${e.name}`,
                headers: t,
              })
            ).data.metadata
          );
        }
        async tableExists(e) {
          let t = {};
          this.accessDelegation &&
            (t['X-Iceberg-Access-Delegation'] = this.accessDelegation);
          try {
            return (
              await this.client.request({
                method: 'HEAD',
                path: `${this.prefix}/namespaces/${rf(e.namespace)}/tables/${e.name}`,
                headers: t,
              }),
              !0
            );
          } catch (e) {
            if (e instanceof rc && 404 === e.status) return !1;
            throw e;
          }
        }
        async createTableIfNotExists(e, t) {
          try {
            return await this.createTable(e, t);
          } catch (r) {
            if (r instanceof rc && 409 === r.status)
              return await this.loadTable({
                namespace: e.namespace,
                name: t.name,
              });
            throw r;
          }
        }
      },
      rm = class {
        constructor(e) {
          let t = 'v1';
          e.catalogName && (t += `/${e.catalogName}`);
          const r = e.baseUrl.endsWith('/') ? e.baseUrl : `${e.baseUrl}/`;
          ((this.client = (function (e) {
            let t = e.fetchImpl ?? globalThis.fetch;
            return {
              async request({
                method: r,
                path: n,
                query: i,
                body: s,
                headers: a,
              }) {
                let o = (function (e, t, r) {
                    let n = new URL(t, e);
                    if (r)
                      for (let [e, t] of Object.entries(r))
                        void 0 !== t && n.searchParams.set(e, t);
                    return n.toString();
                  })(e.baseUrl, n, i),
                  l = await rh(e.auth),
                  u = await t(o, {
                    method: r,
                    headers: {
                      ...(s ? { 'Content-Type': 'application/json' } : {}),
                      ...l,
                      ...a,
                    },
                    body: s ? JSON.stringify(s) : void 0,
                  }),
                  c = await u.text(),
                  h = (u.headers.get('content-type') || '').includes(
                    'application/json'
                  ),
                  d = h && c ? JSON.parse(c) : c;
                if (!u.ok) {
                  let e = h ? d : void 0,
                    t = e?.error;
                  throw new rc(
                    t?.message ?? `Request failed with status ${u.status}`,
                    {
                      status: u.status,
                      icebergType: t?.type,
                      icebergCode: t?.code,
                      details: e,
                    }
                  );
                }
                return { status: u.status, headers: u.headers, data: d };
              },
            };
          })({ baseUrl: r, auth: e.auth, fetchImpl: e.fetch })),
            (this.accessDelegation = e.accessDelegation?.join(',')),
            (this.namespaceOps = new rp(this.client, t)),
            (this.tableOps = new rg(this.client, t, this.accessDelegation)));
        }
        async listNamespaces(e) {
          return this.namespaceOps.listNamespaces(e);
        }
        async createNamespace(e, t) {
          return this.namespaceOps.createNamespace(e, t);
        }
        async dropNamespace(e) {
          await this.namespaceOps.dropNamespace(e);
        }
        async loadNamespaceMetadata(e) {
          return this.namespaceOps.loadNamespaceMetadata(e);
        }
        async listTables(e) {
          return this.tableOps.listTables(e);
        }
        async createTable(e, t) {
          return this.tableOps.createTable(e, t);
        }
        async updateTable(e, t) {
          return this.tableOps.updateTable(e, t);
        }
        async dropTable(e, t) {
          await this.tableOps.dropTable(e, t);
        }
        async loadTable(e) {
          return this.tableOps.loadTable(e);
        }
        async namespaceExists(e) {
          return this.namespaceOps.namespaceExists(e);
        }
        async tableExists(e) {
          return this.tableOps.tableExists(e);
        }
        async createNamespaceIfNotExists(e, t) {
          return this.namespaceOps.createNamespaceIfNotExists(e, t);
        }
        async createTableIfNotExists(e, t) {
          return this.tableOps.createTableIfNotExists(e, t);
        }
      },
      ry = class extends Error {
        constructor(e) {
          (super(e),
            (this.__isStorageError = !0),
            (this.name = 'StorageError'));
        }
      };
    function rb(e) {
      return 'object' == typeof e && null !== e && '__isStorageError' in e;
    }
    var rv = class extends ry {
        constructor(e, t, r) {
          (super(e),
            (this.name = 'StorageApiError'),
            (this.status = t),
            (this.statusCode = r));
        }
        toJSON() {
          return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode,
          };
        }
      },
      rw = class extends ry {
        constructor(e, t) {
          (super(e),
            (this.name = 'StorageUnknownError'),
            (this.originalError = t));
        }
      };
    let r_ = (e) => (e ? (...t) => e(...t) : (...e) => fetch(...e)),
      rE = (e) => {
        if (Array.isArray(e)) return e.map((e) => rE(e));
        if ('function' == typeof e || e !== Object(e)) return e;
        let t = {};
        return (
          Object.entries(e).forEach(([e, r]) => {
            t[
              e.replace(/([-_][a-z])/gi, (e) =>
                e.toUpperCase().replace(/[-_]/g, '')
              )
            ] = rE(r);
          }),
          t
        );
      };
    function rS(e) {
      return (rS =
        'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
          ? function (e) {
              return typeof e;
            }
          : function (e) {
              return e &&
                'function' == typeof Symbol &&
                e.constructor === Symbol &&
                e !== Symbol.prototype
                ? 'symbol'
                : typeof e;
            })(e);
    }
    function rR(e, t) {
      var r = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        (t &&
          (n = n.filter(function (t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable;
          })),
          r.push.apply(r, n));
      }
      return r;
    }
    function rO(e) {
      for (var t = 1; t < arguments.length; t++) {
        var r = null != arguments[t] ? arguments[t] : {};
        t % 2
          ? rR(Object(r), !0).forEach(function (t) {
              !(function (e, t, r) {
                var n;
                ((n = (function (e, t) {
                  if ('object' != rS(e) || !e) return e;
                  var r = e[Symbol.toPrimitive];
                  if (void 0 !== r) {
                    var n = r.call(e, t || 'default');
                    if ('object' != rS(n)) return n;
                    throw TypeError(
                      '@@toPrimitive must return a primitive value.'
                    );
                  }
                  return ('string' === t ? String : Number)(e);
                })(t, 'string')),
                (t = 'symbol' == rS(n) ? n : n + '') in e)
                  ? Object.defineProperty(e, t, {
                      value: r,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                    })
                  : (e[t] = r);
              })(e, t, r[t]);
            })
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
            : rR(Object(r)).forEach(function (t) {
                Object.defineProperty(
                  e,
                  t,
                  Object.getOwnPropertyDescriptor(r, t)
                );
              });
      }
      return e;
    }
    let rT = (e) => {
        var t;
        return (
          e.msg ||
          e.message ||
          e.error_description ||
          ('string' == typeof e.error
            ? e.error
            : null == (t = e.error)
              ? void 0
              : t.message) ||
          JSON.stringify(e)
        );
      },
      rk = async (e, t, r) => {
        e instanceof (await Response) && !(null == r ? void 0 : r.noResolveJson)
          ? e
              .json()
              .then((r) => {
                let n = e.status || 500,
                  i = (null == r ? void 0 : r.statusCode) || n + '';
                t(new rv(rT(r), n, i));
              })
              .catch((e) => {
                t(new rw(rT(e), e));
              })
          : t(new rw(rT(e), e));
      };
    async function rP(e, t, r, n, i, s) {
      return new Promise((a, o) => {
        let l;
        e(
          r,
          ((l = { method: t, headers: (null == n ? void 0 : n.headers) || {} }),
          'GET' === t || !s
            ? l
            : (((e) => {
                if ('object' != typeof e || null === e) return !1;
                let t = Object.getPrototypeOf(e);
                return (
                  (null === t ||
                    t === Object.prototype ||
                    null === Object.getPrototypeOf(t)) &&
                  !(Symbol.toStringTag in e) &&
                  !(Symbol.iterator in e)
                );
              })(s)
                ? ((l.headers = rO(
                    { 'Content-Type': 'application/json' },
                    null == n ? void 0 : n.headers
                  )),
                  (l.body = JSON.stringify(s)))
                : (l.body = s),
              (null == n ? void 0 : n.duplex) && (l.duplex = n.duplex),
              rO(rO({}, l), i)))
        )
          .then((e) => {
            if (!e.ok) throw e;
            return (null == n ? void 0 : n.noResolveJson) ? e : e.json();
          })
          .then((e) => a(e))
          .catch((e) => rk(e, o, n));
      });
    }
    async function rx(e, t, r, n) {
      return rP(e, 'GET', t, r, n);
    }
    async function rA(e, t, r, n, i) {
      return rP(e, 'POST', t, n, i, r);
    }
    async function rC(e, t, r, n, i) {
      return rP(e, 'PUT', t, n, i, r);
    }
    async function rI(e, t, r, n) {
      return rP(e, 'HEAD', t, rO(rO({}, r), {}, { noResolveJson: !0 }), n);
    }
    async function rN(e, t, r, n, i) {
      return rP(e, 'DELETE', t, n, i, r);
    }
    var rj = class {
      constructor(e, t) {
        ((this.downloadFn = e), (this.shouldThrowOnError = t));
      }
      then(e, t) {
        return this.execute().then(e, t);
      }
      async execute() {
        try {
          return { data: (await this.downloadFn()).body, error: null };
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
    };
    r = Symbol.toStringTag;
    var rD = class {
      constructor(e, t) {
        ((this.downloadFn = e),
          (this.shouldThrowOnError = t),
          (this[r] = 'BlobDownloadBuilder'),
          (this.promise = null));
      }
      asStream() {
        return new rj(this.downloadFn, this.shouldThrowOnError);
      }
      then(e, t) {
        return this.getPromise().then(e, t);
      }
      catch(e) {
        return this.getPromise().catch(e);
      }
      finally(e) {
        return this.getPromise().finally(e);
      }
      getPromise() {
        return (this.promise || (this.promise = this.execute()), this.promise);
      }
      async execute() {
        try {
          return { data: await (await this.downloadFn()).blob(), error: null };
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
    };
    let r$ = {
        limit: 100,
        offset: 0,
        sortBy: { column: 'name', order: 'asc' },
      },
      rL = {
        cacheControl: '3600',
        contentType: 'text/plain;charset=UTF-8',
        upsert: !1,
      };
    var rU = class {
      constructor(e, t = {}, r, n) {
        ((this.shouldThrowOnError = !1),
          (this.url = e),
          (this.headers = t),
          (this.bucketId = r),
          (this.fetch = r_(n)));
      }
      throwOnError() {
        return ((this.shouldThrowOnError = !0), this);
      }
      async uploadOrUpdate(e, t, r, n) {
        try {
          let i,
            s = rO(rO({}, rL), n),
            a = rO(
              rO({}, this.headers),
              'POST' === e && { 'x-upsert': String(s.upsert) }
            ),
            o = s.metadata;
          ('u' > typeof Blob && r instanceof Blob
            ? ((i = new FormData()).append('cacheControl', s.cacheControl),
              o && i.append('metadata', this.encodeMetadata(o)),
              i.append('', r))
            : 'u' > typeof FormData && r instanceof FormData
              ? ((i = r).has('cacheControl') ||
                  i.append('cacheControl', s.cacheControl),
                o &&
                  !i.has('metadata') &&
                  i.append('metadata', this.encodeMetadata(o)))
              : ((i = r),
                (a['cache-control'] = `max-age=${s.cacheControl}`),
                (a['content-type'] = s.contentType),
                o && (a['x-metadata'] = this.toBase64(this.encodeMetadata(o))),
                (('u' > typeof ReadableStream && i instanceof ReadableStream) ||
                  (i &&
                    'object' == typeof i &&
                    'pipe' in i &&
                    'function' == typeof i.pipe)) &&
                  !s.duplex &&
                  (s.duplex = 'half')),
            (null == n ? void 0 : n.headers) && (a = rO(rO({}, a), n.headers)));
          let l = this._removeEmptyFolders(t),
            u = this._getFinalPath(l),
            c = await ('PUT' == e ? rC : rA)(
              this.fetch,
              `${this.url}/object/${u}`,
              i,
              rO(
                { headers: a },
                (null == s ? void 0 : s.duplex) ? { duplex: s.duplex } : {}
              )
            );
          return { data: { path: l, id: c.Id, fullPath: c.Key }, error: null };
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
      async upload(e, t, r) {
        return this.uploadOrUpdate('POST', e, t, r);
      }
      async uploadToSignedUrl(e, t, r, n) {
        let i = this._removeEmptyFolders(e),
          s = this._getFinalPath(i),
          a = new URL(this.url + `/object/upload/sign/${s}`);
        a.searchParams.set('token', t);
        try {
          let e,
            t = rO({ upsert: rL.upsert }, n),
            s = rO(rO({}, this.headers), { 'x-upsert': String(t.upsert) });
          return (
            'u' > typeof Blob && r instanceof Blob
              ? ((e = new FormData()).append('cacheControl', t.cacheControl),
                e.append('', r))
              : 'u' > typeof FormData && r instanceof FormData
                ? (e = r).append('cacheControl', t.cacheControl)
                : ((e = r),
                  (s['cache-control'] = `max-age=${t.cacheControl}`),
                  (s['content-type'] = t.contentType)),
            {
              data: {
                path: i,
                fullPath: (
                  await rC(this.fetch, a.toString(), e, { headers: s })
                ).Key,
              },
              error: null,
            }
          );
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
      async createSignedUploadUrl(e, t) {
        try {
          let r = this._getFinalPath(e),
            n = rO({}, this.headers);
          (null == t ? void 0 : t.upsert) && (n['x-upsert'] = 'true');
          let i = await rA(
              this.fetch,
              `${this.url}/object/upload/sign/${r}`,
              {},
              { headers: n }
            ),
            s = new URL(this.url + i.url),
            a = s.searchParams.get('token');
          if (!a) throw new ry('No token returned by API');
          return {
            data: { signedUrl: s.toString(), path: e, token: a },
            error: null,
          };
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
      async update(e, t, r) {
        return this.uploadOrUpdate('PUT', e, t, r);
      }
      async move(e, t, r) {
        try {
          return {
            data: await rA(
              this.fetch,
              `${this.url}/object/move`,
              {
                bucketId: this.bucketId,
                sourceKey: e,
                destinationKey: t,
                destinationBucket: null == r ? void 0 : r.destinationBucket,
              },
              { headers: this.headers }
            ),
            error: null,
          };
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
      async copy(e, t, r) {
        try {
          return {
            data: {
              path: (
                await rA(
                  this.fetch,
                  `${this.url}/object/copy`,
                  {
                    bucketId: this.bucketId,
                    sourceKey: e,
                    destinationKey: t,
                    destinationBucket: null == r ? void 0 : r.destinationBucket,
                  },
                  { headers: this.headers }
                )
              ).Key,
            },
            error: null,
          };
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
      async createSignedUrl(e, t, r) {
        try {
          let n = this._getFinalPath(e),
            i = await rA(
              this.fetch,
              `${this.url}/object/sign/${n}`,
              rO(
                { expiresIn: t },
                (null == r ? void 0 : r.transform)
                  ? { transform: r.transform }
                  : {}
              ),
              { headers: this.headers }
            ),
            s = (null == r ? void 0 : r.download)
              ? `&download=${!0 === r.download ? '' : r.download}`
              : '';
          return {
            data: (i = {
              signedUrl: encodeURI(`${this.url}${i.signedURL}${s}`),
            }),
            error: null,
          };
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
      async createSignedUrls(e, t, r) {
        var n = this;
        try {
          let i = await rA(
              n.fetch,
              `${n.url}/object/sign/${n.bucketId}`,
              { expiresIn: t, paths: e },
              { headers: n.headers }
            ),
            s = (null == r ? void 0 : r.download)
              ? `&download=${!0 === r.download ? '' : r.download}`
              : '';
          return {
            data: i.map((e) =>
              rO(
                rO({}, e),
                {},
                {
                  signedUrl: e.signedURL
                    ? encodeURI(`${n.url}${e.signedURL}${s}`)
                    : null,
                }
              )
            ),
            error: null,
          };
        } catch (e) {
          if (n.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
      download(e, t) {
        let r =
            void 0 !== (null == t ? void 0 : t.transform)
              ? 'render/image/authenticated'
              : 'object',
          n = this.transformOptsToQueryString(
            (null == t ? void 0 : t.transform) || {}
          ),
          i = n ? `?${n}` : '',
          s = this._getFinalPath(e);
        return new rD(
          () =>
            rx(this.fetch, `${this.url}/${r}/${s}${i}`, {
              headers: this.headers,
              noResolveJson: !0,
            }),
          this.shouldThrowOnError
        );
      }
      async info(e) {
        let t = this._getFinalPath(e);
        try {
          return {
            data: rE(
              await rx(this.fetch, `${this.url}/object/info/${t}`, {
                headers: this.headers,
              })
            ),
            error: null,
          };
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
      async exists(e) {
        let t = this._getFinalPath(e);
        try {
          return (
            await rI(this.fetch, `${this.url}/object/${t}`, {
              headers: this.headers,
            }),
            { data: !0, error: null }
          );
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e) && e instanceof rw) {
            let t = e.originalError;
            if ([400, 404].includes(null == t ? void 0 : t.status))
              return { data: !1, error: e };
          }
          throw e;
        }
      }
      getPublicUrl(e, t) {
        let r = this._getFinalPath(e),
          n = [],
          i = (null == t ? void 0 : t.download)
            ? `download=${!0 === t.download ? '' : t.download}`
            : '';
        '' !== i && n.push(i);
        let s =
            void 0 !== (null == t ? void 0 : t.transform)
              ? 'render/image'
              : 'object',
          a = this.transformOptsToQueryString(
            (null == t ? void 0 : t.transform) || {}
          );
        '' !== a && n.push(a);
        let o = n.join('&');
        return (
          '' !== o && (o = `?${o}`),
          { data: { publicUrl: encodeURI(`${this.url}/${s}/public/${r}${o}`) } }
        );
      }
      async remove(e) {
        try {
          return {
            data: await rN(
              this.fetch,
              `${this.url}/object/${this.bucketId}`,
              { prefixes: e },
              { headers: this.headers }
            ),
            error: null,
          };
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
      async list(e, t, r) {
        try {
          let n = rO(rO(rO({}, r$), t), {}, { prefix: e || '' });
          return {
            data: await rA(
              this.fetch,
              `${this.url}/object/list/${this.bucketId}`,
              n,
              { headers: this.headers },
              r
            ),
            error: null,
          };
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
      async listV2(e, t) {
        try {
          let r = rO({}, e);
          return {
            data: await rA(
              this.fetch,
              `${this.url}/object/list-v2/${this.bucketId}`,
              r,
              { headers: this.headers },
              t
            ),
            error: null,
          };
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (rb(e)) return { data: null, error: e };
          throw e;
        }
      }
      encodeMetadata(e) {
        return JSON.stringify(e);
      }
      toBase64(e) {
        return 'u' > typeof Buffer
          ? Buffer.from(e).toString('base64')
          : btoa(e);
      }
      _getFinalPath(e) {
        return `${this.bucketId}/${e.replace(/^\/+/, '')}`;
      }
      _removeEmptyFolders(e) {
        return e.replace(/^\/|\/$/g, '').replace(/\/+/g, '/');
      }
      transformOptsToQueryString(e) {
        let t = [];
        return (
          e.width && t.push(`width=${e.width}`),
          e.height && t.push(`height=${e.height}`),
          e.resize && t.push(`resize=${e.resize}`),
          e.format && t.push(`format=${e.format}`),
          e.quality && t.push(`quality=${e.quality}`),
          t.join('&')
        );
      }
    };
    let rM = '2.91.1',
      rB = { 'X-Client-Info': `storage-js/${rM}` };
    var rq = class {
        constructor(e, t = {}, r, n) {
          this.shouldThrowOnError = !1;
          const i = new URL(e);
          ((null == n ? void 0 : n.useNewHostname) &&
            /supabase\.(co|in|red)$/.test(i.hostname) &&
            !i.hostname.includes('storage.supabase.') &&
            (i.hostname = i.hostname.replace('supabase.', 'storage.supabase.')),
            (this.url = i.href.replace(/\/$/, '')),
            (this.headers = rO(rO({}, rB), t)),
            (this.fetch = r_(r)));
        }
        throwOnError() {
          return ((this.shouldThrowOnError = !0), this);
        }
        async listBuckets(e) {
          try {
            let t = this.listBucketOptionsToQueryString(e);
            return {
              data: await rx(this.fetch, `${this.url}/bucket${t}`, {
                headers: this.headers,
              }),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rb(e)) return { data: null, error: e };
            throw e;
          }
        }
        async getBucket(e) {
          try {
            return {
              data: await rx(this.fetch, `${this.url}/bucket/${e}`, {
                headers: this.headers,
              }),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rb(e)) return { data: null, error: e };
            throw e;
          }
        }
        async createBucket(e, t = { public: !1 }) {
          try {
            return {
              data: await rA(
                this.fetch,
                `${this.url}/bucket`,
                {
                  id: e,
                  name: e,
                  type: t.type,
                  public: t.public,
                  file_size_limit: t.fileSizeLimit,
                  allowed_mime_types: t.allowedMimeTypes,
                },
                { headers: this.headers }
              ),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rb(e)) return { data: null, error: e };
            throw e;
          }
        }
        async updateBucket(e, t) {
          try {
            return {
              data: await rC(
                this.fetch,
                `${this.url}/bucket/${e}`,
                {
                  id: e,
                  name: e,
                  public: t.public,
                  file_size_limit: t.fileSizeLimit,
                  allowed_mime_types: t.allowedMimeTypes,
                },
                { headers: this.headers }
              ),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rb(e)) return { data: null, error: e };
            throw e;
          }
        }
        async emptyBucket(e) {
          try {
            return {
              data: await rA(
                this.fetch,
                `${this.url}/bucket/${e}/empty`,
                {},
                { headers: this.headers }
              ),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rb(e)) return { data: null, error: e };
            throw e;
          }
        }
        async deleteBucket(e) {
          try {
            return {
              data: await rN(
                this.fetch,
                `${this.url}/bucket/${e}`,
                {},
                { headers: this.headers }
              ),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rb(e)) return { data: null, error: e };
            throw e;
          }
        }
        listBucketOptionsToQueryString(e) {
          let t = {};
          return (
            e &&
              ('limit' in e && (t.limit = String(e.limit)),
              'offset' in e && (t.offset = String(e.offset)),
              e.search && (t.search = e.search),
              e.sortColumn && (t.sortColumn = e.sortColumn),
              e.sortOrder && (t.sortOrder = e.sortOrder)),
            Object.keys(t).length > 0
              ? '?' + new URLSearchParams(t).toString()
              : ''
          );
        }
      },
      rV = class {
        constructor(e, t = {}, r) {
          ((this.shouldThrowOnError = !1),
            (this.url = e.replace(/\/$/, '')),
            (this.headers = rO(rO({}, rB), t)),
            (this.fetch = r_(r)));
        }
        throwOnError() {
          return ((this.shouldThrowOnError = !0), this);
        }
        async createBucket(e) {
          try {
            return {
              data: await rA(
                this.fetch,
                `${this.url}/bucket`,
                { name: e },
                { headers: this.headers }
              ),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rb(e)) return { data: null, error: e };
            throw e;
          }
        }
        async listBuckets(e) {
          try {
            let t = new URLSearchParams();
            ((null == e ? void 0 : e.limit) !== void 0 &&
              t.set('limit', e.limit.toString()),
              (null == e ? void 0 : e.offset) !== void 0 &&
                t.set('offset', e.offset.toString()),
              (null == e ? void 0 : e.sortColumn) &&
                t.set('sortColumn', e.sortColumn),
              (null == e ? void 0 : e.sortOrder) &&
                t.set('sortOrder', e.sortOrder),
              (null == e ? void 0 : e.search) && t.set('search', e.search));
            let r = t.toString(),
              n = r ? `${this.url}/bucket?${r}` : `${this.url}/bucket`;
            return {
              data: await rx(this.fetch, n, { headers: this.headers }),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rb(e)) return { data: null, error: e };
            throw e;
          }
        }
        async deleteBucket(e) {
          try {
            return {
              data: await rN(
                this.fetch,
                `${this.url}/bucket/${e}`,
                {},
                { headers: this.headers }
              ),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rb(e)) return { data: null, error: e };
            throw e;
          }
        }
        from(e) {
          var t = this;
          if (
            !(
              !(
                !e ||
                'string' != typeof e ||
                0 === e.length ||
                e.length > 100 ||
                e.trim() !== e ||
                e.includes('/') ||
                e.includes('\\')
              ) && /^[\w!.\*'() &$@=;:+,?-]+$/.test(e)
            )
          )
            throw new ry(
              'Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.'
            );
          let r = new rm({
              baseUrl: this.url,
              catalogName: e,
              auth: { type: 'custom', getHeaders: async () => t.headers },
              fetch: this.fetch,
            }),
            n = this.shouldThrowOnError;
          return new Proxy(r, {
            get(e, t) {
              let r = e[t];
              return 'function' != typeof r
                ? r
                : async (...t) => {
                    try {
                      return { data: await r.apply(e, t), error: null };
                    } catch (e) {
                      if (n) throw e;
                      return { data: null, error: e };
                    }
                  };
            },
          });
        }
      };
    let rW = {
      'X-Client-Info': `storage-js/${rM}`,
      'Content-Type': 'application/json',
    };
    var rG = class extends Error {
      constructor(e) {
        (super(e),
          (this.__isStorageVectorsError = !0),
          (this.name = 'StorageVectorsError'));
      }
    };
    function rH(e) {
      return (
        'object' == typeof e && null !== e && '__isStorageVectorsError' in e
      );
    }
    var rF = class extends rG {
        constructor(e, t, r) {
          (super(e),
            (this.name = 'StorageVectorsApiError'),
            (this.status = t),
            (this.statusCode = r));
        }
        toJSON() {
          return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode,
          };
        }
      },
      rz = class extends rG {
        constructor(e, t) {
          (super(e),
            (this.name = 'StorageVectorsUnknownError'),
            (this.originalError = t));
        }
      };
    let rK = (e) => (e ? (...t) => e(...t) : (...e) => fetch(...e)),
      rX = (e) =>
        e.msg ||
        e.message ||
        e.error_description ||
        e.error ||
        JSON.stringify(e),
      rJ = async (e, t, r) => {
        if (
          e &&
          'object' == typeof e &&
          'status' in e &&
          'ok' in e &&
          'number' == typeof e.status &&
          !(null == r ? void 0 : r.noResolveJson)
        ) {
          let r = e.status || 500;
          'function' == typeof e.json
            ? e
                .json()
                .then((e) => {
                  let n =
                    (null == e ? void 0 : e.statusCode) ||
                    (null == e ? void 0 : e.code) ||
                    r + '';
                  t(new rF(rX(e), r, n));
                })
                .catch(() => {
                  t(new rF(e.statusText || `HTTP ${r} error`, r, r + ''));
                })
            : t(new rF(e.statusText || `HTTP ${r} error`, r, r + ''));
        } else t(new rz(rX(e), e));
      };
    async function rY(e, t, r, n, i, s) {
      return new Promise((a, o) => {
        let l;
        e(
          r,
          ((l = { method: t, headers: (null == n ? void 0 : n.headers) || {} }),
          'GET' === t || !s
            ? l
            : (((e) => {
                if ('object' != typeof e || null === e) return !1;
                let t = Object.getPrototypeOf(e);
                return (
                  (null === t ||
                    t === Object.prototype ||
                    null === Object.getPrototypeOf(t)) &&
                  !(Symbol.toStringTag in e) &&
                  !(Symbol.iterator in e)
                );
              })(s)
                ? ((l.headers = rO(
                    { 'Content-Type': 'application/json' },
                    null == n ? void 0 : n.headers
                  )),
                  (l.body = JSON.stringify(s)))
                : (l.body = s),
              rO(rO({}, l), i)))
        )
          .then((e) => {
            if (!e.ok) throw e;
            if (null == n ? void 0 : n.noResolveJson) return e;
            let t = e.headers.get('content-type');
            return t && t.includes('application/json') ? e.json() : {};
          })
          .then((e) => a(e))
          .catch((e) => rJ(e, o, n));
      });
    }
    async function rQ(e, t, r, n, i) {
      return rY(e, 'POST', t, n, i, r);
    }
    var rZ = class {
        constructor(e, t = {}, r) {
          ((this.shouldThrowOnError = !1),
            (this.url = e.replace(/\/$/, '')),
            (this.headers = rO(rO({}, rW), t)),
            (this.fetch = rK(r)));
        }
        throwOnError() {
          return ((this.shouldThrowOnError = !0), this);
        }
        async createIndex(e) {
          try {
            return {
              data:
                (await rQ(this.fetch, `${this.url}/CreateIndex`, e, {
                  headers: this.headers,
                })) || {},
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
        async getIndex(e, t) {
          try {
            return {
              data: await rQ(
                this.fetch,
                `${this.url}/GetIndex`,
                { vectorBucketName: e, indexName: t },
                { headers: this.headers }
              ),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
        async listIndexes(e) {
          try {
            return {
              data: await rQ(this.fetch, `${this.url}/ListIndexes`, e, {
                headers: this.headers,
              }),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
        async deleteIndex(e, t) {
          try {
            return {
              data:
                (await rQ(
                  this.fetch,
                  `${this.url}/DeleteIndex`,
                  { vectorBucketName: e, indexName: t },
                  { headers: this.headers }
                )) || {},
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
      },
      r0 = class {
        constructor(e, t = {}, r) {
          ((this.shouldThrowOnError = !1),
            (this.url = e.replace(/\/$/, '')),
            (this.headers = rO(rO({}, rW), t)),
            (this.fetch = rK(r)));
        }
        throwOnError() {
          return ((this.shouldThrowOnError = !0), this);
        }
        async putVectors(e) {
          try {
            if (e.vectors.length < 1 || e.vectors.length > 500)
              throw Error('Vector batch size must be between 1 and 500 items');
            return {
              data:
                (await rQ(this.fetch, `${this.url}/PutVectors`, e, {
                  headers: this.headers,
                })) || {},
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
        async getVectors(e) {
          try {
            return {
              data: await rQ(this.fetch, `${this.url}/GetVectors`, e, {
                headers: this.headers,
              }),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
        async listVectors(e) {
          try {
            if (void 0 !== e.segmentCount) {
              if (e.segmentCount < 1 || e.segmentCount > 16)
                throw Error('segmentCount must be between 1 and 16');
              if (
                void 0 !== e.segmentIndex &&
                (e.segmentIndex < 0 || e.segmentIndex >= e.segmentCount)
              )
                throw Error(
                  `segmentIndex must be between 0 and ${e.segmentCount - 1}`
                );
            }
            return {
              data: await rQ(this.fetch, `${this.url}/ListVectors`, e, {
                headers: this.headers,
              }),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
        async queryVectors(e) {
          try {
            return {
              data: await rQ(this.fetch, `${this.url}/QueryVectors`, e, {
                headers: this.headers,
              }),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
        async deleteVectors(e) {
          try {
            if (e.keys.length < 1 || e.keys.length > 500)
              throw Error('Keys batch size must be between 1 and 500 items');
            return {
              data:
                (await rQ(this.fetch, `${this.url}/DeleteVectors`, e, {
                  headers: this.headers,
                })) || {},
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
      },
      r1 = class {
        constructor(e, t = {}, r) {
          ((this.shouldThrowOnError = !1),
            (this.url = e.replace(/\/$/, '')),
            (this.headers = rO(rO({}, rW), t)),
            (this.fetch = rK(r)));
        }
        throwOnError() {
          return ((this.shouldThrowOnError = !0), this);
        }
        async createBucket(e) {
          try {
            return {
              data:
                (await rQ(
                  this.fetch,
                  `${this.url}/CreateVectorBucket`,
                  { vectorBucketName: e },
                  { headers: this.headers }
                )) || {},
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
        async getBucket(e) {
          try {
            return {
              data: await rQ(
                this.fetch,
                `${this.url}/GetVectorBucket`,
                { vectorBucketName: e },
                { headers: this.headers }
              ),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
        async listBuckets(e = {}) {
          try {
            return {
              data: await rQ(this.fetch, `${this.url}/ListVectorBuckets`, e, {
                headers: this.headers,
              }),
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
        async deleteBucket(e) {
          try {
            return {
              data:
                (await rQ(
                  this.fetch,
                  `${this.url}/DeleteVectorBucket`,
                  { vectorBucketName: e },
                  { headers: this.headers }
                )) || {},
              error: null,
            };
          } catch (e) {
            if (this.shouldThrowOnError) throw e;
            if (rH(e)) return { data: null, error: e };
            throw e;
          }
        }
      },
      r2 = class extends r1 {
        constructor(e, t = {}) {
          super(e, t.headers || {}, t.fetch);
        }
        from(e) {
          return new r3(this.url, this.headers, e, this.fetch);
        }
        async createBucket(e) {
          return super.createBucket.call(this, e);
        }
        async getBucket(e) {
          return super.getBucket.call(this, e);
        }
        async listBuckets(e = {}) {
          return super.listBuckets.call(this, e);
        }
        async deleteBucket(e) {
          return super.deleteBucket.call(this, e);
        }
      },
      r3 = class extends rZ {
        constructor(e, t, r, n) {
          (super(e, t, n), (this.vectorBucketName = r));
        }
        async createIndex(e) {
          return super.createIndex.call(
            this,
            rO(rO({}, e), {}, { vectorBucketName: this.vectorBucketName })
          );
        }
        async listIndexes(e = {}) {
          return super.listIndexes.call(
            this,
            rO(rO({}, e), {}, { vectorBucketName: this.vectorBucketName })
          );
        }
        async getIndex(e) {
          return super.getIndex.call(this, this.vectorBucketName, e);
        }
        async deleteIndex(e) {
          return super.deleteIndex.call(this, this.vectorBucketName, e);
        }
        index(e) {
          return new r4(
            this.url,
            this.headers,
            this.vectorBucketName,
            e,
            this.fetch
          );
        }
      },
      r4 = class extends r0 {
        constructor(e, t, r, n, i) {
          (super(e, t, i), (this.vectorBucketName = r), (this.indexName = n));
        }
        async putVectors(e) {
          return super.putVectors.call(
            this,
            rO(
              rO({}, e),
              {},
              {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName,
              }
            )
          );
        }
        async getVectors(e) {
          return super.getVectors.call(
            this,
            rO(
              rO({}, e),
              {},
              {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName,
              }
            )
          );
        }
        async listVectors(e = {}) {
          return super.listVectors.call(
            this,
            rO(
              rO({}, e),
              {},
              {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName,
              }
            )
          );
        }
        async queryVectors(e) {
          return super.queryVectors.call(
            this,
            rO(
              rO({}, e),
              {},
              {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName,
              }
            )
          );
        }
        async deleteVectors(e) {
          return super.deleteVectors.call(
            this,
            rO(
              rO({}, e),
              {},
              {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName,
              }
            )
          );
        }
      },
      r5 = class extends rq {
        constructor(e, t = {}, r, n) {
          super(e, t, r, n);
        }
        from(e) {
          return new rU(this.url, this.headers, e, this.fetch);
        }
        get vectors() {
          return new r2(this.url + '/vector', {
            headers: this.headers,
            fetch: this.fetch,
          });
        }
        get analytics() {
          return new rV(this.url + '/iceberg', this.headers, this.fetch);
        }
      };
    let r6 = '2.91.1',
      r9 = { 'X-Client-Info': `gotrue-js/${r6}` },
      r8 = 'X-Supabase-Api-Version',
      r7 = {
        '2024-01-01': {
          timestamp: Date.parse('2024-01-01T00:00:00.0Z'),
          name: '2024-01-01',
        },
      },
      ne = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;
    class nt extends Error {
      constructor(e, t, r) {
        (super(e),
          (this.__isAuthError = !0),
          (this.name = 'AuthError'),
          (this.status = t),
          (this.code = r));
      }
    }
    function nr(e) {
      return 'object' == typeof e && null !== e && '__isAuthError' in e;
    }
    class nn extends nt {
      constructor(e, t, r) {
        (super(e, t, r),
          (this.name = 'AuthApiError'),
          (this.status = t),
          (this.code = r));
      }
    }
    class ni extends nt {
      constructor(e, t) {
        (super(e), (this.name = 'AuthUnknownError'), (this.originalError = t));
      }
    }
    class ns extends nt {
      constructor(e, t, r, n) {
        (super(e, r, n), (this.name = t), (this.status = r));
      }
    }
    class na extends ns {
      constructor() {
        super('Auth session missing!', 'AuthSessionMissingError', 400, void 0);
      }
    }
    class no extends ns {
      constructor() {
        super(
          'Auth session or user missing',
          'AuthInvalidTokenResponseError',
          500,
          void 0
        );
      }
    }
    class nl extends ns {
      constructor(e) {
        super(e, 'AuthInvalidCredentialsError', 400, void 0);
      }
    }
    class nu extends ns {
      constructor(e, t = null) {
        (super(e, 'AuthImplicitGrantRedirectError', 500, void 0),
          (this.details = null),
          (this.details = t));
      }
      toJSON() {
        return {
          name: this.name,
          message: this.message,
          status: this.status,
          details: this.details,
        };
      }
    }
    class nc extends ns {
      constructor() {
        super(
          'PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.',
          'AuthPKCECodeVerifierMissingError',
          400,
          'pkce_code_verifier_not_found'
        );
      }
    }
    class nh extends ns {
      constructor(e, t) {
        super(e, 'AuthRetryableFetchError', t, void 0);
      }
    }
    function nd(e) {
      return nr(e) && 'AuthRetryableFetchError' === e.name;
    }
    class np extends ns {
      constructor(e, t, r) {
        (super(e, 'AuthWeakPasswordError', t, 'weak_password'),
          (this.reasons = r));
      }
    }
    class nf extends ns {
      constructor(e) {
        super(e, 'AuthInvalidJwtError', 400, 'invalid_jwt');
      }
    }
    let ng =
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split(
          ''
        ),
      nm = ' 	\n\r='.split(''),
      ny = (() => {
        let e = Array(128);
        for (let t = 0; t < e.length; t += 1) e[t] = -1;
        for (let t = 0; t < nm.length; t += 1) e[nm[t].charCodeAt(0)] = -2;
        for (let t = 0; t < ng.length; t += 1) e[ng[t].charCodeAt(0)] = t;
        return e;
      })();
    function nb(e, t, r) {
      if (null !== e)
        for (
          t.queue = (t.queue << 8) | e, t.queuedBits += 8;
          t.queuedBits >= 6;
        )
          (r(ng[(t.queue >> (t.queuedBits - 6)) & 63]), (t.queuedBits -= 6));
      else if (t.queuedBits > 0)
        for (
          t.queue = t.queue << (6 - t.queuedBits), t.queuedBits = 6;
          t.queuedBits >= 6;
        )
          (r(ng[(t.queue >> (t.queuedBits - 6)) & 63]), (t.queuedBits -= 6));
    }
    function nv(e, t, r) {
      let n = ny[e];
      if (n > -1)
        for (
          t.queue = (t.queue << 6) | n, t.queuedBits += 6;
          t.queuedBits >= 8;
        )
          (r((t.queue >> (t.queuedBits - 8)) & 255), (t.queuedBits -= 8));
      else if (-2 === n) return;
      else
        throw Error(`Invalid Base64-URL character "${String.fromCharCode(e)}"`);
    }
    function nw(e) {
      let t = [],
        r = (e) => {
          t.push(String.fromCodePoint(e));
        },
        n = { utf8seq: 0, codepoint: 0 },
        i = { queue: 0, queuedBits: 0 },
        s = (e) => {
          !(function (e, t, r) {
            if (0 === t.utf8seq) {
              if (e <= 127) return r(e);
              for (let r = 1; r < 6; r += 1)
                if (((e >> (7 - r)) & 1) == 0) {
                  t.utf8seq = r;
                  break;
                }
              if (2 === t.utf8seq) t.codepoint = 31 & e;
              else if (3 === t.utf8seq) t.codepoint = 15 & e;
              else if (4 === t.utf8seq) t.codepoint = 7 & e;
              else throw Error('Invalid UTF-8 sequence');
              t.utf8seq -= 1;
            } else if (t.utf8seq > 0) {
              if (e <= 127) throw Error('Invalid UTF-8 sequence');
              ((t.codepoint = (t.codepoint << 6) | (63 & e)),
                (t.utf8seq -= 1),
                0 === t.utf8seq && r(t.codepoint));
            }
          })(e, n, r);
        };
      for (let t = 0; t < e.length; t += 1) nv(e.charCodeAt(t), i, s);
      return t.join('');
    }
    function n_(e) {
      let t = [],
        r = { queue: 0, queuedBits: 0 },
        n = (e) => {
          t.push(e);
        };
      for (let t = 0; t < e.length; t += 1) nv(e.charCodeAt(t), r, n);
      return new Uint8Array(t);
    }
    function nE(e) {
      let t = [],
        r = { queue: 0, queuedBits: 0 },
        n = (e) => {
          t.push(e);
        };
      return (e.forEach((e) => nb(e, r, n)), nb(null, r, n), t.join(''));
    }
    let nS = (e) => (e ? (...t) => e(...t) : (...e) => fetch(...e)),
      nR = async (e, t, r) => {
        await e.setItem(t, JSON.stringify(r));
      },
      nO = async (e, t) => {
        let r = await e.getItem(t);
        if (!r) return null;
        try {
          return JSON.parse(r);
        } catch (e) {
          return r;
        }
      },
      nT = async (e, t) => {
        await e.removeItem(t);
      };
    class nk {
      constructor() {
        this.promise = new nk.promiseConstructor((e, t) => {
          ((this.resolve = e), (this.reject = t));
        });
      }
    }
    function nP(e) {
      let t = e.split('.');
      if (3 !== t.length) throw new nf('Invalid JWT structure');
      for (let e = 0; e < t.length; e++)
        if (!ne.test(t[e])) throw new nf('JWT not in base64url format');
      return {
        header: JSON.parse(nw(t[0])),
        payload: JSON.parse(nw(t[1])),
        signature: n_(t[2]),
        raw: { header: t[0], payload: t[1] },
      };
    }
    async function nx(e) {
      return await new Promise((t) => {
        setTimeout(() => t(null), e);
      });
    }
    function nA(e) {
      return ('0' + e.toString(16)).substr(-2);
    }
    async function nC(e) {
      let t = new TextEncoder().encode(e);
      return Array.from(
        new Uint8Array(await crypto.subtle.digest('SHA-256', t))
      )
        .map((e) => String.fromCharCode(e))
        .join('');
    }
    async function nI(e) {
      return 'u' > typeof crypto &&
        void 0 !== crypto.subtle &&
        'u' > typeof TextEncoder
        ? btoa(await nC(e))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+$/, '')
        : (console.warn(
            'WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.'
          ),
          e);
    }
    async function nN(e, t, r = !1) {
      let n = (function () {
          let e = new Uint32Array(56);
          if ('u' < typeof crypto) {
            let e =
                'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~',
              t = e.length,
              r = '';
            for (let n = 0; n < 56; n++)
              r += e.charAt(Math.floor(Math.random() * t));
            return r;
          }
          return (crypto.getRandomValues(e), Array.from(e, nA).join(''));
        })(),
        i = n;
      (r && (i += '/PASSWORD_RECOVERY'), await nR(e, `${t}-code-verifier`, i));
      let s = await nI(n),
        a = n === s ? 'plain' : 's256';
      return [s, a];
    }
    nk.promiseConstructor = Promise;
    let nj = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i,
      nD = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
    function n$(e) {
      if (!nD.test(e))
        throw Error(
          '@supabase/auth-js: Expected parameter to be UUID but is not'
        );
    }
    function nL() {
      return new Proxy(
        {},
        {
          get: (e, t) => {
            if ('__isUserNotAvailableProxy' === t) return !0;
            if ('symbol' == typeof t) {
              let e = t.toString();
              if (
                'Symbol(Symbol.toPrimitive)' === e ||
                'Symbol(Symbol.toStringTag)' === e ||
                'Symbol(util.inspect.custom)' === e
              )
                return;
            }
            throw Error(
              `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${t}" property of the session object is not supported. Please use getUser() instead.`
            );
          },
          set: (e, t) => {
            throw Error(
              `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`
            );
          },
          deleteProperty: (e, t) => {
            throw Error(
              `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`
            );
          },
        }
      );
    }
    function nU(e) {
      return JSON.parse(JSON.stringify(e));
    }
    let nM = (e) =>
        e.msg ||
        e.message ||
        e.error_description ||
        e.error ||
        JSON.stringify(e),
      nB = [502, 503, 504];
    async function nq(e) {
      var t;
      let r, n;
      if (
        !(
          'object' == typeof e &&
          null !== e &&
          'status' in e &&
          'ok' in e &&
          'json' in e &&
          'function' == typeof e.json
        )
      )
        throw new nh(nM(e), 0);
      if (nB.includes(e.status)) throw new nh(nM(e), e.status);
      try {
        r = await e.json();
      } catch (e) {
        throw new ni(nM(e), e);
      }
      let i = (function (e) {
        let t = e.headers.get(r8);
        if (!t || !t.match(nj)) return null;
        try {
          return new Date(`${t}T00:00:00.0Z`);
        } catch (e) {
          return null;
        }
      })(e);
      if (
        (i &&
        i.getTime() >= r7['2024-01-01'].timestamp &&
        'object' == typeof r &&
        r &&
        'string' == typeof r.code
          ? (n = r.code)
          : 'object' == typeof r &&
            r &&
            'string' == typeof r.error_code &&
            (n = r.error_code),
        n)
      ) {
        if ('weak_password' === n)
          throw new np(
            nM(r),
            e.status,
            (null == (t = r.weak_password) ? void 0 : t.reasons) || []
          );
        else if ('session_not_found' === n) throw new na();
      } else if (
        'object' == typeof r &&
        r &&
        'object' == typeof r.weak_password &&
        r.weak_password &&
        Array.isArray(r.weak_password.reasons) &&
        r.weak_password.reasons.length &&
        r.weak_password.reasons.reduce((e, t) => e && 'string' == typeof t, !0)
      )
        throw new np(nM(r), e.status, r.weak_password.reasons);
      throw new nn(nM(r), e.status || 500, n);
    }
    async function nV(e, t, r, n) {
      var i;
      let s = Object.assign({}, null == n ? void 0 : n.headers);
      (s[r8] || (s[r8] = r7['2024-01-01'].name),
        (null == n ? void 0 : n.jwt) && (s.Authorization = `Bearer ${n.jwt}`));
      let a = null != (i = null == n ? void 0 : n.query) ? i : {};
      (null == n ? void 0 : n.redirectTo) && (a.redirect_to = n.redirectTo);
      let o = Object.keys(a).length
          ? '?' + new URLSearchParams(a).toString()
          : '',
        l = await nW(
          e,
          t,
          r + o,
          { headers: s, noResolveJson: null == n ? void 0 : n.noResolveJson },
          {},
          null == n ? void 0 : n.body
        );
      return (null == n ? void 0 : n.xform)
        ? null == n
          ? void 0
          : n.xform(l)
        : { data: Object.assign({}, l), error: null };
    }
    async function nW(e, t, r, n, i, s) {
      let a,
        o,
        l =
          ((o = { method: t, headers: (null == n ? void 0 : n.headers) || {} }),
          'GET' === t
            ? o
            : ((o.headers = Object.assign(
                { 'Content-Type': 'application/json;charset=UTF-8' },
                null == n ? void 0 : n.headers
              )),
              (o.body = JSON.stringify(s)),
              Object.assign(Object.assign({}, o), i)));
      try {
        a = await e(r, Object.assign({}, l));
      } catch (e) {
        throw (console.error(e), new nh(nM(e), 0));
      }
      if ((a.ok || (await nq(a)), null == n ? void 0 : n.noResolveJson))
        return a;
      try {
        return await a.json();
      } catch (e) {
        await nq(e);
      }
    }
    function nG(e) {
      var t, r, n;
      let i = null;
      (n = e).access_token &&
        n.refresh_token &&
        n.expires_in &&
        ((i = Object.assign({}, e)),
        e.expires_at ||
          (i.expires_at =
            ((r = e.expires_in), Math.round(Date.now() / 1e3) + r)));
      return {
        data: { session: i, user: null != (t = e.user) ? t : e },
        error: null,
      };
    }
    function nH(e) {
      let t = nG(e);
      return (
        !t.error &&
          e.weak_password &&
          'object' == typeof e.weak_password &&
          Array.isArray(e.weak_password.reasons) &&
          e.weak_password.reasons.length &&
          e.weak_password.message &&
          'string' == typeof e.weak_password.message &&
          e.weak_password.reasons.reduce(
            (e, t) => e && 'string' == typeof t,
            !0
          ) &&
          (t.data.weak_password = e.weak_password),
        t
      );
    }
    function nF(e) {
      var t;
      return { data: { user: null != (t = e.user) ? t : e }, error: null };
    }
    function nz(e) {
      return { data: e, error: null };
    }
    function nK(e) {
      let {
        action_link: t,
        email_otp: r,
        hashed_token: n,
        redirect_to: i,
        verification_type: s,
      } = e;
      return {
        data: {
          properties: {
            action_link: t,
            email_otp: r,
            hashed_token: n,
            redirect_to: i,
            verification_type: s,
          },
          user: Object.assign(
            {},
            tG(e, [
              'action_link',
              'email_otp',
              'hashed_token',
              'redirect_to',
              'verification_type',
            ])
          ),
        },
        error: null,
      };
    }
    function nX(e) {
      return e;
    }
    let nJ = ['global', 'local', 'others'];
    class nY {
      constructor({ url: e = '', headers: t = {}, fetch: r }) {
        ((this.url = e),
          (this.headers = t),
          (this.fetch = nS(r)),
          (this.mfa = {
            listFactors: this._listFactors.bind(this),
            deleteFactor: this._deleteFactor.bind(this),
          }),
          (this.oauth = {
            listClients: this._listOAuthClients.bind(this),
            createClient: this._createOAuthClient.bind(this),
            getClient: this._getOAuthClient.bind(this),
            updateClient: this._updateOAuthClient.bind(this),
            deleteClient: this._deleteOAuthClient.bind(this),
            regenerateClientSecret:
              this._regenerateOAuthClientSecret.bind(this),
          }));
      }
      async signOut(e, t = nJ[0]) {
        if (0 > nJ.indexOf(t))
          throw Error(
            `@supabase/auth-js: Parameter scope must be one of ${nJ.join(', ')}`
          );
        try {
          return (
            await nV(this.fetch, 'POST', `${this.url}/logout?scope=${t}`, {
              headers: this.headers,
              jwt: e,
              noResolveJson: !0,
            }),
            { data: null, error: null }
          );
        } catch (e) {
          if (nr(e)) return { data: null, error: e };
          throw e;
        }
      }
      async inviteUserByEmail(e, t = {}) {
        try {
          return await nV(this.fetch, 'POST', `${this.url}/invite`, {
            body: { email: e, data: t.data },
            headers: this.headers,
            redirectTo: t.redirectTo,
            xform: nF,
          });
        } catch (e) {
          if (nr(e)) return { data: { user: null }, error: e };
          throw e;
        }
      }
      async generateLink(e) {
        try {
          let { options: t } = e,
            r = tG(e, ['options']),
            n = Object.assign(Object.assign({}, r), t);
          return (
            'newEmail' in r &&
              ((n.new_email = null == r ? void 0 : r.newEmail),
              delete n.newEmail),
            await nV(this.fetch, 'POST', `${this.url}/admin/generate_link`, {
              body: n,
              headers: this.headers,
              xform: nK,
              redirectTo: null == t ? void 0 : t.redirectTo,
            })
          );
        } catch (e) {
          if (nr(e))
            return { data: { properties: null, user: null }, error: e };
          throw e;
        }
      }
      async createUser(e) {
        try {
          return await nV(this.fetch, 'POST', `${this.url}/admin/users`, {
            body: e,
            headers: this.headers,
            xform: nF,
          });
        } catch (e) {
          if (nr(e)) return { data: { user: null }, error: e };
          throw e;
        }
      }
      async listUsers(e) {
        var t, r, n, i, s, a, o;
        try {
          let l = { nextPage: null, lastPage: 0, total: 0 },
            u = await nV(this.fetch, 'GET', `${this.url}/admin/users`, {
              headers: this.headers,
              noResolveJson: !0,
              query: {
                page:
                  null !=
                  (r =
                    null == (t = null == e ? void 0 : e.page)
                      ? void 0
                      : t.toString())
                    ? r
                    : '',
                per_page:
                  null !=
                  (i =
                    null == (n = null == e ? void 0 : e.perPage)
                      ? void 0
                      : n.toString())
                    ? i
                    : '',
              },
              xform: nX,
            });
          if (u.error) throw u.error;
          let c = await u.json(),
            h = null != (s = u.headers.get('x-total-count')) ? s : 0,
            d =
              null !=
              (o = null == (a = u.headers.get('link')) ? void 0 : a.split(','))
                ? o
                : [];
          return (
            d.length > 0 &&
              (d.forEach((e) => {
                let t = parseInt(e.split(';')[0].split('=')[1].substring(0, 1)),
                  r = JSON.parse(e.split(';')[1].split('=')[1]);
                l[`${r}Page`] = t;
              }),
              (l.total = parseInt(h))),
            { data: Object.assign(Object.assign({}, c), l), error: null }
          );
        } catch (e) {
          if (nr(e)) return { data: { users: [] }, error: e };
          throw e;
        }
      }
      async getUserById(e) {
        n$(e);
        try {
          return await nV(this.fetch, 'GET', `${this.url}/admin/users/${e}`, {
            headers: this.headers,
            xform: nF,
          });
        } catch (e) {
          if (nr(e)) return { data: { user: null }, error: e };
          throw e;
        }
      }
      async updateUserById(e, t) {
        n$(e);
        try {
          return await nV(this.fetch, 'PUT', `${this.url}/admin/users/${e}`, {
            body: t,
            headers: this.headers,
            xform: nF,
          });
        } catch (e) {
          if (nr(e)) return { data: { user: null }, error: e };
          throw e;
        }
      }
      async deleteUser(e, t = !1) {
        n$(e);
        try {
          return await nV(
            this.fetch,
            'DELETE',
            `${this.url}/admin/users/${e}`,
            {
              headers: this.headers,
              body: { should_soft_delete: t },
              xform: nF,
            }
          );
        } catch (e) {
          if (nr(e)) return { data: { user: null }, error: e };
          throw e;
        }
      }
      async _listFactors(e) {
        n$(e.userId);
        try {
          let { data: t, error: r } = await nV(
            this.fetch,
            'GET',
            `${this.url}/admin/users/${e.userId}/factors`,
            {
              headers: this.headers,
              xform: (e) => ({ data: { factors: e }, error: null }),
            }
          );
          return { data: t, error: r };
        } catch (e) {
          if (nr(e)) return { data: null, error: e };
          throw e;
        }
      }
      async _deleteFactor(e) {
        (n$(e.userId), n$(e.id));
        try {
          return {
            data: await nV(
              this.fetch,
              'DELETE',
              `${this.url}/admin/users/${e.userId}/factors/${e.id}`,
              { headers: this.headers }
            ),
            error: null,
          };
        } catch (e) {
          if (nr(e)) return { data: null, error: e };
          throw e;
        }
      }
      async _listOAuthClients(e) {
        var t, r, n, i, s, a, o;
        try {
          let l = { nextPage: null, lastPage: 0, total: 0 },
            u = await nV(this.fetch, 'GET', `${this.url}/admin/oauth/clients`, {
              headers: this.headers,
              noResolveJson: !0,
              query: {
                page:
                  null !=
                  (r =
                    null == (t = null == e ? void 0 : e.page)
                      ? void 0
                      : t.toString())
                    ? r
                    : '',
                per_page:
                  null !=
                  (i =
                    null == (n = null == e ? void 0 : e.perPage)
                      ? void 0
                      : n.toString())
                    ? i
                    : '',
              },
              xform: nX,
            });
          if (u.error) throw u.error;
          let c = await u.json(),
            h = null != (s = u.headers.get('x-total-count')) ? s : 0,
            d =
              null !=
              (o = null == (a = u.headers.get('link')) ? void 0 : a.split(','))
                ? o
                : [];
          return (
            d.length > 0 &&
              (d.forEach((e) => {
                let t = parseInt(e.split(';')[0].split('=')[1].substring(0, 1)),
                  r = JSON.parse(e.split(';')[1].split('=')[1]);
                l[`${r}Page`] = t;
              }),
              (l.total = parseInt(h))),
            { data: Object.assign(Object.assign({}, c), l), error: null }
          );
        } catch (e) {
          if (nr(e)) return { data: { clients: [] }, error: e };
          throw e;
        }
      }
      async _createOAuthClient(e) {
        try {
          return await nV(
            this.fetch,
            'POST',
            `${this.url}/admin/oauth/clients`,
            {
              body: e,
              headers: this.headers,
              xform: (e) => ({ data: e, error: null }),
            }
          );
        } catch (e) {
          if (nr(e)) return { data: null, error: e };
          throw e;
        }
      }
      async _getOAuthClient(e) {
        try {
          return await nV(
            this.fetch,
            'GET',
            `${this.url}/admin/oauth/clients/${e}`,
            { headers: this.headers, xform: (e) => ({ data: e, error: null }) }
          );
        } catch (e) {
          if (nr(e)) return { data: null, error: e };
          throw e;
        }
      }
      async _updateOAuthClient(e, t) {
        try {
          return await nV(
            this.fetch,
            'PUT',
            `${this.url}/admin/oauth/clients/${e}`,
            {
              body: t,
              headers: this.headers,
              xform: (e) => ({ data: e, error: null }),
            }
          );
        } catch (e) {
          if (nr(e)) return { data: null, error: e };
          throw e;
        }
      }
      async _deleteOAuthClient(e) {
        try {
          return (
            await nV(
              this.fetch,
              'DELETE',
              `${this.url}/admin/oauth/clients/${e}`,
              { headers: this.headers, noResolveJson: !0 }
            ),
            { data: null, error: null }
          );
        } catch (e) {
          if (nr(e)) return { data: null, error: e };
          throw e;
        }
      }
      async _regenerateOAuthClientSecret(e) {
        try {
          return await nV(
            this.fetch,
            'POST',
            `${this.url}/admin/oauth/clients/${e}/regenerate_secret`,
            { headers: this.headers, xform: (e) => ({ data: e, error: null }) }
          );
        } catch (e) {
          if (nr(e)) return { data: null, error: e };
          throw e;
        }
      }
    }
    function nQ(e = {}) {
      return {
        getItem: (t) => e[t] || null,
        setItem: (t, r) => {
          e[t] = r;
        },
        removeItem: (t) => {
          delete e[t];
        },
      };
    }
    globalThis;
    class nZ extends Error {
      constructor(e) {
        (super(e), (this.isAcquireTimeout = !0));
      }
    }
    function n0(e) {
      if (!/^0x[a-fA-F0-9]{40}$/.test(e))
        throw Error(`@supabase/auth-js: Address "${e}" is invalid.`);
      return e.toLowerCase();
    }
    class n1 extends Error {
      constructor({ message: e, code: t, cause: r, name: n }) {
        var i;
        (super(e, { cause: r }),
          (this.__isWebAuthnError = !0),
          (this.name =
            null != (i = null != n ? n : r instanceof Error ? r.name : void 0)
              ? i
              : 'Unknown Error'),
          (this.code = t));
      }
    }
    class n2 extends n1 {
      constructor(e, t) {
        (super({
          code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
          cause: t,
          message: e,
        }),
          (this.name = 'WebAuthnUnknownError'),
          (this.originalError = t));
      }
    }
    let n3 = new (class {
      createNewAbortSignal() {
        if (this.controller) {
          let e = Error('Cancelling existing WebAuthn API call for new one');
          ((e.name = 'AbortError'), this.controller.abort(e));
        }
        let e = new AbortController();
        return ((this.controller = e), e.signal);
      }
      cancelCeremony() {
        if (this.controller) {
          let e = Error('Manually cancelling existing WebAuthn API call');
          ((e.name = 'AbortError'),
            this.controller.abort(e),
            (this.controller = void 0));
        }
      }
    })();
    function n4(e) {
      return (
        'localhost' === e || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)
      );
    }
    async function n5(e) {
      try {
        let t = await navigator.credentials.create(e);
        if (!t)
          return { data: null, error: new n2('Empty credential response', t) };
        if (!(t instanceof PublicKeyCredential))
          return {
            data: null,
            error: new n2('Browser returned unexpected credential type', t),
          };
        return { data: t, error: null };
      } catch (t) {
        return {
          data: null,
          error: (function ({ error: e, options: t }) {
            var r, n, i;
            let { publicKey: s } = t;
            if (!s)
              throw Error('options was missing required publicKey property');
            if ('AbortError' === e.name) {
              if (t.signal instanceof AbortSignal)
                return new n1({
                  message: 'Registration ceremony was sent an abort signal',
                  code: 'ERROR_CEREMONY_ABORTED',
                  cause: e,
                });
            } else if ('ConstraintError' === e.name) {
              if (
                (null == (r = s.authenticatorSelection)
                  ? void 0
                  : r.requireResidentKey) === !0
              )
                return new n1({
                  message:
                    'Discoverable credentials were required but no available authenticator supported it',
                  code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',
                  cause: e,
                });
              else if (
                'conditional' === t.mediation &&
                (null == (n = s.authenticatorSelection)
                  ? void 0
                  : n.userVerification) === 'required'
              )
                return new n1({
                  message:
                    'User verification was required during automatic registration but it could not be performed',
                  code: 'ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE',
                  cause: e,
                });
              else if (
                (null == (i = s.authenticatorSelection)
                  ? void 0
                  : i.userVerification) === 'required'
              )
                return new n1({
                  message:
                    'User verification was required but no available authenticator supported it',
                  code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',
                  cause: e,
                });
            } else if ('InvalidStateError' === e.name)
              return new n1({
                message: 'The authenticator was previously registered',
                code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',
                cause: e,
              });
            else if ('NotAllowedError' === e.name)
              return new n1({
                message: e.message,
                code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
                cause: e,
              });
            else if ('NotSupportedError' === e.name)
              return new n1(
                0 ===
                  s.pubKeyCredParams.filter((e) => 'public-key' === e.type)
                    .length
                  ? {
                      message:
                        'No entry in pubKeyCredParams was of type "public-key"',
                      code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',
                      cause: e,
                    }
                  : {
                      message:
                        'No available authenticator supported any of the specified pubKeyCredParams algorithms',
                      code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',
                      cause: e,
                    }
              );
            else if ('SecurityError' === e.name) {
              let t = window.location.hostname;
              if (!n4(t))
                return new n1({
                  message: `${window.location.hostname} is an invalid domain`,
                  code: 'ERROR_INVALID_DOMAIN',
                  cause: e,
                });
              if (s.rp.id !== t)
                return new n1({
                  message: `The RP ID "${s.rp.id}" is invalid for this domain`,
                  code: 'ERROR_INVALID_RP_ID',
                  cause: e,
                });
            } else if ('TypeError' === e.name) {
              if (s.user.id.byteLength < 1 || s.user.id.byteLength > 64)
                return new n1({
                  message: 'User ID was not between 1 and 64 characters',
                  code: 'ERROR_INVALID_USER_ID_LENGTH',
                  cause: e,
                });
            } else if ('UnknownError' === e.name)
              return new n1({
                message:
                  'The authenticator was unable to process the specified options, or could not create a new credential',
                code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',
                cause: e,
              });
            return new n1({
              message: 'a Non-Webauthn related error has occurred',
              code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
              cause: e,
            });
          })({ error: t, options: e }),
        };
      }
    }
    async function n6(e) {
      try {
        let t = await navigator.credentials.get(e);
        if (!t)
          return { data: null, error: new n2('Empty credential response', t) };
        if (!(t instanceof PublicKeyCredential))
          return {
            data: null,
            error: new n2('Browser returned unexpected credential type', t),
          };
        return { data: t, error: null };
      } catch (t) {
        return {
          data: null,
          error: (function ({ error: e, options: t }) {
            let { publicKey: r } = t;
            if (!r)
              throw Error('options was missing required publicKey property');
            if ('AbortError' === e.name) {
              if (t.signal instanceof AbortSignal)
                return new n1({
                  message: 'Authentication ceremony was sent an abort signal',
                  code: 'ERROR_CEREMONY_ABORTED',
                  cause: e,
                });
            } else if ('NotAllowedError' === e.name)
              return new n1({
                message: e.message,
                code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
                cause: e,
              });
            else if ('SecurityError' === e.name) {
              let t = window.location.hostname;
              if (!n4(t))
                return new n1({
                  message: `${window.location.hostname} is an invalid domain`,
                  code: 'ERROR_INVALID_DOMAIN',
                  cause: e,
                });
              if (r.rpId !== t)
                return new n1({
                  message: `The RP ID "${r.rpId}" is invalid for this domain`,
                  code: 'ERROR_INVALID_RP_ID',
                  cause: e,
                });
            } else if ('UnknownError' === e.name)
              return new n1({
                message:
                  'The authenticator was unable to process the specified options, or could not create a new assertion signature',
                code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',
                cause: e,
              });
            return new n1({
              message: 'a Non-Webauthn related error has occurred',
              code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
              cause: e,
            });
          })({ error: t, options: e }),
        };
      }
    }
    let n9 = {
        hints: ['security-key'],
        authenticatorSelection: {
          authenticatorAttachment: 'cross-platform',
          requireResidentKey: !1,
          userVerification: 'preferred',
          residentKey: 'discouraged',
        },
        attestation: 'direct',
      },
      n8 = {
        userVerification: 'preferred',
        hints: ['security-key'],
        attestation: 'direct',
      };
    function n7(...e) {
      let t = (e) => null !== e && 'object' == typeof e && !Array.isArray(e),
        r = (e) => e instanceof ArrayBuffer || ArrayBuffer.isView(e),
        n = {};
      for (let i of e)
        if (i)
          for (let e in i) {
            let s = i[e];
            if (void 0 !== s)
              if (Array.isArray(s)) n[e] = s;
              else if (r(s)) n[e] = s;
              else if (t(s)) {
                let r = n[e];
                t(r) ? (n[e] = n7(r, s)) : (n[e] = n7(s));
              } else n[e] = s;
          }
      return n;
    }
    class ie {
      constructor(e) {
        ((this.client = e),
          (this.enroll = this._enroll.bind(this)),
          (this.challenge = this._challenge.bind(this)),
          (this.verify = this._verify.bind(this)),
          (this.authenticate = this._authenticate.bind(this)),
          (this.register = this._register.bind(this)));
      }
      async _enroll(e) {
        return this.client.mfa.enroll(
          Object.assign(Object.assign({}, e), { factorType: 'webauthn' })
        );
      }
      async _challenge(
        { factorId: e, webauthn: t, friendlyName: r, signal: n },
        i
      ) {
        try {
          var s, a, o, l;
          let { data: u, error: c } = await this.client.mfa.challenge({
            factorId: e,
            webauthn: t,
          });
          if (!u) return { data: null, error: c };
          let h = null != n ? n : n3.createNewAbortSignal();
          if ('create' === u.webauthn.type) {
            let { user: e } = u.webauthn.credential_options.publicKey;
            (e.name || (e.name = `${e.id}:${r}`),
              e.displayName || (e.displayName = e.name));
          }
          switch (u.webauthn.type) {
            case 'create': {
              let t =
                  ((s = u.webauthn.credential_options.publicKey),
                  (a = null == i ? void 0 : i.create),
                  n7(n9, s, a || {})),
                { data: r, error: n } = await n5({ publicKey: t, signal: h });
              if (r)
                return {
                  data: {
                    factorId: e,
                    challengeId: u.id,
                    webauthn: { type: u.webauthn.type, credential_response: r },
                  },
                  error: null,
                };
              return { data: null, error: n };
            }
            case 'request': {
              let t =
                  ((o = u.webauthn.credential_options.publicKey),
                  (l = null == i ? void 0 : i.request),
                  n7(n8, o, l || {})),
                { data: r, error: n } = await n6(
                  Object.assign(
                    Object.assign({}, u.webauthn.credential_options),
                    { publicKey: t, signal: h }
                  )
                );
              if (r)
                return {
                  data: {
                    factorId: e,
                    challengeId: u.id,
                    webauthn: { type: u.webauthn.type, credential_response: r },
                  },
                  error: null,
                };
              return { data: null, error: n };
            }
          }
        } catch (e) {
          if (nr(e)) return { data: null, error: e };
          return {
            data: null,
            error: new ni('Unexpected error in challenge', e),
          };
        }
      }
      async _verify({ challengeId: e, factorId: t, webauthn: r }) {
        return this.client.mfa.verify({
          factorId: t,
          challengeId: e,
          webauthn: r,
        });
      }
      async _authenticate(
        { factorId: e, webauthn: { rpId: t, rpOrigins: r, signal: n } = {} },
        i
      ) {
        if (!t)
          return {
            data: null,
            error: new nt('rpId is required for WebAuthn authentication'),
          };
        try {
          1;
          return {
            data: null,
            error: new ni('Browser does not support WebAuthn', null),
          };
        } catch (e) {
          if (nr(e)) return { data: null, error: e };
          return {
            data: null,
            error: new ni('Unexpected error in authenticate', e),
          };
        }
      }
      async _register(
        {
          friendlyName: e,
          webauthn: { rpId: t, rpOrigins: r, signal: n } = {},
        },
        i
      ) {
        if (!t)
          return {
            data: null,
            error: new nt('rpId is required for WebAuthn registration'),
          };
        try {
          1;
          return {
            data: null,
            error: new ni('Browser does not support WebAuthn', null),
          };
        } catch (e) {
          if (nr(e)) return { data: null, error: e };
          return {
            data: null,
            error: new ni('Unexpected error in register', e),
          };
        }
      }
    }
    if ('object' != typeof globalThis)
      try {
        (Object.defineProperty(Object.prototype, '__magic__', {
          get: function () {
            return this;
          },
          configurable: !0,
        }),
          (__magic__.globalThis = __magic__),
          delete Object.prototype.__magic__);
      } catch (e) {
        'u' > typeof self && (self.globalThis = self);
      }
    let it = {
      url: 'http://localhost:9999',
      storageKey: 'supabase.auth.token',
      autoRefreshToken: !0,
      persistSession: !0,
      detectSessionInUrl: !0,
      headers: r9,
      flowType: 'implicit',
      debug: !1,
      hasCustomAuthorizationHeader: !1,
      throwOnError: !1,
      lockAcquireTimeout: 1e4,
    };
    async function ir(e, t, r) {
      return await r();
    }
    let ii = {};
    class is {
      get jwks() {
        var e, t;
        return null != (t = null == (e = ii[this.storageKey]) ? void 0 : e.jwks)
          ? t
          : { keys: [] };
      }
      set jwks(e) {
        ii[this.storageKey] = Object.assign(
          Object.assign({}, ii[this.storageKey]),
          { jwks: e }
        );
      }
      get jwks_cached_at() {
        var e, t;
        return null !=
          (t = null == (e = ii[this.storageKey]) ? void 0 : e.cachedAt)
          ? t
          : Number.MIN_SAFE_INTEGER;
      }
      set jwks_cached_at(e) {
        ii[this.storageKey] = Object.assign(
          Object.assign({}, ii[this.storageKey]),
          { cachedAt: e }
        );
      }
      constructor(e) {
        var t;
        ((this.userStorage = null),
          (this.memoryStorage = null),
          (this.stateChangeEmitters = new Map()),
          (this.autoRefreshTicker = null),
          (this.autoRefreshTickTimeout = null),
          (this.visibilityChangedCallback = null),
          (this.refreshingDeferred = null),
          (this.initializePromise = null),
          (this.detectSessionInUrl = !0),
          (this.hasCustomAuthorizationHeader = !1),
          (this.suppressGetSessionWarning = !1),
          (this.lockAcquired = !1),
          (this.pendingInLock = []),
          (this.broadcastChannel = null),
          (this.logger = console.log));
        const r = Object.assign(Object.assign({}, it), e);
        ((this.storageKey = r.storageKey),
          (this.instanceID =
            null != (t = is.nextInstanceID[this.storageKey]) ? t : 0),
          (is.nextInstanceID[this.storageKey] = this.instanceID + 1),
          (this.logDebugMessages = !!r.debug),
          'function' == typeof r.debug && (this.logger = r.debug),
          this.instanceID,
          (this.persistSession = r.persistSession),
          (this.autoRefreshToken = r.autoRefreshToken),
          (this.admin = new nY({
            url: r.url,
            headers: r.headers,
            fetch: r.fetch,
          })),
          (this.url = r.url),
          (this.headers = r.headers),
          (this.fetch = nS(r.fetch)),
          (this.lock = r.lock || ir),
          (this.detectSessionInUrl = r.detectSessionInUrl),
          (this.flowType = r.flowType),
          (this.hasCustomAuthorizationHeader = r.hasCustomAuthorizationHeader),
          (this.throwOnError = r.throwOnError),
          (this.lockAcquireTimeout = r.lockAcquireTimeout),
          r.lock
            ? (this.lock = r.lock)
            : (this.persistSession, (this.lock = ir)),
          this.jwks ||
            ((this.jwks = { keys: [] }),
            (this.jwks_cached_at = Number.MIN_SAFE_INTEGER)),
          (this.mfa = {
            verify: this._verify.bind(this),
            enroll: this._enroll.bind(this),
            unenroll: this._unenroll.bind(this),
            challenge: this._challenge.bind(this),
            listFactors: this._listFactors.bind(this),
            challengeAndVerify: this._challengeAndVerify.bind(this),
            getAuthenticatorAssuranceLevel:
              this._getAuthenticatorAssuranceLevel.bind(this),
            webauthn: new ie(this),
          }),
          (this.oauth = {
            getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
            approveAuthorization: this._approveAuthorization.bind(this),
            denyAuthorization: this._denyAuthorization.bind(this),
            listGrants: this._listOAuthGrants.bind(this),
            revokeGrant: this._revokeOAuthGrant.bind(this),
          }),
          this.persistSession
            ? (r.storage
                ? (this.storage = r.storage)
                : ((this.memoryStorage = {}),
                  (this.storage = nQ(this.memoryStorage))),
              r.userStorage && (this.userStorage = r.userStorage))
            : ((this.memoryStorage = {}),
              (this.storage = nQ(this.memoryStorage))),
          this.initialize());
      }
      isThrowOnErrorEnabled() {
        return this.throwOnError;
      }
      _returnResult(e) {
        if (this.throwOnError && e && e.error) throw e.error;
        return e;
      }
      _logPrefix() {
        return `GoTrueClient@${this.storageKey}:${this.instanceID} (${r6}) ${new Date().toISOString()}`;
      }
      _debug(...e) {
        return (
          this.logDebugMessages && this.logger(this._logPrefix(), ...e),
          this
        );
      }
      async initialize() {
        return (
          this.initializePromise ||
            (this.initializePromise = (async () =>
              await this._acquireLock(
                this.lockAcquireTimeout,
                async () => await this._initialize()
              ))()),
          await this.initializePromise
        );
      }
      async _initialize() {
        try {
          return (await this._recoverAndRefresh(), { error: null });
        } catch (e) {
          if (nr(e)) return this._returnResult({ error: e });
          return this._returnResult({
            error: new ni('Unexpected error during initialization', e),
          });
        } finally {
          (await this._handleVisibilityChange(),
            this._debug('#_initialize()', 'end'));
        }
      }
      async signInAnonymously(e) {
        var t, r, n;
        try {
          let { data: i, error: s } = await nV(
            this.fetch,
            'POST',
            `${this.url}/signup`,
            {
              headers: this.headers,
              body: {
                data:
                  null !=
                  (r =
                    null == (t = null == e ? void 0 : e.options)
                      ? void 0
                      : t.data)
                    ? r
                    : {},
                gotrue_meta_security: {
                  captcha_token:
                    null == (n = null == e ? void 0 : e.options)
                      ? void 0
                      : n.captchaToken,
                },
              },
              xform: nG,
            }
          );
          if (s || !i)
            return this._returnResult({
              data: { user: null, session: null },
              error: s,
            });
          let a = i.session,
            o = i.user;
          return (
            i.session &&
              (await this._saveSession(i.session),
              await this._notifyAllSubscribers('SIGNED_IN', a)),
            this._returnResult({ data: { user: o, session: a }, error: null })
          );
        } catch (e) {
          if (nr(e))
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          throw e;
        }
      }
      async signUp(e) {
        var t, r, n;
        try {
          let i;
          if ('email' in e) {
            let { email: r, password: n, options: s } = e,
              a = null,
              o = null;
            ('pkce' === this.flowType &&
              ([a, o] = await nN(this.storage, this.storageKey)),
              (i = await nV(this.fetch, 'POST', `${this.url}/signup`, {
                headers: this.headers,
                redirectTo: null == s ? void 0 : s.emailRedirectTo,
                body: {
                  email: r,
                  password: n,
                  data: null != (t = null == s ? void 0 : s.data) ? t : {},
                  gotrue_meta_security: {
                    captcha_token: null == s ? void 0 : s.captchaToken,
                  },
                  code_challenge: a,
                  code_challenge_method: o,
                },
                xform: nG,
              })));
          } else if ('phone' in e) {
            let { phone: t, password: s, options: a } = e;
            i = await nV(this.fetch, 'POST', `${this.url}/signup`, {
              headers: this.headers,
              body: {
                phone: t,
                password: s,
                data: null != (r = null == a ? void 0 : a.data) ? r : {},
                channel:
                  null != (n = null == a ? void 0 : a.channel) ? n : 'sms',
                gotrue_meta_security: {
                  captcha_token: null == a ? void 0 : a.captchaToken,
                },
              },
              xform: nG,
            });
          } else
            throw new nl(
              'You must provide either an email or phone number and a password'
            );
          let { data: s, error: a } = i;
          if (a || !s)
            return (
              await nT(this.storage, `${this.storageKey}-code-verifier`),
              this._returnResult({
                data: { user: null, session: null },
                error: a,
              })
            );
          let o = s.session,
            l = s.user;
          return (
            s.session &&
              (await this._saveSession(s.session),
              await this._notifyAllSubscribers('SIGNED_IN', o)),
            this._returnResult({ data: { user: l, session: o }, error: null })
          );
        } catch (e) {
          if (
            (await nT(this.storage, `${this.storageKey}-code-verifier`), nr(e))
          )
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          throw e;
        }
      }
      async signInWithPassword(e) {
        try {
          let t;
          if ('email' in e) {
            let { email: r, password: n, options: i } = e;
            t = await nV(
              this.fetch,
              'POST',
              `${this.url}/token?grant_type=password`,
              {
                headers: this.headers,
                body: {
                  email: r,
                  password: n,
                  gotrue_meta_security: {
                    captcha_token: null == i ? void 0 : i.captchaToken,
                  },
                },
                xform: nH,
              }
            );
          } else if ('phone' in e) {
            let { phone: r, password: n, options: i } = e;
            t = await nV(
              this.fetch,
              'POST',
              `${this.url}/token?grant_type=password`,
              {
                headers: this.headers,
                body: {
                  phone: r,
                  password: n,
                  gotrue_meta_security: {
                    captcha_token: null == i ? void 0 : i.captchaToken,
                  },
                },
                xform: nH,
              }
            );
          } else
            throw new nl(
              'You must provide either an email or phone number and a password'
            );
          let { data: r, error: n } = t;
          if (n)
            return this._returnResult({
              data: { user: null, session: null },
              error: n,
            });
          if (!r || !r.session || !r.user) {
            let e = new no();
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          }
          return (
            r.session &&
              (await this._saveSession(r.session),
              await this._notifyAllSubscribers('SIGNED_IN', r.session)),
            this._returnResult({
              data: Object.assign(
                { user: r.user, session: r.session },
                r.weak_password ? { weakPassword: r.weak_password } : null
              ),
              error: n,
            })
          );
        } catch (e) {
          if (nr(e))
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          throw e;
        }
      }
      async signInWithOAuth(e) {
        var t, r, n, i;
        return await this._handleProviderSignIn(e.provider, {
          redirectTo: null == (t = e.options) ? void 0 : t.redirectTo,
          scopes: null == (r = e.options) ? void 0 : r.scopes,
          queryParams: null == (n = e.options) ? void 0 : n.queryParams,
          skipBrowserRedirect:
            null == (i = e.options) ? void 0 : i.skipBrowserRedirect,
        });
      }
      async exchangeCodeForSession(e) {
        return (
          await this.initializePromise,
          this._acquireLock(this.lockAcquireTimeout, async () =>
            this._exchangeCodeForSession(e)
          )
        );
      }
      async signInWithWeb3(e) {
        let { chain: t } = e;
        switch (t) {
          case 'ethereum':
            return await this.signInWithEthereum(e);
          case 'solana':
            return await this.signInWithSolana(e);
          default:
            throw Error(`@supabase/auth-js: Unsupported chain "${t}"`);
        }
      }
      async signInWithEthereum(e) {
        var t, r, n, i, s, a, o, l, u, c, h, d;
        let p, f;
        if ('message' in e) ((p = e.message), (f = e.signature));
        else {
          let { chain: c, wallet: h, statement: g, options: m } = e;
          if ('object' != typeof h || !(null == m ? void 0 : m.url))
            throw Error(
              '@supabase/auth-js: Both wallet and url must be specified in non-browser environments.'
            );
          let y = new URL(
              null != (t = null == m ? void 0 : m.url)
                ? t
                : window.location.href
            ),
            b = await h
              .request({ method: 'eth_requestAccounts' })
              .then((e) => e)
              .catch(() => {
                throw Error(
                  '@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid'
                );
              });
          if (!b || 0 === b.length)
            throw Error(
              '@supabase/auth-js: No accounts available. Please ensure the wallet is connected.'
            );
          let v = n0(b[0]),
            w =
              null == (r = null == m ? void 0 : m.signInWithEthereum)
                ? void 0
                : r.chainId;
          (w || (w = parseInt(await h.request({ method: 'eth_chainId' }), 16)),
            (p = (function (e) {
              var t;
              let {
                chainId: r,
                domain: n,
                expirationTime: i,
                issuedAt: s = new Date(),
                nonce: a,
                notBefore: o,
                requestId: l,
                resources: u,
                scheme: c,
                uri: h,
                version: d,
              } = e;
              if (!Number.isInteger(r))
                throw Error(
                  `@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${r}`
                );
              if (!n)
                throw Error(
                  '@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.'
                );
              if (a && a.length < 8)
                throw Error(
                  `@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${a}`
                );
              if (!h)
                throw Error(
                  '@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.'
                );
              if ('1' !== d)
                throw Error(
                  `@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${d}`
                );
              if (null == (t = e.statement) ? void 0 : t.includes('\n'))
                throw Error(
                  `@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${e.statement}`
                );
              let p = n0(e.address),
                f = c ? `${c}://${n}` : n,
                g = e.statement
                  ? `${e.statement}
`
                  : '',
                m = `${f} wants you to sign in with your Ethereum account:
${p}

${g}`,
                y = `URI: ${h}
Version: ${d}
Chain ID: ${r}${
                  a
                    ? `
Nonce: ${a}`
                    : ''
                }
Issued At: ${s.toISOString()}`;
              if (
                (i &&
                  (y += `
Expiration Time: ${i.toISOString()}`),
                o &&
                  (y += `
Not Before: ${o.toISOString()}`),
                l &&
                  (y += `
Request ID: ${l}`),
                u)
              ) {
                let e = '\nResources:';
                for (let t of u) {
                  if (!t || 'string' != typeof t)
                    throw Error(
                      `@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${t}`
                    );
                  e += `
- ${t}`;
                }
                y += e;
              }
              return `${m}
${y}`;
            })({
              domain: y.host,
              address: v,
              statement: g,
              uri: y.href,
              version: '1',
              chainId: w,
              nonce:
                null == (n = null == m ? void 0 : m.signInWithEthereum)
                  ? void 0
                  : n.nonce,
              issuedAt:
                null !=
                (s =
                  null == (i = null == m ? void 0 : m.signInWithEthereum)
                    ? void 0
                    : i.issuedAt)
                  ? s
                  : new Date(),
              expirationTime:
                null == (a = null == m ? void 0 : m.signInWithEthereum)
                  ? void 0
                  : a.expirationTime,
              notBefore:
                null == (o = null == m ? void 0 : m.signInWithEthereum)
                  ? void 0
                  : o.notBefore,
              requestId:
                null == (l = null == m ? void 0 : m.signInWithEthereum)
                  ? void 0
                  : l.requestId,
              resources:
                null == (u = null == m ? void 0 : m.signInWithEthereum)
                  ? void 0
                  : u.resources,
            })),
            (f = await h.request({
              method: 'personal_sign',
              params: [
                ((d = p),
                '0x' +
                  Array.from(new TextEncoder().encode(d), (e) =>
                    e.toString(16).padStart(2, '0')
                  ).join('')),
                v,
              ],
            })));
        }
        try {
          let { data: t, error: r } = await nV(
            this.fetch,
            'POST',
            `${this.url}/token?grant_type=web3`,
            {
              headers: this.headers,
              body: Object.assign(
                { chain: 'ethereum', message: p, signature: f },
                (null == (c = e.options) ? void 0 : c.captchaToken)
                  ? {
                      gotrue_meta_security: {
                        captcha_token:
                          null == (h = e.options) ? void 0 : h.captchaToken,
                      },
                    }
                  : null
              ),
              xform: nG,
            }
          );
          if (r) throw r;
          if (!t || !t.session || !t.user) {
            let e = new no();
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          }
          return (
            t.session &&
              (await this._saveSession(t.session),
              await this._notifyAllSubscribers('SIGNED_IN', t.session)),
            this._returnResult({ data: Object.assign({}, t), error: r })
          );
        } catch (e) {
          if (nr(e))
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          throw e;
        }
      }
      async signInWithSolana(e) {
        var t, r, n, i, s, a, o, l, u, c, h, d;
        let p, f;
        if ('message' in e) ((p = e.message), (f = e.signature));
        else {
          let { chain: h, wallet: d, statement: g, options: m } = e;
          if ('object' != typeof d || !(null == m ? void 0 : m.url))
            throw Error(
              '@supabase/auth-js: Both wallet and url must be specified in non-browser environments.'
            );
          let y = new URL(
            null != (t = null == m ? void 0 : m.url) ? t : window.location.href
          );
          if ('signIn' in d && d.signIn) {
            let e,
              t = await d.signIn(
                Object.assign(
                  Object.assign(
                    Object.assign(
                      { issuedAt: new Date().toISOString() },
                      null == m ? void 0 : m.signInWithSolana
                    ),
                    { version: '1', domain: y.host, uri: y.href }
                  ),
                  g ? { statement: g } : null
                )
              );
            if (Array.isArray(t) && t[0] && 'object' == typeof t[0]) e = t[0];
            else if (
              t &&
              'object' == typeof t &&
              'signedMessage' in t &&
              'signature' in t
            )
              e = t;
            else
              throw Error(
                '@supabase/auth-js: Wallet method signIn() returned unrecognized value'
              );
            if (
              'signedMessage' in e &&
              'signature' in e &&
              ('string' == typeof e.signedMessage ||
                e.signedMessage instanceof Uint8Array) &&
              e.signature instanceof Uint8Array
            )
              ((p =
                'string' == typeof e.signedMessage
                  ? e.signedMessage
                  : new TextDecoder().decode(e.signedMessage)),
                (f = e.signature));
            else
              throw Error(
                '@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields'
              );
          } else {
            if (
              !('signMessage' in d) ||
              'function' != typeof d.signMessage ||
              !('publicKey' in d) ||
              'object' != typeof d ||
              !d.publicKey ||
              !('toBase58' in d.publicKey) ||
              'function' != typeof d.publicKey.toBase58
            )
              throw Error(
                '@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API'
              );
            p = [
              `${y.host} wants you to sign in with your Solana account:`,
              d.publicKey.toBase58(),
              ...(g ? ['', g, ''] : ['']),
              'Version: 1',
              `URI: ${y.href}`,
              `Issued At: ${null != (n = null == (r = null == m ? void 0 : m.signInWithSolana) ? void 0 : r.issuedAt) ? n : new Date().toISOString()}`,
              ...((
                null == (i = null == m ? void 0 : m.signInWithSolana)
                  ? void 0
                  : i.notBefore
              )
                ? [`Not Before: ${m.signInWithSolana.notBefore}`]
                : []),
              ...((
                null == (s = null == m ? void 0 : m.signInWithSolana)
                  ? void 0
                  : s.expirationTime
              )
                ? [`Expiration Time: ${m.signInWithSolana.expirationTime}`]
                : []),
              ...((
                null == (a = null == m ? void 0 : m.signInWithSolana)
                  ? void 0
                  : a.chainId
              )
                ? [`Chain ID: ${m.signInWithSolana.chainId}`]
                : []),
              ...((
                null == (o = null == m ? void 0 : m.signInWithSolana)
                  ? void 0
                  : o.nonce
              )
                ? [`Nonce: ${m.signInWithSolana.nonce}`]
                : []),
              ...((
                null == (l = null == m ? void 0 : m.signInWithSolana)
                  ? void 0
                  : l.requestId
              )
                ? [`Request ID: ${m.signInWithSolana.requestId}`]
                : []),
              ...((
                null ==
                (c =
                  null == (u = null == m ? void 0 : m.signInWithSolana)
                    ? void 0
                    : u.resources)
                  ? void 0
                  : c.length
              )
                ? [
                    'Resources',
                    ...m.signInWithSolana.resources.map((e) => `- ${e}`),
                  ]
                : []),
            ].join('\n');
            let e = await d.signMessage(new TextEncoder().encode(p), 'utf8');
            if (!e || !(e instanceof Uint8Array))
              throw Error(
                '@supabase/auth-js: Wallet signMessage() API returned an recognized value'
              );
            f = e;
          }
        }
        try {
          let { data: t, error: r } = await nV(
            this.fetch,
            'POST',
            `${this.url}/token?grant_type=web3`,
            {
              headers: this.headers,
              body: Object.assign(
                { chain: 'solana', message: p, signature: nE(f) },
                (null == (h = e.options) ? void 0 : h.captchaToken)
                  ? {
                      gotrue_meta_security: {
                        captcha_token:
                          null == (d = e.options) ? void 0 : d.captchaToken,
                      },
                    }
                  : null
              ),
              xform: nG,
            }
          );
          if (r) throw r;
          if (!t || !t.session || !t.user) {
            let e = new no();
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          }
          return (
            t.session &&
              (await this._saveSession(t.session),
              await this._notifyAllSubscribers('SIGNED_IN', t.session)),
            this._returnResult({ data: Object.assign({}, t), error: r })
          );
        } catch (e) {
          if (nr(e))
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          throw e;
        }
      }
      async _exchangeCodeForSession(e) {
        let t = await nO(this.storage, `${this.storageKey}-code-verifier`),
          [r, n] = (null != t ? t : '').split('/');
        try {
          if (!r && 'pkce' === this.flowType) throw new nc();
          let { data: t, error: i } = await nV(
            this.fetch,
            'POST',
            `${this.url}/token?grant_type=pkce`,
            {
              headers: this.headers,
              body: { auth_code: e, code_verifier: r },
              xform: nG,
            }
          );
          if ((await nT(this.storage, `${this.storageKey}-code-verifier`), i))
            throw i;
          if (!t || !t.session || !t.user) {
            let e = new no();
            return this._returnResult({
              data: { user: null, session: null, redirectType: null },
              error: e,
            });
          }
          return (
            t.session &&
              (await this._saveSession(t.session),
              await this._notifyAllSubscribers('SIGNED_IN', t.session)),
            this._returnResult({
              data: Object.assign(Object.assign({}, t), {
                redirectType: null != n ? n : null,
              }),
              error: i,
            })
          );
        } catch (e) {
          if (
            (await nT(this.storage, `${this.storageKey}-code-verifier`), nr(e))
          )
            return this._returnResult({
              data: { user: null, session: null, redirectType: null },
              error: e,
            });
          throw e;
        }
      }
      async signInWithIdToken(e) {
        try {
          let {
              options: t,
              provider: r,
              token: n,
              access_token: i,
              nonce: s,
            } = e,
            { data: a, error: o } = await nV(
              this.fetch,
              'POST',
              `${this.url}/token?grant_type=id_token`,
              {
                headers: this.headers,
                body: {
                  provider: r,
                  id_token: n,
                  access_token: i,
                  nonce: s,
                  gotrue_meta_security: {
                    captcha_token: null == t ? void 0 : t.captchaToken,
                  },
                },
                xform: nG,
              }
            );
          if (o)
            return this._returnResult({
              data: { user: null, session: null },
              error: o,
            });
          if (!a || !a.session || !a.user) {
            let e = new no();
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          }
          return (
            a.session &&
              (await this._saveSession(a.session),
              await this._notifyAllSubscribers('SIGNED_IN', a.session)),
            this._returnResult({ data: a, error: o })
          );
        } catch (e) {
          if (nr(e))
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          throw e;
        }
      }
      async signInWithOtp(e) {
        var t, r, n, i, s;
        try {
          if ('email' in e) {
            let { email: n, options: i } = e,
              s = null,
              a = null;
            'pkce' === this.flowType &&
              ([s, a] = await nN(this.storage, this.storageKey));
            let { error: o } = await nV(this.fetch, 'POST', `${this.url}/otp`, {
              headers: this.headers,
              body: {
                email: n,
                data: null != (t = null == i ? void 0 : i.data) ? t : {},
                create_user:
                  null == (r = null == i ? void 0 : i.shouldCreateUser) || r,
                gotrue_meta_security: {
                  captcha_token: null == i ? void 0 : i.captchaToken,
                },
                code_challenge: s,
                code_challenge_method: a,
              },
              redirectTo: null == i ? void 0 : i.emailRedirectTo,
            });
            return this._returnResult({
              data: { user: null, session: null },
              error: o,
            });
          }
          if ('phone' in e) {
            let { phone: t, options: r } = e,
              { data: a, error: o } = await nV(
                this.fetch,
                'POST',
                `${this.url}/otp`,
                {
                  headers: this.headers,
                  body: {
                    phone: t,
                    data: null != (n = null == r ? void 0 : r.data) ? n : {},
                    create_user:
                      null == (i = null == r ? void 0 : r.shouldCreateUser) ||
                      i,
                    gotrue_meta_security: {
                      captcha_token: null == r ? void 0 : r.captchaToken,
                    },
                    channel:
                      null != (s = null == r ? void 0 : r.channel) ? s : 'sms',
                  },
                }
              );
            return this._returnResult({
              data: {
                user: null,
                session: null,
                messageId: null == a ? void 0 : a.message_id,
              },
              error: o,
            });
          }
          throw new nl('You must provide either an email or phone number.');
        } catch (e) {
          if (
            (await nT(this.storage, `${this.storageKey}-code-verifier`), nr(e))
          )
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          throw e;
        }
      }
      async verifyOtp(e) {
        var t, r;
        try {
          let n, i;
          'options' in e &&
            ((n = null == (t = e.options) ? void 0 : t.redirectTo),
            (i = null == (r = e.options) ? void 0 : r.captchaToken));
          let { data: s, error: a } = await nV(
            this.fetch,
            'POST',
            `${this.url}/verify`,
            {
              headers: this.headers,
              body: Object.assign(Object.assign({}, e), {
                gotrue_meta_security: { captcha_token: i },
              }),
              redirectTo: n,
              xform: nG,
            }
          );
          if (a) throw a;
          if (!s) throw Error('An error occurred on token verification.');
          let o = s.session,
            l = s.user;
          return (
            (null == o ? void 0 : o.access_token) &&
              (await this._saveSession(o),
              await this._notifyAllSubscribers(
                'recovery' == e.type ? 'PASSWORD_RECOVERY' : 'SIGNED_IN',
                o
              )),
            this._returnResult({ data: { user: l, session: o }, error: null })
          );
        } catch (e) {
          if (nr(e))
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          throw e;
        }
      }
      async signInWithSSO(e) {
        var t, r, n, i;
        try {
          let s = null,
            a = null;
          'pkce' === this.flowType &&
            ([s, a] = await nN(this.storage, this.storageKey));
          let o = await nV(this.fetch, 'POST', `${this.url}/sso`, {
            body: Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign(
                    Object.assign(
                      {},
                      'providerId' in e ? { provider_id: e.providerId } : null
                    ),
                    'domain' in e ? { domain: e.domain } : null
                  ),
                  {
                    redirect_to:
                      null !=
                      (r = null == (t = e.options) ? void 0 : t.redirectTo)
                        ? r
                        : void 0,
                  }
                ),
                (
                  null == (n = null == e ? void 0 : e.options)
                    ? void 0
                    : n.captchaToken
                )
                  ? {
                      gotrue_meta_security: {
                        captcha_token: e.options.captchaToken,
                      },
                    }
                  : null
              ),
              {
                skip_http_redirect: !0,
                code_challenge: s,
                code_challenge_method: a,
              }
            ),
            headers: this.headers,
            xform: nz,
          });
          return (null == (i = o.data) || i.url, this._returnResult(o));
        } catch (e) {
          if (
            (await nT(this.storage, `${this.storageKey}-code-verifier`), nr(e))
          )
            return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
      async reauthenticate() {
        return (
          await this.initializePromise,
          await this._acquireLock(
            this.lockAcquireTimeout,
            async () => await this._reauthenticate()
          )
        );
      }
      async _reauthenticate() {
        try {
          return await this._useSession(async (e) => {
            let {
              data: { session: t },
              error: r,
            } = e;
            if (r) throw r;
            if (!t) throw new na();
            let { error: n } = await nV(
              this.fetch,
              'GET',
              `${this.url}/reauthenticate`,
              { headers: this.headers, jwt: t.access_token }
            );
            return this._returnResult({
              data: { user: null, session: null },
              error: n,
            });
          });
        } catch (e) {
          if (nr(e))
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          throw e;
        }
      }
      async resend(e) {
        try {
          let t = `${this.url}/resend`;
          if ('email' in e) {
            let { email: r, type: n, options: i } = e,
              { error: s } = await nV(this.fetch, 'POST', t, {
                headers: this.headers,
                body: {
                  email: r,
                  type: n,
                  gotrue_meta_security: {
                    captcha_token: null == i ? void 0 : i.captchaToken,
                  },
                },
                redirectTo: null == i ? void 0 : i.emailRedirectTo,
              });
            return this._returnResult({
              data: { user: null, session: null },
              error: s,
            });
          }
          if ('phone' in e) {
            let { phone: r, type: n, options: i } = e,
              { data: s, error: a } = await nV(this.fetch, 'POST', t, {
                headers: this.headers,
                body: {
                  phone: r,
                  type: n,
                  gotrue_meta_security: {
                    captcha_token: null == i ? void 0 : i.captchaToken,
                  },
                },
              });
            return this._returnResult({
              data: {
                user: null,
                session: null,
                messageId: null == s ? void 0 : s.message_id,
              },
              error: a,
            });
          }
          throw new nl(
            'You must provide either an email or phone number and a type'
          );
        } catch (e) {
          if (nr(e))
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          throw e;
        }
      }
      async getSession() {
        return (
          await this.initializePromise,
          await this._acquireLock(this.lockAcquireTimeout, async () =>
            this._useSession(async (e) => e)
          )
        );
      }
      async _acquireLock(e, t) {
        this._debug('#_acquireLock', 'begin', e);
        try {
          if (this.lockAcquired) {
            let e = this.pendingInLock.length
                ? this.pendingInLock[this.pendingInLock.length - 1]
                : Promise.resolve(),
              r = (async () => (await e, await t()))();
            return (
              this.pendingInLock.push(
                (async () => {
                  try {
                    await r;
                  } catch (e) {}
                })()
              ),
              r
            );
          }
          return await this.lock(`lock:${this.storageKey}`, e, async () => {
            this._debug(
              '#_acquireLock',
              'lock acquired for storage key',
              this.storageKey
            );
            try {
              this.lockAcquired = !0;
              let e = t();
              for (
                this.pendingInLock.push(
                  (async () => {
                    try {
                      await e;
                    } catch (e) {}
                  })()
                ),
                  await e;
                this.pendingInLock.length;
              ) {
                let e = [...this.pendingInLock];
                (await Promise.all(e), this.pendingInLock.splice(0, e.length));
              }
              return await e;
            } finally {
              (this._debug(
                '#_acquireLock',
                'lock released for storage key',
                this.storageKey
              ),
                (this.lockAcquired = !1));
            }
          });
        } finally {
          this._debug('#_acquireLock', 'end');
        }
      }
      async _useSession(e) {
        this._debug('#_useSession', 'begin');
        try {
          let t = await this.__loadSession();
          return await e(t);
        } finally {
          this._debug('#_useSession', 'end');
        }
      }
      async __loadSession() {
        (this._debug('#__loadSession()', 'begin'),
          this.lockAcquired ||
            this._debug(
              '#__loadSession()',
              'used outside of an acquired lock!',
              Error().stack
            ));
        try {
          let t = null,
            r = await nO(this.storage, this.storageKey);
          if (
            (this._debug('#getSession()', 'session from storage', r),
            null !== r &&
              (this._isValidSession(r)
                ? (t = r)
                : (this._debug(
                    '#getSession()',
                    'session from storage is not valid'
                  ),
                  await this._removeSession())),
            !t)
          )
            return { data: { session: null }, error: null };
          let n = !!t.expires_at && 1e3 * t.expires_at - Date.now() < 9e4;
          if (
            (this._debug(
              '#__loadSession()',
              `session has${n ? '' : ' not'} expired`,
              'expires_at',
              t.expires_at
            ),
            !n)
          ) {
            if (this.userStorage) {
              let e = await nO(this.userStorage, this.storageKey + '-user');
              (null == e ? void 0 : e.user)
                ? (t.user = e.user)
                : (t.user = nL());
            }
            if (
              this.storage.isServer &&
              t.user &&
              !t.user.__isUserNotAvailableProxy
            ) {
              var e;
              let r = { value: this.suppressGetSessionWarning };
              ((t.user =
                ((e = t.user),
                new Proxy(e, {
                  get: (e, t, n) => {
                    if ('__isInsecureUserWarningProxy' === t) return !0;
                    if ('symbol' == typeof t) {
                      let r = t.toString();
                      if (
                        'Symbol(Symbol.toPrimitive)' === r ||
                        'Symbol(Symbol.toStringTag)' === r ||
                        'Symbol(util.inspect.custom)' === r ||
                        'Symbol(nodejs.util.inspect.custom)' === r
                      )
                        return Reflect.get(e, t, n);
                    }
                    return (
                      r.value ||
                        'string' != typeof t ||
                        (console.warn(
                          'Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.'
                        ),
                        (r.value = !0)),
                      Reflect.get(e, t, n)
                    );
                  },
                }))),
                r.value && (this.suppressGetSessionWarning = !0));
            }
            return { data: { session: t }, error: null };
          }
          let { data: i, error: s } = await this._callRefreshToken(
            t.refresh_token
          );
          if (s)
            return this._returnResult({ data: { session: null }, error: s });
          return this._returnResult({ data: { session: i }, error: null });
        } finally {
          this._debug('#__loadSession()', 'end');
        }
      }
      async getUser(e) {
        if (e) return await this._getUser(e);
        await this.initializePromise;
        let t = await this._acquireLock(
          this.lockAcquireTimeout,
          async () => await this._getUser()
        );
        return (t.data.user && (this.suppressGetSessionWarning = !0), t);
      }
      async _getUser(e) {
        try {
          if (e)
            return await nV(this.fetch, 'GET', `${this.url}/user`, {
              headers: this.headers,
              jwt: e,
              xform: nF,
            });
          return await this._useSession(async (e) => {
            var t, r, n;
            let { data: i, error: s } = e;
            if (s) throw s;
            return (null == (t = i.session) ? void 0 : t.access_token) ||
              this.hasCustomAuthorizationHeader
              ? await nV(this.fetch, 'GET', `${this.url}/user`, {
                  headers: this.headers,
                  jwt:
                    null !=
                    (n = null == (r = i.session) ? void 0 : r.access_token)
                      ? n
                      : void 0,
                  xform: nF,
                })
              : { data: { user: null }, error: new na() };
          });
        } catch (e) {
          if (nr(e))
            return (
              nr(e) &&
                'AuthSessionMissingError' === e.name &&
                (await this._removeSession(),
                await nT(this.storage, `${this.storageKey}-code-verifier`)),
              this._returnResult({ data: { user: null }, error: e })
            );
          throw e;
        }
      }
      async updateUser(e, t = {}) {
        return (
          await this.initializePromise,
          await this._acquireLock(
            this.lockAcquireTimeout,
            async () => await this._updateUser(e, t)
          )
        );
      }
      async _updateUser(e, t = {}) {
        try {
          return await this._useSession(async (r) => {
            let { data: n, error: i } = r;
            if (i) throw i;
            if (!n.session) throw new na();
            let s = n.session,
              a = null,
              o = null;
            'pkce' === this.flowType &&
              null != e.email &&
              ([a, o] = await nN(this.storage, this.storageKey));
            let { data: l, error: u } = await nV(
              this.fetch,
              'PUT',
              `${this.url}/user`,
              {
                headers: this.headers,
                redirectTo: null == t ? void 0 : t.emailRedirectTo,
                body: Object.assign(Object.assign({}, e), {
                  code_challenge: a,
                  code_challenge_method: o,
                }),
                jwt: s.access_token,
                xform: nF,
              }
            );
            if (u) throw u;
            return (
              (s.user = l.user),
              await this._saveSession(s),
              await this._notifyAllSubscribers('USER_UPDATED', s),
              this._returnResult({ data: { user: s.user }, error: null })
            );
          });
        } catch (e) {
          if (
            (await nT(this.storage, `${this.storageKey}-code-verifier`), nr(e))
          )
            return this._returnResult({ data: { user: null }, error: e });
          throw e;
        }
      }
      async setSession(e) {
        return (
          await this.initializePromise,
          await this._acquireLock(
            this.lockAcquireTimeout,
            async () => await this._setSession(e)
          )
        );
      }
      async _setSession(e) {
        try {
          if (!e.access_token || !e.refresh_token) throw new na();
          let t = Date.now() / 1e3,
            r = t,
            n = !0,
            i = null,
            { payload: s } = nP(e.access_token);
          if ((s.exp && (n = (r = s.exp) <= t), n)) {
            let { data: t, error: r } = await this._callRefreshToken(
              e.refresh_token
            );
            if (r)
              return this._returnResult({
                data: { user: null, session: null },
                error: r,
              });
            if (!t) return { data: { user: null, session: null }, error: null };
            i = t;
          } else {
            let { data: n, error: s } = await this._getUser(e.access_token);
            if (s) throw s;
            ((i = {
              access_token: e.access_token,
              refresh_token: e.refresh_token,
              user: n.user,
              token_type: 'bearer',
              expires_in: r - t,
              expires_at: r,
            }),
              await this._saveSession(i),
              await this._notifyAllSubscribers('SIGNED_IN', i));
          }
          return this._returnResult({
            data: { user: i.user, session: i },
            error: null,
          });
        } catch (e) {
          if (nr(e))
            return this._returnResult({
              data: { session: null, user: null },
              error: e,
            });
          throw e;
        }
      }
      async refreshSession(e) {
        return (
          await this.initializePromise,
          await this._acquireLock(
            this.lockAcquireTimeout,
            async () => await this._refreshSession(e)
          )
        );
      }
      async _refreshSession(e) {
        try {
          return await this._useSession(async (t) => {
            var r;
            if (!e) {
              let { data: n, error: i } = t;
              if (i) throw i;
              e = null != (r = n.session) ? r : void 0;
            }
            if (!(null == e ? void 0 : e.refresh_token)) throw new na();
            let { data: n, error: i } = await this._callRefreshToken(
              e.refresh_token
            );
            return i
              ? this._returnResult({
                  data: { user: null, session: null },
                  error: i,
                })
              : n
                ? this._returnResult({
                    data: { user: n.user, session: n },
                    error: null,
                  })
                : this._returnResult({
                    data: { user: null, session: null },
                    error: null,
                  });
          });
        } catch (e) {
          if (nr(e))
            return this._returnResult({
              data: { user: null, session: null },
              error: e,
            });
          throw e;
        }
      }
      async _getSessionFromURL(e, t) {
        try {
          throw new nu('No browser detected.');
        } catch (e) {
          if (nr(e))
            return this._returnResult({
              data: { session: null, redirectType: null },
              error: e,
            });
          throw e;
        }
      }
      _isImplicitGrantCallback(e) {
        return 'function' == typeof this.detectSessionInUrl
          ? this.detectSessionInUrl(new URL(window.location.href), e)
          : !!(e.access_token || e.error_description);
      }
      async _isPKCECallback(e) {
        let t = await nO(this.storage, `${this.storageKey}-code-verifier`);
        return !!(e.code && t);
      }
      async signOut(e = { scope: 'global' }) {
        return (
          await this.initializePromise,
          await this._acquireLock(
            this.lockAcquireTimeout,
            async () => await this._signOut(e)
          )
        );
      }
      async _signOut({ scope: e } = { scope: 'global' }) {
        return await this._useSession(async (t) => {
          var r;
          let { data: n, error: i } = t;
          if (i) return this._returnResult({ error: i });
          let s = null == (r = n.session) ? void 0 : r.access_token;
          if (s) {
            let { error: t } = await this.admin.signOut(s, e);
            if (
              t &&
              !(
                nr(t) &&
                'AuthApiError' === t.name &&
                (404 === t.status || 401 === t.status || 403 === t.status)
              )
            )
              return this._returnResult({ error: t });
          }
          return (
            'others' !== e &&
              (await this._removeSession(),
              await nT(this.storage, `${this.storageKey}-code-verifier`)),
            this._returnResult({ error: null })
          );
        });
      }
      onAuthStateChange(e) {
        let t = Symbol('auth-callback'),
          r = {
            id: t,
            callback: e,
            unsubscribe: () => {
              (this._debug(
                '#unsubscribe()',
                'state change callback with id removed',
                t
              ),
                this.stateChangeEmitters.delete(t));
            },
          };
        return (
          this._debug('#onAuthStateChange()', 'registered callback with id', t),
          this.stateChangeEmitters.set(t, r),
          (async () => {
            (await this.initializePromise,
              await this._acquireLock(this.lockAcquireTimeout, async () => {
                this._emitInitialSession(t);
              }));
          })(),
          { data: { subscription: r } }
        );
      }
      async _emitInitialSession(e) {
        return await this._useSession(async (t) => {
          var r, n;
          try {
            let {
              data: { session: n },
              error: i,
            } = t;
            if (i) throw i;
            (await (null == (r = this.stateChangeEmitters.get(e))
              ? void 0
              : r.callback('INITIAL_SESSION', n)),
              this._debug('INITIAL_SESSION', 'callback id', e, 'session', n));
          } catch (t) {
            (await (null == (n = this.stateChangeEmitters.get(e))
              ? void 0
              : n.callback('INITIAL_SESSION', null)),
              this._debug('INITIAL_SESSION', 'callback id', e, 'error', t),
              console.error(t));
          }
        });
      }
      async resetPasswordForEmail(e, t = {}) {
        let r = null,
          n = null;
        'pkce' === this.flowType &&
          ([r, n] = await nN(this.storage, this.storageKey, !0));
        try {
          return await nV(this.fetch, 'POST', `${this.url}/recover`, {
            body: {
              email: e,
              code_challenge: r,
              code_challenge_method: n,
              gotrue_meta_security: { captcha_token: t.captchaToken },
            },
            headers: this.headers,
            redirectTo: t.redirectTo,
          });
        } catch (e) {
          if (
            (await nT(this.storage, `${this.storageKey}-code-verifier`), nr(e))
          )
            return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
      async getUserIdentities() {
        var e;
        try {
          let { data: t, error: r } = await this.getUser();
          if (r) throw r;
          return this._returnResult({
            data: { identities: null != (e = t.user.identities) ? e : [] },
            error: null,
          });
        } catch (e) {
          if (nr(e)) return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
      async linkIdentity(e) {
        return 'token' in e
          ? this.linkIdentityIdToken(e)
          : this.linkIdentityOAuth(e);
      }
      async linkIdentityOAuth(e) {
        try {
          let { data: t, error: r } = await this._useSession(async (t) => {
            var r, n, i, s, a;
            let { data: o, error: l } = t;
            if (l) throw l;
            let u = await this._getUrlForProvider(
              `${this.url}/user/identities/authorize`,
              e.provider,
              {
                redirectTo: null == (r = e.options) ? void 0 : r.redirectTo,
                scopes: null == (n = e.options) ? void 0 : n.scopes,
                queryParams: null == (i = e.options) ? void 0 : i.queryParams,
                skipBrowserRedirect: !0,
              }
            );
            return await nV(this.fetch, 'GET', u, {
              headers: this.headers,
              jwt:
                null != (a = null == (s = o.session) ? void 0 : s.access_token)
                  ? a
                  : void 0,
            });
          });
          if (r) throw r;
          return this._returnResult({
            data: { provider: e.provider, url: null == t ? void 0 : t.url },
            error: null,
          });
        } catch (t) {
          if (nr(t))
            return this._returnResult({
              data: { provider: e.provider, url: null },
              error: t,
            });
          throw t;
        }
      }
      async linkIdentityIdToken(e) {
        return await this._useSession(async (t) => {
          var r;
          try {
            let {
              error: n,
              data: { session: i },
            } = t;
            if (n) throw n;
            let {
                options: s,
                provider: a,
                token: o,
                access_token: l,
                nonce: u,
              } = e,
              { data: c, error: h } = await nV(
                this.fetch,
                'POST',
                `${this.url}/token?grant_type=id_token`,
                {
                  headers: this.headers,
                  jwt:
                    null != (r = null == i ? void 0 : i.access_token)
                      ? r
                      : void 0,
                  body: {
                    provider: a,
                    id_token: o,
                    access_token: l,
                    nonce: u,
                    link_identity: !0,
                    gotrue_meta_security: {
                      captcha_token: null == s ? void 0 : s.captchaToken,
                    },
                  },
                  xform: nG,
                }
              );
            if (h)
              return this._returnResult({
                data: { user: null, session: null },
                error: h,
              });
            if (!c || !c.session || !c.user)
              return this._returnResult({
                data: { user: null, session: null },
                error: new no(),
              });
            return (
              c.session &&
                (await this._saveSession(c.session),
                await this._notifyAllSubscribers('USER_UPDATED', c.session)),
              this._returnResult({ data: c, error: h })
            );
          } catch (e) {
            if (
              (await nT(this.storage, `${this.storageKey}-code-verifier`),
              nr(e))
            )
              return this._returnResult({
                data: { user: null, session: null },
                error: e,
              });
            throw e;
          }
        });
      }
      async unlinkIdentity(e) {
        try {
          return await this._useSession(async (t) => {
            var r, n;
            let { data: i, error: s } = t;
            if (s) throw s;
            return await nV(
              this.fetch,
              'DELETE',
              `${this.url}/user/identities/${e.identity_id}`,
              {
                headers: this.headers,
                jwt:
                  null !=
                  (n = null == (r = i.session) ? void 0 : r.access_token)
                    ? n
                    : void 0,
              }
            );
          });
        } catch (e) {
          if (nr(e)) return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
      async _refreshAccessToken(e) {
        let t = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
        this._debug(t, 'begin');
        try {
          var r, n;
          let i = Date.now();
          return await ((r = async (r) => (
            r > 0 && (await nx(200 * Math.pow(2, r - 1))),
            this._debug(t, 'refreshing attempt', r),
            await nV(
              this.fetch,
              'POST',
              `${this.url}/token?grant_type=refresh_token`,
              { body: { refresh_token: e }, headers: this.headers, xform: nG }
            )
          )),
          (n = (e, t) => {
            let r = 200 * Math.pow(2, e);
            return t && nd(t) && Date.now() + r - i < 3e4;
          }),
          new Promise((e, t) => {
            (async () => {
              for (let i = 0; i < 1 / 0; i++)
                try {
                  let t = await r(i);
                  if (!n(i, null, t)) return void e(t);
                } catch (e) {
                  if (!n(i, e)) return void t(e);
                }
            })();
          }));
        } catch (e) {
          if ((this._debug(t, 'error', e), nr(e)))
            return this._returnResult({
              data: { session: null, user: null },
              error: e,
            });
          throw e;
        } finally {
          this._debug(t, 'end');
        }
      }
      _isValidSession(e) {
        return (
          'object' == typeof e &&
          null !== e &&
          'access_token' in e &&
          'refresh_token' in e &&
          'expires_at' in e
        );
      }
      async _handleProviderSignIn(e, t) {
        let r = await this._getUrlForProvider(`${this.url}/authorize`, e, {
          redirectTo: t.redirectTo,
          scopes: t.scopes,
          queryParams: t.queryParams,
        });
        return (
          this._debug(
            '#_handleProviderSignIn()',
            'provider',
            e,
            'options',
            t,
            'url',
            r
          ),
          { data: { provider: e, url: r }, error: null }
        );
      }
      async _recoverAndRefresh() {
        var e, t;
        let r = '#_recoverAndRefresh()';
        this._debug(r, 'begin');
        try {
          let n = await nO(this.storage, this.storageKey);
          if (n && this.userStorage) {
            let t = await nO(this.userStorage, this.storageKey + '-user');
            (!this.storage.isServer &&
              Object.is(this.storage, this.userStorage) &&
              !t &&
              ((t = { user: n.user }),
              await nR(this.userStorage, this.storageKey + '-user', t)),
              (n.user = null != (e = null == t ? void 0 : t.user) ? e : nL()));
          } else if (n && !n.user && !n.user) {
            let e = await nO(this.storage, this.storageKey + '-user');
            e && (null == e ? void 0 : e.user)
              ? ((n.user = e.user),
                await nT(this.storage, this.storageKey + '-user'),
                await nR(this.storage, this.storageKey, n))
              : (n.user = nL());
          }
          if (
            (this._debug(r, 'session from storage', n),
            !this._isValidSession(n))
          ) {
            (this._debug(r, 'session is not valid'),
              null !== n && (await this._removeSession()));
            return;
          }
          let i =
            (null != (t = n.expires_at) ? t : 1 / 0) * 1e3 - Date.now() < 9e4;
          if (
            (this._debug(
              r,
              `session has${i ? '' : ' not'} expired with margin of 90000s`
            ),
            i)
          ) {
            if (this.autoRefreshToken && n.refresh_token) {
              let { error: e } = await this._callRefreshToken(n.refresh_token);
              e &&
                (console.error(e),
                nd(e) ||
                  (this._debug(
                    r,
                    'refresh failed with a non-retryable error, removing the session',
                    e
                  ),
                  await this._removeSession()));
            }
          } else if (n.user && !0 === n.user.__isUserNotAvailableProxy)
            try {
              let { data: e, error: t } = await this._getUser(n.access_token);
              !t && (null == e ? void 0 : e.user)
                ? ((n.user = e.user),
                  await this._saveSession(n),
                  await this._notifyAllSubscribers('SIGNED_IN', n))
                : this._debug(
                    r,
                    'could not get user data, skipping SIGNED_IN notification'
                  );
            } catch (e) {
              (console.error('Error getting user data:', e),
                this._debug(
                  r,
                  'error getting user data, skipping SIGNED_IN notification',
                  e
                ));
            }
          else await this._notifyAllSubscribers('SIGNED_IN', n);
        } catch (e) {
          (this._debug(r, 'error', e), console.error(e));
          return;
        } finally {
          this._debug(r, 'end');
        }
      }
      async _callRefreshToken(e) {
        var t, r;
        if (!e) throw new na();
        if (this.refreshingDeferred) return this.refreshingDeferred.promise;
        let n = `#_callRefreshToken(${e.substring(0, 5)}...)`;
        this._debug(n, 'begin');
        try {
          this.refreshingDeferred = new nk();
          let { data: t, error: r } = await this._refreshAccessToken(e);
          if (r) throw r;
          if (!t.session) throw new na();
          (await this._saveSession(t.session),
            await this._notifyAllSubscribers('TOKEN_REFRESHED', t.session));
          let n = { data: t.session, error: null };
          return (this.refreshingDeferred.resolve(n), n);
        } catch (e) {
          if ((this._debug(n, 'error', e), nr(e))) {
            let r = { data: null, error: e };
            return (
              nd(e) || (await this._removeSession()),
              null == (t = this.refreshingDeferred) || t.resolve(r),
              r
            );
          }
          throw (null == (r = this.refreshingDeferred) || r.reject(e), e);
        } finally {
          ((this.refreshingDeferred = null), this._debug(n, 'end'));
        }
      }
      async _notifyAllSubscribers(e, t, r = !0) {
        let n = `#_notifyAllSubscribers(${e})`;
        this._debug(n, 'begin', t, `broadcast = ${r}`);
        try {
          this.broadcastChannel &&
            r &&
            this.broadcastChannel.postMessage({ event: e, session: t });
          let n = [],
            i = Array.from(this.stateChangeEmitters.values()).map(async (r) => {
              try {
                await r.callback(e, t);
              } catch (e) {
                n.push(e);
              }
            });
          if ((await Promise.all(i), n.length > 0)) {
            for (let e = 0; e < n.length; e += 1) console.error(n[e]);
            throw n[0];
          }
        } finally {
          this._debug(n, 'end');
        }
      }
      async _saveSession(e) {
        (this._debug('#_saveSession()', e),
          (this.suppressGetSessionWarning = !0),
          await nT(this.storage, `${this.storageKey}-code-verifier`));
        let t = Object.assign({}, e),
          r = t.user && !0 === t.user.__isUserNotAvailableProxy;
        if (this.userStorage) {
          !r &&
            t.user &&
            (await nR(this.userStorage, this.storageKey + '-user', {
              user: t.user,
            }));
          let e = Object.assign({}, t);
          delete e.user;
          let n = nU(e);
          await nR(this.storage, this.storageKey, n);
        } else {
          let e = nU(t);
          await nR(this.storage, this.storageKey, e);
        }
      }
      async _removeSession() {
        (this._debug('#_removeSession()'),
          (this.suppressGetSessionWarning = !1),
          await nT(this.storage, this.storageKey),
          await nT(this.storage, this.storageKey + '-code-verifier'),
          await nT(this.storage, this.storageKey + '-user'),
          this.userStorage &&
            (await nT(this.userStorage, this.storageKey + '-user')),
          await this._notifyAllSubscribers('SIGNED_OUT', null));
      }
      _removeVisibilityChangedCallback() {
        (this._debug('#_removeVisibilityChangedCallback()'),
          this.visibilityChangedCallback,
          (this.visibilityChangedCallback = null));
      }
      async _startAutoRefresh() {
        (await this._stopAutoRefresh(), this._debug('#_startAutoRefresh()'));
        let e = setInterval(() => this._autoRefreshTokenTick(), 3e4);
        ((this.autoRefreshTicker = e),
          e && 'object' == typeof e && 'function' == typeof e.unref
            ? e.unref()
            : 'u' > typeof Deno &&
              'function' == typeof Deno.unrefTimer &&
              Deno.unrefTimer(e));
        let t = setTimeout(async () => {
          (await this.initializePromise, await this._autoRefreshTokenTick());
        }, 0);
        ((this.autoRefreshTickTimeout = t),
          t && 'object' == typeof t && 'function' == typeof t.unref
            ? t.unref()
            : 'u' > typeof Deno &&
              'function' == typeof Deno.unrefTimer &&
              Deno.unrefTimer(t));
      }
      async _stopAutoRefresh() {
        this._debug('#_stopAutoRefresh()');
        let e = this.autoRefreshTicker;
        ((this.autoRefreshTicker = null), e && clearInterval(e));
        let t = this.autoRefreshTickTimeout;
        ((this.autoRefreshTickTimeout = null), t && clearTimeout(t));
      }
      async startAutoRefresh() {
        (this._removeVisibilityChangedCallback(),
          await this._startAutoRefresh());
      }
      async stopAutoRefresh() {
        (this._removeVisibilityChangedCallback(),
          await this._stopAutoRefresh());
      }
      async _autoRefreshTokenTick() {
        this._debug('#_autoRefreshTokenTick()', 'begin');
        try {
          await this._acquireLock(0, async () => {
            try {
              let e = Date.now();
              try {
                return await this._useSession(async (t) => {
                  let {
                    data: { session: r },
                  } = t;
                  if (!r || !r.refresh_token || !r.expires_at)
                    return void this._debug(
                      '#_autoRefreshTokenTick()',
                      'no session'
                    );
                  let n = Math.floor((1e3 * r.expires_at - e) / 3e4);
                  (this._debug(
                    '#_autoRefreshTokenTick()',
                    `access token expires in ${n} ticks, a tick lasts 30000ms, refresh threshold is 3 ticks`
                  ),
                    n <= 3 && (await this._callRefreshToken(r.refresh_token)));
                });
              } catch (e) {
                console.error(
                  'Auto refresh tick failed with error. This is likely a transient error.',
                  e
                );
              }
            } finally {
              this._debug('#_autoRefreshTokenTick()', 'end');
            }
          });
        } catch (e) {
          if (e.isAcquireTimeout || e instanceof nZ)
            this._debug('auto refresh token tick lock not available');
          else throw e;
        }
      }
      async _handleVisibilityChange() {
        return (
          this._debug('#_handleVisibilityChange()'),
          this.autoRefreshToken && this.startAutoRefresh(),
          !1
        );
      }
      async _onVisibilityChanged(e) {
        let t = `#_onVisibilityChanged(${e})`;
        (this._debug(t, 'visibilityState', document.visibilityState),
          'visible' === document.visibilityState
            ? (this.autoRefreshToken && this._startAutoRefresh(),
              e ||
                (await this.initializePromise,
                await this._acquireLock(this.lockAcquireTimeout, async () => {
                  'visible' !== document.visibilityState
                    ? this._debug(
                        t,
                        'acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting'
                      )
                    : await this._recoverAndRefresh();
                })))
            : 'hidden' === document.visibilityState &&
              this.autoRefreshToken &&
              this._stopAutoRefresh());
      }
      async _getUrlForProvider(e, t, r) {
        let n = [`provider=${encodeURIComponent(t)}`];
        if (
          ((null == r ? void 0 : r.redirectTo) &&
            n.push(`redirect_to=${encodeURIComponent(r.redirectTo)}`),
          (null == r ? void 0 : r.scopes) &&
            n.push(`scopes=${encodeURIComponent(r.scopes)}`),
          'pkce' === this.flowType)
        ) {
          let [e, t] = await nN(this.storage, this.storageKey),
            r = new URLSearchParams({
              code_challenge: `${encodeURIComponent(e)}`,
              code_challenge_method: `${encodeURIComponent(t)}`,
            });
          n.push(r.toString());
        }
        if (null == r ? void 0 : r.queryParams) {
          let e = new URLSearchParams(r.queryParams);
          n.push(e.toString());
        }
        return (
          (null == r ? void 0 : r.skipBrowserRedirect) &&
            n.push(`skip_http_redirect=${r.skipBrowserRedirect}`),
          `${e}?${n.join('&')}`
        );
      }
      async _unenroll(e) {
        try {
          return await this._useSession(async (t) => {
            var r;
            let { data: n, error: i } = t;
            return i
              ? this._returnResult({ data: null, error: i })
              : await nV(
                  this.fetch,
                  'DELETE',
                  `${this.url}/factors/${e.factorId}`,
                  {
                    headers: this.headers,
                    jwt:
                      null == (r = null == n ? void 0 : n.session)
                        ? void 0
                        : r.access_token,
                  }
                );
          });
        } catch (e) {
          if (nr(e)) return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
      async _enroll(e) {
        try {
          return await this._useSession(async (t) => {
            var r, n;
            let { data: i, error: s } = t;
            if (s) return this._returnResult({ data: null, error: s });
            let a = Object.assign(
                { friendly_name: e.friendlyName, factor_type: e.factorType },
                'phone' === e.factorType
                  ? { phone: e.phone }
                  : 'totp' === e.factorType
                    ? { issuer: e.issuer }
                    : {}
              ),
              { data: o, error: l } = await nV(
                this.fetch,
                'POST',
                `${this.url}/factors`,
                {
                  body: a,
                  headers: this.headers,
                  jwt:
                    null == (r = null == i ? void 0 : i.session)
                      ? void 0
                      : r.access_token,
                }
              );
            return l
              ? this._returnResult({ data: null, error: l })
              : ('totp' === e.factorType &&
                  'totp' === o.type &&
                  (null == (n = null == o ? void 0 : o.totp)
                    ? void 0
                    : n.qr_code) &&
                  (o.totp.qr_code = `data:image/svg+xml;utf-8,${o.totp.qr_code}`),
                this._returnResult({ data: o, error: null }));
          });
        } catch (e) {
          if (nr(e)) return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
      async _verify(e) {
        return this._acquireLock(this.lockAcquireTimeout, async () => {
          try {
            return await this._useSession(async (t) => {
              var r, n, i;
              let { data: s, error: a } = t;
              if (a) return this._returnResult({ data: null, error: a });
              let o = Object.assign(
                  { challenge_id: e.challengeId },
                  'webauthn' in e
                    ? {
                        webauthn: Object.assign(Object.assign({}, e.webauthn), {
                          credential_response:
                            'create' === e.webauthn.type
                              ? ((n = e.webauthn.credential_response),
                                'toJSON' in n && 'function' == typeof n.toJSON
                                  ? n.toJSON()
                                  : {
                                      id: n.id,
                                      rawId: n.id,
                                      response: {
                                        attestationObject: nE(
                                          new Uint8Array(
                                            n.response.attestationObject
                                          )
                                        ),
                                        clientDataJSON: nE(
                                          new Uint8Array(
                                            n.response.clientDataJSON
                                          )
                                        ),
                                      },
                                      type: 'public-key',
                                      clientExtensionResults:
                                        n.getClientExtensionResults(),
                                      authenticatorAttachment:
                                        null != (i = n.authenticatorAttachment)
                                          ? i
                                          : void 0,
                                    })
                              : (function (e) {
                                  var t;
                                  if (
                                    'toJSON' in e &&
                                    'function' == typeof e.toJSON
                                  )
                                    return e.toJSON();
                                  let r = e.getClientExtensionResults(),
                                    n = e.response;
                                  return {
                                    id: e.id,
                                    rawId: e.id,
                                    response: {
                                      authenticatorData: nE(
                                        new Uint8Array(n.authenticatorData)
                                      ),
                                      clientDataJSON: nE(
                                        new Uint8Array(n.clientDataJSON)
                                      ),
                                      signature: nE(
                                        new Uint8Array(n.signature)
                                      ),
                                      userHandle: n.userHandle
                                        ? nE(new Uint8Array(n.userHandle))
                                        : void 0,
                                    },
                                    type: 'public-key',
                                    clientExtensionResults: r,
                                    authenticatorAttachment:
                                      null != (t = e.authenticatorAttachment)
                                        ? t
                                        : void 0,
                                  };
                                })(e.webauthn.credential_response),
                        }),
                      }
                    : { code: e.code }
                ),
                { data: l, error: u } = await nV(
                  this.fetch,
                  'POST',
                  `${this.url}/factors/${e.factorId}/verify`,
                  {
                    body: o,
                    headers: this.headers,
                    jwt:
                      null == (r = null == s ? void 0 : s.session)
                        ? void 0
                        : r.access_token,
                  }
                );
              return u
                ? this._returnResult({ data: null, error: u })
                : (await this._saveSession(
                    Object.assign(
                      {
                        expires_at: Math.round(Date.now() / 1e3) + l.expires_in,
                      },
                      l
                    )
                  ),
                  await this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', l),
                  this._returnResult({ data: l, error: u }));
            });
          } catch (e) {
            if (nr(e)) return this._returnResult({ data: null, error: e });
            throw e;
          }
        });
      }
      async _challenge(e) {
        return this._acquireLock(this.lockAcquireTimeout, async () => {
          try {
            return await this._useSession(async (t) => {
              var r;
              let { data: n, error: i } = t;
              if (i) return this._returnResult({ data: null, error: i });
              let s = await nV(
                this.fetch,
                'POST',
                `${this.url}/factors/${e.factorId}/challenge`,
                {
                  body: e,
                  headers: this.headers,
                  jwt:
                    null == (r = null == n ? void 0 : n.session)
                      ? void 0
                      : r.access_token,
                }
              );
              if (s.error) return s;
              let { data: a } = s;
              if ('webauthn' !== a.type) return { data: a, error: null };
              switch (a.webauthn.type) {
                case 'create':
                  return {
                    data: Object.assign(Object.assign({}, a), {
                      webauthn: Object.assign(Object.assign({}, a.webauthn), {
                        credential_options: Object.assign(
                          Object.assign({}, a.webauthn.credential_options),
                          {
                            publicKey: (function (e) {
                              if (!e)
                                throw Error(
                                  'Credential creation options are required'
                                );
                              if (
                                'u' > typeof PublicKeyCredential &&
                                'parseCreationOptionsFromJSON' in
                                  PublicKeyCredential &&
                                'function' ==
                                  typeof PublicKeyCredential.parseCreationOptionsFromJSON
                              )
                                return PublicKeyCredential.parseCreationOptionsFromJSON(
                                  e
                                );
                              let {
                                  challenge: t,
                                  user: r,
                                  excludeCredentials: n,
                                } = e,
                                i = tG(e, [
                                  'challenge',
                                  'user',
                                  'excludeCredentials',
                                ]),
                                s = n_(t).buffer,
                                a = Object.assign(Object.assign({}, r), {
                                  id: n_(r.id).buffer,
                                }),
                                o = Object.assign(Object.assign({}, i), {
                                  challenge: s,
                                  user: a,
                                });
                              if (n && n.length > 0) {
                                o.excludeCredentials = Array(n.length);
                                for (let e = 0; e < n.length; e++) {
                                  let t = n[e];
                                  o.excludeCredentials[e] = Object.assign(
                                    Object.assign({}, t),
                                    {
                                      id: n_(t.id).buffer,
                                      type: t.type || 'public-key',
                                      transports: t.transports,
                                    }
                                  );
                                }
                              }
                              return o;
                            })(a.webauthn.credential_options.publicKey),
                          }
                        ),
                      }),
                    }),
                    error: null,
                  };
                case 'request':
                  return {
                    data: Object.assign(Object.assign({}, a), {
                      webauthn: Object.assign(Object.assign({}, a.webauthn), {
                        credential_options: Object.assign(
                          Object.assign({}, a.webauthn.credential_options),
                          {
                            publicKey: (function (e) {
                              if (!e)
                                throw Error(
                                  'Credential request options are required'
                                );
                              if (
                                'u' > typeof PublicKeyCredential &&
                                'parseRequestOptionsFromJSON' in
                                  PublicKeyCredential &&
                                'function' ==
                                  typeof PublicKeyCredential.parseRequestOptionsFromJSON
                              )
                                return PublicKeyCredential.parseRequestOptionsFromJSON(
                                  e
                                );
                              let { challenge: t, allowCredentials: r } = e,
                                n = tG(e, ['challenge', 'allowCredentials']),
                                i = n_(t).buffer,
                                s = Object.assign(Object.assign({}, n), {
                                  challenge: i,
                                });
                              if (r && r.length > 0) {
                                s.allowCredentials = Array(r.length);
                                for (let e = 0; e < r.length; e++) {
                                  let t = r[e];
                                  s.allowCredentials[e] = Object.assign(
                                    Object.assign({}, t),
                                    {
                                      id: n_(t.id).buffer,
                                      type: t.type || 'public-key',
                                      transports: t.transports,
                                    }
                                  );
                                }
                              }
                              return s;
                            })(a.webauthn.credential_options.publicKey),
                          }
                        ),
                      }),
                    }),
                    error: null,
                  };
              }
            });
          } catch (e) {
            if (nr(e)) return this._returnResult({ data: null, error: e });
            throw e;
          }
        });
      }
      async _challengeAndVerify(e) {
        let { data: t, error: r } = await this._challenge({
          factorId: e.factorId,
        });
        return r
          ? this._returnResult({ data: null, error: r })
          : await this._verify({
              factorId: e.factorId,
              challengeId: t.id,
              code: e.code,
            });
      }
      async _listFactors() {
        var e;
        let {
          data: { user: t },
          error: r,
        } = await this.getUser();
        if (r) return { data: null, error: r };
        let n = { all: [], phone: [], totp: [], webauthn: [] };
        for (let r of null != (e = null == t ? void 0 : t.factors) ? e : [])
          (n.all.push(r), 'verified' === r.status && n[r.factor_type].push(r));
        return { data: n, error: null };
      }
      async _getAuthenticatorAssuranceLevel() {
        var e, t;
        let {
          data: { session: r },
          error: n,
        } = await this.getSession();
        if (n) return this._returnResult({ data: null, error: n });
        if (!r)
          return {
            data: {
              currentLevel: null,
              nextLevel: null,
              currentAuthenticationMethods: [],
            },
            error: null,
          };
        let { payload: i } = nP(r.access_token),
          s = null;
        i.aal && (s = i.aal);
        let a = s;
        return (
          (null !=
          (t =
            null == (e = r.user.factors)
              ? void 0
              : e.filter((e) => 'verified' === e.status))
            ? t
            : []
          ).length > 0 && (a = 'aal2'),
          {
            data: {
              currentLevel: s,
              nextLevel: a,
              currentAuthenticationMethods: i.amr || [],
            },
            error: null,
          }
        );
      }
      async _getAuthorizationDetails(e) {
        try {
          return await this._useSession(async (t) => {
            let {
              data: { session: r },
              error: n,
            } = t;
            return n
              ? this._returnResult({ data: null, error: n })
              : r
                ? await nV(
                    this.fetch,
                    'GET',
                    `${this.url}/oauth/authorizations/${e}`,
                    {
                      headers: this.headers,
                      jwt: r.access_token,
                      xform: (e) => ({ data: e, error: null }),
                    }
                  )
                : this._returnResult({ data: null, error: new na() });
          });
        } catch (e) {
          if (nr(e)) return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
      async _approveAuthorization(e, t) {
        try {
          return await this._useSession(async (t) => {
            let {
              data: { session: r },
              error: n,
            } = t;
            if (n) return this._returnResult({ data: null, error: n });
            if (!r) return this._returnResult({ data: null, error: new na() });
            let i = await nV(
              this.fetch,
              'POST',
              `${this.url}/oauth/authorizations/${e}/consent`,
              {
                headers: this.headers,
                jwt: r.access_token,
                body: { action: 'approve' },
                xform: (e) => ({ data: e, error: null }),
              }
            );
            return (i.data && i.data.redirect_url, i);
          });
        } catch (e) {
          if (nr(e)) return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
      async _denyAuthorization(e, t) {
        try {
          return await this._useSession(async (t) => {
            let {
              data: { session: r },
              error: n,
            } = t;
            if (n) return this._returnResult({ data: null, error: n });
            if (!r) return this._returnResult({ data: null, error: new na() });
            let i = await nV(
              this.fetch,
              'POST',
              `${this.url}/oauth/authorizations/${e}/consent`,
              {
                headers: this.headers,
                jwt: r.access_token,
                body: { action: 'deny' },
                xform: (e) => ({ data: e, error: null }),
              }
            );
            return (i.data && i.data.redirect_url, i);
          });
        } catch (e) {
          if (nr(e)) return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
      async _listOAuthGrants() {
        try {
          return await this._useSession(async (e) => {
            let {
              data: { session: t },
              error: r,
            } = e;
            return r
              ? this._returnResult({ data: null, error: r })
              : t
                ? await nV(this.fetch, 'GET', `${this.url}/user/oauth/grants`, {
                    headers: this.headers,
                    jwt: t.access_token,
                    xform: (e) => ({ data: e, error: null }),
                  })
                : this._returnResult({ data: null, error: new na() });
          });
        } catch (e) {
          if (nr(e)) return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
      async _revokeOAuthGrant(e) {
        try {
          return await this._useSession(async (t) => {
            let {
              data: { session: r },
              error: n,
            } = t;
            return n
              ? this._returnResult({ data: null, error: n })
              : r
                ? (await nV(
                    this.fetch,
                    'DELETE',
                    `${this.url}/user/oauth/grants`,
                    {
                      headers: this.headers,
                      jwt: r.access_token,
                      query: { client_id: e.clientId },
                      noResolveJson: !0,
                    }
                  ),
                  { data: {}, error: null })
                : this._returnResult({ data: null, error: new na() });
          });
        } catch (e) {
          if (nr(e)) return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
      async fetchJwk(e, t = { keys: [] }) {
        let r = t.keys.find((t) => t.kid === e);
        if (r) return r;
        let n = Date.now();
        if (
          (r = this.jwks.keys.find((t) => t.kid === e)) &&
          this.jwks_cached_at + 6e5 > n
        )
          return r;
        let { data: i, error: s } = await nV(
          this.fetch,
          'GET',
          `${this.url}/.well-known/jwks.json`,
          { headers: this.headers }
        );
        if (s) throw s;
        return i.keys &&
          0 !== i.keys.length &&
          ((this.jwks = i),
          (this.jwks_cached_at = n),
          (r = i.keys.find((t) => t.kid === e)))
          ? r
          : null;
      }
      async getClaims(e, t = {}) {
        try {
          var r;
          let n,
            i = e;
          if (!i) {
            let { data: e, error: t } = await this.getSession();
            if (t || !e.session)
              return this._returnResult({ data: null, error: t });
            i = e.session.access_token;
          }
          let {
            header: s,
            payload: a,
            signature: o,
            raw: { header: l, payload: u },
          } = nP(i);
          (null == t ? void 0 : t.allowExpired) ||
            (function (e) {
              if (!e) throw Error('Missing exp claim');
              if (e <= Math.floor(Date.now() / 1e3))
                throw Error('JWT has expired');
            })(a.exp);
          let c =
            !s.alg ||
            s.alg.startsWith('HS') ||
            !s.kid ||
            !('crypto' in globalThis && 'subtle' in globalThis.crypto)
              ? null
              : await this.fetchJwk(
                  s.kid,
                  (null == t ? void 0 : t.keys)
                    ? { keys: t.keys }
                    : null == t
                      ? void 0
                      : t.jwks
                );
          if (!c) {
            let { error: e } = await this.getUser(i);
            if (e) throw e;
            return {
              data: { claims: a, header: s, signature: o },
              error: null,
            };
          }
          let h = (function (e) {
              switch (e) {
                case 'RS256':
                  return {
                    name: 'RSASSA-PKCS1-v1_5',
                    hash: { name: 'SHA-256' },
                  };
                case 'ES256':
                  return {
                    name: 'ECDSA',
                    namedCurve: 'P-256',
                    hash: { name: 'SHA-256' },
                  };
                default:
                  throw Error('Invalid alg claim');
              }
            })(s.alg),
            d = await crypto.subtle.importKey('jwk', c, h, !0, ['verify']);
          if (
            !(await crypto.subtle.verify(
              h,
              d,
              o,
              ((r = `${l}.${u}`),
              (n = []),
              !(function (e, t) {
                for (let r = 0; r < e.length; r += 1) {
                  let n = e.charCodeAt(r);
                  if (n > 55295 && n <= 56319) {
                    let t = ((n - 55296) * 1024) & 65535;
                    ((n =
                      (((e.charCodeAt(r + 1) - 56320) & 65535) | t) + 65536),
                      (r += 1));
                  }
                  !(function (e, t) {
                    if (e <= 127) return t(e);
                    if (e <= 2047) {
                      (t(192 | (e >> 6)), t(128 | (63 & e)));
                      return;
                    }
                    if (e <= 65535) {
                      (t(224 | (e >> 12)),
                        t(128 | ((e >> 6) & 63)),
                        t(128 | (63 & e)));
                      return;
                    }
                    if (e <= 1114111) {
                      (t(240 | (e >> 18)),
                        t(128 | ((e >> 12) & 63)),
                        t(128 | ((e >> 6) & 63)),
                        t(128 | (63 & e)));
                      return;
                    }
                    throw Error(
                      `Unrecognized Unicode codepoint: ${e.toString(16)}`
                    );
                  })(n, t);
                }
              })(r, (e) => n.push(e)),
              new Uint8Array(n))
            ))
          )
            throw new nf('Invalid JWT signature');
          return { data: { claims: a, header: s, signature: o }, error: null };
        } catch (e) {
          if (nr(e)) return this._returnResult({ data: null, error: e });
          throw e;
        }
      }
    }
    is.nextInstanceID = {};
    let ia = is,
      io = '';
    io =
      'u' > typeof Deno
        ? 'deno'
        : 'u' > typeof document
          ? 'web'
          : 'u' > typeof navigator && 'ReactNative' === navigator.product
            ? 'react-native'
            : 'node';
    let il = { headers: { 'X-Client-Info': `supabase-js-${io}/2.91.1` } },
      iu = { schema: 'public' },
      ic = {
        autoRefreshToken: !0,
        persistSession: !0,
        detectSessionInUrl: !0,
        flowType: 'implicit',
      },
      ih = {};
    function id(e) {
      return (id =
        'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
          ? function (e) {
              return typeof e;
            }
          : function (e) {
              return e &&
                'function' == typeof Symbol &&
                e.constructor === Symbol &&
                e !== Symbol.prototype
                ? 'symbol'
                : typeof e;
            })(e);
    }
    function ip(e, t) {
      var r = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        (t &&
          (n = n.filter(function (t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable;
          })),
          r.push.apply(r, n));
      }
      return r;
    }
    function ig(e) {
      for (var t = 1; t < arguments.length; t++) {
        var r = null != arguments[t] ? arguments[t] : {};
        t % 2
          ? ip(Object(r), !0).forEach(function (t) {
              !(function (e, t, r) {
                var n;
                ((n = (function (e, t) {
                  if ('object' != id(e) || !e) return e;
                  var r = e[Symbol.toPrimitive];
                  if (void 0 !== r) {
                    var n = r.call(e, t || 'default');
                    if ('object' != id(n)) return n;
                    throw TypeError(
                      '@@toPrimitive must return a primitive value.'
                    );
                  }
                  return ('string' === t ? String : Number)(e);
                })(t, 'string')),
                (t = 'symbol' == id(n) ? n : n + '') in e)
                  ? Object.defineProperty(e, t, {
                      value: r,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                    })
                  : (e[t] = r);
              })(e, t, r[t]);
            })
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
            : ip(Object(r)).forEach(function (t) {
                Object.defineProperty(
                  e,
                  t,
                  Object.getOwnPropertyDescriptor(r, t)
                );
              });
      }
      return e;
    }
    var im = class extends ia {
        constructor(e) {
          super(e);
        }
      },
      iy = class {
        constructor(e, t, r) {
          var n, i, s;
          ((this.supabaseUrl = e), (this.supabaseKey = t));
          const a = (function (e) {
            let t = null == e ? void 0 : e.trim();
            if (!t) throw Error('supabaseUrl is required.');
            if (!t.match(/^https?:\/\//i))
              throw Error(
                'Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.'
              );
            try {
              return new URL(t.endsWith('/') ? t : t + '/');
            } catch (e) {
              throw Error('Invalid supabaseUrl: Provided URL is malformed.');
            }
          })(e);
          if (!t) throw Error('supabaseKey is required.');
          ((this.realtimeUrl = new URL('realtime/v1', a)),
            (this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace(
              'http',
              'ws'
            )),
            (this.authUrl = new URL('auth/v1', a)),
            (this.storageUrl = new URL('storage/v1', a)),
            (this.functionsUrl = new URL('functions/v1', a)));
          const o = `sb-${a.hostname.split('.')[0]}-auth-token`,
            l = (function (e, t) {
              var r, n;
              let { db: i, auth: s, realtime: a, global: o } = e,
                { db: l, auth: u, realtime: c, global: h } = t,
                d = {
                  db: ig(ig({}, l), i),
                  auth: ig(ig({}, u), s),
                  realtime: ig(ig({}, c), a),
                  storage: {},
                  global: ig(
                    ig(ig({}, h), o),
                    {},
                    {
                      headers: ig(
                        ig(
                          {},
                          null != (r = null == h ? void 0 : h.headers) ? r : {}
                        ),
                        null != (n = null == o ? void 0 : o.headers) ? n : {}
                      ),
                    }
                  ),
                  accessToken: async () => '',
                };
              return (
                e.accessToken
                  ? (d.accessToken = e.accessToken)
                  : delete d.accessToken,
                d
              );
            })(null != r ? r : {}, {
              db: iu,
              realtime: ih,
              auth: ig(ig({}, ic), {}, { storageKey: o }),
              global: il,
            });
          ((this.storageKey = null != (n = l.auth.storageKey) ? n : ''),
            (this.headers = null != (i = l.global.headers) ? i : {}),
            l.accessToken
              ? ((this.accessToken = l.accessToken),
                (this.auth = new Proxy(
                  {},
                  {
                    get: (e, t) => {
                      throw Error(
                        `@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(t)} is not possible`
                      );
                    },
                  }
                )))
              : (this.auth = this._initSupabaseAuthClient(
                  null != (s = l.auth) ? s : {},
                  this.headers,
                  l.global.fetch
                )),
            (this.fetch = ((e, t, r) => {
              let n = r ? (...e) => r(...e) : (...e) => fetch(...e),
                i = Headers;
              return async (r, s) => {
                var a;
                let o = null != (a = await t()) ? a : e,
                  l = new i(null == s ? void 0 : s.headers);
                return (
                  l.has('apikey') || l.set('apikey', e),
                  l.has('Authorization') ||
                    l.set('Authorization', `Bearer ${o}`),
                  n(r, ig(ig({}, s), {}, { headers: l }))
                );
              };
            })(t, this._getAccessToken.bind(this), l.global.fetch)),
            (this.realtime = this._initRealtimeClient(
              ig(
                {
                  headers: this.headers,
                  accessToken: this._getAccessToken.bind(this),
                },
                l.realtime
              )
            )),
            this.accessToken &&
              Promise.resolve(this.accessToken())
                .then((e) => this.realtime.setAuth(e))
                .catch((e) =>
                  console.warn('Failed to set initial Realtime auth token:', e)
                ),
            (this.rest = new tQ(new URL('rest/v1', a).href, {
              headers: this.headers,
              schema: l.db.schema,
              fetch: this.fetch,
            })),
            (this.storage = new r5(
              this.storageUrl.href,
              this.headers,
              this.fetch,
              null == r ? void 0 : r.storage
            )),
            l.accessToken || this._listenForAuthEvents());
        }
        get functions() {
          return new tH(this.functionsUrl.href, {
            headers: this.headers,
            customFetch: this.fetch,
          });
        }
        from(e) {
          return this.rest.from(e);
        }
        schema(e) {
          return this.rest.schema(e);
        }
        rpc(e, t = {}, r = { head: !1, get: !1, count: void 0 }) {
          return this.rest.rpc(e, t, r);
        }
        channel(e, t = { config: {} }) {
          return this.realtime.channel(e, t);
        }
        getChannels() {
          return this.realtime.getChannels();
        }
        removeChannel(e) {
          return this.realtime.removeChannel(e);
        }
        removeAllChannels() {
          return this.realtime.removeAllChannels();
        }
        async _getAccessToken() {
          var e, t;
          if (this.accessToken) return await this.accessToken();
          let { data: r } = await this.auth.getSession();
          return null != (e = null == (t = r.session) ? void 0 : t.access_token)
            ? e
            : this.supabaseKey;
        }
        _initSupabaseAuthClient(
          {
            autoRefreshToken: e,
            persistSession: t,
            detectSessionInUrl: r,
            storage: n,
            userStorage: i,
            storageKey: s,
            flowType: a,
            lock: o,
            debug: l,
            throwOnError: u,
          },
          c,
          h
        ) {
          let d = {
            Authorization: `Bearer ${this.supabaseKey}`,
            apikey: `${this.supabaseKey}`,
          };
          return new im({
            url: this.authUrl.href,
            headers: ig(ig({}, d), c),
            storageKey: s,
            autoRefreshToken: e,
            persistSession: t,
            detectSessionInUrl: r,
            storage: n,
            userStorage: i,
            flowType: a,
            lock: o,
            debug: l,
            throwOnError: u,
            fetch: h,
            hasCustomAuthorizationHeader: Object.keys(this.headers).some(
              (e) => 'authorization' === e.toLowerCase()
            ),
          });
        }
        _initRealtimeClient(e) {
          return new ru(
            this.realtimeUrl.href,
            ig(
              ig({}, e),
              {},
              {
                params: ig(
                  ig({}, { apikey: this.supabaseKey }),
                  null == e ? void 0 : e.params
                ),
              }
            )
          );
        }
        _listenForAuthEvents() {
          return this.auth.onAuthStateChange((e, t) => {
            this._handleTokenChanged(
              e,
              'CLIENT',
              null == t ? void 0 : t.access_token
            );
          });
        }
        _handleTokenChanged(e, t, r) {
          ('TOKEN_REFRESHED' === e || 'SIGNED_IN' === e) &&
          this.changedAccessToken !== r
            ? ((this.changedAccessToken = r), this.realtime.setAuth(r))
            : 'SIGNED_OUT' === e &&
              (this.realtime.setAuth(),
              'STORAGE' == t && this.auth.signOut(),
              (this.changedAccessToken = void 0));
        }
      };
    if (
      ((function () {
        let e = globalThis.process;
        if (!e) return !1;
        let t = e.version;
        if (null == t) return !1;
        let r = t.match(/^v(\d+)\./);
        return !!r && 18 >= parseInt(r[1], 10);
      })() &&
        console.warn(
          '  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217'
        ),
      e.i(3995),
      'u' > typeof process && process.env?.ppnpm_package_name)
    ) {
      let e = process.env.ppnpm_package_name;
      [
        '@supabase/auth-helpers-nextjs',
        '@supabase/auth-helpers-react',
        '@supabase/auth-helpers-remix',
        '@supabase/auth-helpers-sveltekit',
      ].includes(e) &&
        console.warn(`

   IMPORTANT: Package Consolidation Notice                                
                                                                            
 The ${e.padEnd(35)} package name is deprecated.  
                                                                            
 You are now using @supabase/ssr - a unified solution for all frameworks.  
                                                                            
 The auth-helpers packages have been consolidated into @supabase/ssr       
 to provide better maintenance and consistent APIs across frameworks.      
                                                                            
 Please update your package.json to use @supabase/ssr directly:            
   ppnpm uninstall ${e.padEnd(42)} 
   ppnpm install @supabase/ssr                                               
                                                                            
 For more information, visit:                                              
 https://supabase.com/docs/guides/auth/server-side                         

    `);
    }
    var ib = e.i(55207);
    async function iv(e) {
      let t = ib.NextResponse.next({ request: e }),
        r = (function (e, t, r) {
          if (!e || !t)
            throw Error(`Your project's URL and Key are required to create a Supabase client!

Check your Supabase project's API settings to find these values

https://supabase.com/dashboard/project/_/settings/api`);
          let {
              storage: n,
              getAll: i,
              setAll: s,
              setItems: a,
              removedItems: o,
            } = (function (e, t) {
              let r,
                n,
                i = e.cookies ?? null,
                s = e.cookieEncoding,
                a = {},
                o = {};
              if (i)
                if ('get' in i) {
                  let e = async (e) => {
                    let t = e.flatMap((e) => [
                        e,
                        ...Array.from({ length: 5 }).map((t, r) => `${e}.${r}`),
                      ]),
                      r = [];
                    for (let e = 0; e < t.length; e += 1) {
                      let n = await i.get(t[e]);
                      (n || 'string' == typeof n) &&
                        r.push({ name: t[e], value: n });
                    }
                    return r;
                  };
                  if (
                    ((r = async (t) => await e(t)), 'set' in i && 'remove' in i)
                  )
                    n = async (e) => {
                      for (let t = 0; t < e.length; t += 1) {
                        let { name: r, value: n, options: s } = e[t];
                        n ? await i.set(r, n, s) : await i.remove(r, s);
                      }
                    };
                  else if (t)
                    n = async () => {
                      console.warn(
                        '@supabase/ssr: createServerClient was configured without set and remove cookie methods, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness. Consider switching to the getAll and setAll cookie methods instead of get, set and remove which are deprecated and can be difficult to use correctly.'
                      );
                    };
                  else
                    throw Error(
                      '@supabase/ssr: createBrowserClient requires configuring a getAll and setAll cookie method (deprecated: alternatively both get, set and remove can be used)'
                    );
                } else if ('getAll' in i)
                  if (((r = async () => await i.getAll()), 'setAll' in i))
                    n = i.setAll;
                  else if (t)
                    n = async () => {
                      console.warn(
                        '@supabase/ssr: createServerClient was configured without the setAll cookie method, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness.'
                      );
                    };
                  else
                    throw Error(
                      '@supabase/ssr: createBrowserClient requires configuring both getAll and setAll cookie methods (deprecated: alternatively both get, set and remove can be used)'
                    );
                else
                  throw Error(
                    `@supabase/ssr: ${t ? 'createServerClient' : 'createBrowserClient'} requires configuring getAll and setAll cookie methods (deprecated: alternatively use get, set and remove).`
                  );
              else if (t || 1)
                if (t)
                  throw Error(
                    '@supabase/ssr: createServerClient must be initialized with cookie options that specify getAll and setAll functions (deprecated, not recommended: alternatively use get, set and remove)'
                  );
                else
                  ((r = () => []),
                    (n = () => {
                      throw Error(
                        '@supabase/ssr: createBrowserClient in non-browser runtimes (including Next.js pre-rendering mode) was not initialized cookie options that specify getAll and setAll functions (deprecated: alternatively use get, set and remove), but they were needed'
                      );
                    }));
              else
                ((r = () => {
                  let e;
                  return Object.keys((e = (0, tk.parse)(document.cookie))).map(
                    (t) => ({ name: t, value: e[t] ?? '' })
                  );
                }),
                  (n = (e) => {
                    e.forEach(({ name: e, value: t, options: r }) => {
                      document.cookie = (0, tk.serialize)(e, t, r);
                    });
                  }));
              return t
                ? {
                    getAll: r,
                    setAll: n,
                    setItems: a,
                    removedItems: o,
                    storage: {
                      isServer: !0,
                      getItem: async (e) => {
                        if ('string' == typeof a[e]) return a[e];
                        if (o[e]) return null;
                        let t = await r([e]),
                          n = await tI(e, async (e) => {
                            let r = t?.find(({ name: t }) => t === e) || null;
                            return r ? r.value : null;
                          });
                        if (!n) return null;
                        let i = n;
                        return (
                          'string' == typeof n &&
                            n.startsWith(tU) &&
                            (i = tL(n.substring(tU.length))),
                          i
                        );
                      },
                      setItem: async (t, i) => {
                        (t.endsWith('-code-verifier') &&
                          (await tM(
                            {
                              getAll: r,
                              setAll: n,
                              setItems: { [t]: i },
                              removedItems: {},
                            },
                            {
                              cookieOptions: e?.cookieOptions ?? null,
                              cookieEncoding: s,
                            }
                          )),
                          (a[t] = i),
                          delete o[t]);
                      },
                      removeItem: async (e) => {
                        (delete a[e], (o[e] = !0));
                      },
                    },
                  }
                : {
                    getAll: r,
                    setAll: n,
                    setItems: a,
                    removedItems: o,
                    storage: {
                      isServer: !1,
                      getItem: async (e) => {
                        let t = await r([e]),
                          n = await tI(e, async (e) => {
                            let r = t?.find(({ name: t }) => t === e) || null;
                            return r ? r.value : null;
                          });
                        if (!n) return null;
                        let i = n;
                        return (
                          n.startsWith(tU) && (i = tL(n.substring(tU.length))),
                          i
                        );
                      },
                      setItem: async (t, i) => {
                        let a = await r([t]),
                          o = new Set(
                            (a?.map(({ name: e }) => e) || []).filter((e) =>
                              tA(e, t)
                            )
                          ),
                          l = i;
                        'base64url' === s && (l = tU + t$(i));
                        let u = tC(t, l);
                        u.forEach(({ name: e }) => {
                          o.delete(e);
                        });
                        let c = { ...tP, ...e?.cookieOptions, maxAge: 0 },
                          h = { ...tP, ...e?.cookieOptions, maxAge: tP.maxAge };
                        (delete c.name, delete h.name);
                        let d = [
                          ...[...o].map((e) => ({
                            name: e,
                            value: '',
                            options: c,
                          })),
                          ...u.map(({ name: e, value: t }) => ({
                            name: e,
                            value: t,
                            options: h,
                          })),
                        ];
                        d.length > 0 && (await n(d));
                      },
                      removeItem: async (t) => {
                        let i = await r([t]),
                          s = (i?.map(({ name: e }) => e) || []).filter((e) =>
                            tA(e, t)
                          ),
                          a = { ...tP, ...e?.cookieOptions, maxAge: 0 };
                        (delete a.name,
                          s.length > 0 &&
                            (await n(
                              s.map((e) => ({ name: e, value: '', options: a }))
                            )));
                      },
                    },
                  };
            })({ ...r, cookieEncoding: r?.cookieEncoding ?? 'base64url' }, !0),
            l = new iy(e, t, {
              ...r,
              global: {
                ...r?.global,
                headers: {
                  ...r?.global?.headers,
                  'X-Client-Info': 'supabase-ssr/0.8.0 createServerClient',
                },
              },
              auth: {
                ...(r?.cookieOptions?.name
                  ? { storageKey: r.cookieOptions.name }
                  : null),
                ...r?.auth,
                flowType: 'pkce',
                autoRefreshToken: !1,
                detectSessionInUrl: !1,
                persistSession: !0,
                storage: n,
                ...(r?.cookies &&
                'encode' in r.cookies &&
                'tokens-only' === r.cookies.encode
                  ? {
                      userStorage:
                        r?.auth?.userStorage ??
                        (function (e = {}) {
                          return {
                            getItem: (t) => e[t] || null,
                            setItem: (t, r) => {
                              e[t] = r;
                            },
                            removeItem: (t) => {
                              delete e[t];
                            },
                          };
                        })(),
                    }
                  : null),
              },
            });
          return (
            l.auth.onAuthStateChange(async (e) => {
              (Object.keys(a).length > 0 || Object.keys(o).length > 0) &&
                ('SIGNED_IN' === e ||
                  'TOKEN_REFRESHED' === e ||
                  'USER_UPDATED' === e ||
                  'PASSWORD_RECOVERY' === e ||
                  'SIGNED_OUT' === e ||
                  'MFA_CHALLENGE_VERIFIED' === e) &&
                (await tM(
                  { getAll: i, setAll: s, setItems: a, removedItems: o },
                  {
                    cookieOptions: r?.cookieOptions ?? null,
                    cookieEncoding: r?.cookieEncoding ?? 'base64url',
                  }
                ));
            }),
            l
          );
        })(
          'https://umkmwbkwvulxtdodzmzf.supabase.co',
          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVta213Ymt3dnVseHRkb2R6bXpmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgzNDE4MzcsImV4cCI6MjA4MzkxNzgzN30.wssvD9W-yzRyLpq8aMCw57E4wNz7OnQ58ujLzYmF6CA',
          {
            cookieOptions: { name: '__session', sameSite: 'lax', secure: !0 },
            cookies: {
              getAll: () => e.cookies.getAll(),
              setAll(r) {
                ((t = ib.NextResponse.next({ request: e })),
                  r.forEach(({ name: e, value: r, options: n }) =>
                    t.cookies.set(e, r, n)
                  ));
              },
            },
          }
        ),
        {
          data: { user: n },
        } = await r.auth.getUser(),
        i = e.nextUrl.pathname,
        s = '/admin/login' === i,
        a = i.startsWith('/admin');
      if (i.startsWith('/auth/callback')) return t;
      if (n && s) {
        let r = e.nextUrl.clone();
        r.pathname = '/admin';
        let n = ib.NextResponse.redirect(r);
        return (
          t.cookies.getAll().forEach((e) => n.cookies.set(e.name, e.value, e)),
          n
        );
      }
      if (a && !s && !n) {
        let r = e.nextUrl.clone();
        r.pathname = '/admin/login';
        let n = ib.NextResponse.redirect(r);
        return (
          t.cookies.getAll().forEach((e) => n.cookies.set(e.name, e.value, e)),
          n
        );
      }
      return t;
    }
    async function iw(e) {
      return await iv(e);
    }
    e.s(
      [
        'config',
        0,
        {
          matcher: [
            '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
          ],
        },
        'proxy',
        () => iw,
      ],
      22685
    );
    var i_ = e.i(22685);
    Object.values({ NOT_FOUND: 404, FORBIDDEN: 403, UNAUTHORIZED: 401 });
    let iE = { ...i_ },
      iS = '/proxy',
      iR = iE.proxy || iE.default;
    if ('function' != typeof iR)
      throw new (class extends Error {
        constructor(e) {
          (super(e), (this.stack = ''));
        }
      })(
        `The Proxy file "${iS}" must export a function named \`proxy\` or a default function.`
      );
    e.s(
      [
        'default',
        0,
        (e) =>
          tT({
            ...e,
            page: iS,
            handler: async (...e) => {
              try {
                return await iR(...e);
              } catch (i) {
                let t = e[0],
                  r = new URL(t.url),
                  n = r.pathname + r.search;
                throw (
                  await o(
                    i,
                    {
                      path: n,
                      method: t.method,
                      headers: Object.fromEntries(t.headers.entries()),
                    },
                    {
                      routerKind: 'Pages Router',
                      routePath: '/proxy',
                      routeType: 'proxy',
                      revalidateReason: void 0,
                    }
                  ),
                  i
                );
              }
            },
          }),
      ],
      89997
    );
  },
];

//# sourceMappingURL=%5Broot-of-the-server%5D__9a5f8dd1._.js.map
