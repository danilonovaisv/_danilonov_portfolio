{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/.pnpm/three%400.182.0/node_modules/three/examples/jsm/shaders/CopyShader.js"],"sourcesContent":["/**\n * @module CopyShader\n * @three_import import { CopyShader } from 'three/addons/shaders/CopyShader.js';\n */\n\n/**\n * Full-screen copy shader pass.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst CopyShader = {\n\n\tname: 'CopyShader',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'opacity': { value: 1.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}`\n\n};\n\nexport { CopyShader };\n"],"names":[],"mappings":";;;;AAAA;;;CAGC,GAED;;;;;CAKC,GACD,MAAM,aAAa;IAElB,MAAM;IAEN,UAAU;QAET,YAAY;YAAE,OAAO;QAAK;QAC1B,WAAW;YAAE,OAAO;QAAI;IAEzB;IAEA,cAAc,QAAQ,GAAE,CAAC;;;;;;;;;GASvB,CAAC;IAEH,gBAAgB,QAAQ,GAAE,CAAC;;;;;;;;;;;;;;GAczB,CAAC;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 57, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/.pnpm/three%400.182.0/node_modules/three/examples/jsm/postprocessing/Pass.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\n/**\n * Abstract base class for all post processing passes.\n *\n * This module is only relevant for post processing with {@link WebGLRenderer}.\n *\n * @abstract\n * @three_import import { Pass } from 'three/addons/postprocessing/Pass.js';\n */\nclass Pass {\n\n\t/**\n\t * Constructs a new pass.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPass = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass is processed by the composer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enabled = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass indicates to swap read and write buffer after rendering.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.needsSwap = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass clears its buffer before rendering\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clear = false;\n\n\t\t/**\n\t\t * If set to `true`, the result of the pass is rendered to screen. The last pass in the composers\n\t\t * pass chain gets automatically rendered to screen, no matter how this property is configured.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @abstract\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( /* width, height */ ) {}\n\n\t/**\n\t * This method holds the render logic of a pass. It must be implemented in all derived classes.\n\t *\n\t * @abstract\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t *\n\t * @abstract\n\t */\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass FullscreenTriangleGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\n\t}\n\n}\n\nconst _geometry = new FullscreenTriangleGeometry();\n\n\n/**\n * This module is a helper for passes which need to render a full\n * screen effect which is quite common in context of post processing.\n *\n * The intended usage is to reuse a single full screen quad for rendering\n * subsequent passes by just reassigning the `material` reference.\n *\n * This module can only be used with {@link WebGLRenderer}.\n *\n * @augments Mesh\n * @three_import import { FullScreenQuad } from 'three/addons/postprocessing/Pass.js';\n */\nclass FullScreenQuad {\n\n\t/**\n\t * Constructs a new full screen quad.\n\t *\n\t * @param {?Material} material - The material to render te full screen quad with.\n\t */\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\t/**\n\t * Renders the full screen quad.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t */\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\t/**\n\t * The quad's material.\n\t *\n\t * @type {?Material}\n\t */\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n"],"names":[],"mappings":";;;;;;AAAA;;AAOA;;;;;;;CAOC,GACD,MAAM;IAEL;;EAEC,GACD,aAAc;QAEb;;;;;;GAMC,GACD,IAAI,CAAC,MAAM,GAAG;QAEd;;;;;GAKC,GACD,IAAI,CAAC,OAAO,GAAG;QAEf;;;;;GAKC,GACD,IAAI,CAAC,SAAS,GAAG;QAEjB;;;;;GAKC,GACD,IAAI,CAAC,KAAK,GAAG;QAEb;;;;;;GAMC,GACD,IAAI,CAAC,cAAc,GAAG;IAEvB;IAEA;;;;;;EAMC,GACD,UAA+B,CAAC;IAEhC;;;;;;;;;;;EAWC,GACD,SAAyE;QAExE,QAAQ,KAAK,CAAE;IAEhB;IAEA;;;;;EAKC,GACD,UAAU,CAAC;AAEZ;AAEA,uEAAuE;AAEvE,MAAM,UAAU,IAAI,4NAAkB,CAAE,CAAE,GAAG,GAAG,GAAG,CAAE,GAAG,GAAG;AAE3D,gDAAgD;AAEhD,MAAM,mCAAmC,wNAAc;IAEtD,aAAc;QAEb,KAAK;QAEL,IAAI,CAAC,YAAY,CAAE,YAAY,IAAI,gOAAsB,CAAE;YAAE,CAAE;YAAG;YAAG;YAAG,CAAE;YAAG,CAAE;YAAG;YAAG;YAAG,CAAE;YAAG;SAAG,EAAE;QAClG,IAAI,CAAC,YAAY,CAAE,MAAM,IAAI,gOAAsB,CAAE;YAAE;YAAG;YAAG;YAAG;YAAG;YAAG;SAAG,EAAE;IAE5E;AAED;AAEA,MAAM,YAAY,IAAI;AAGtB;;;;;;;;;;;CAWC,GACD,MAAM;IAEL;;;;EAIC,GACD,YAAa,QAAQ,CAAG;QAEvB,IAAI,CAAC,KAAK,GAAG,IAAI,8MAAI,CAAE,WAAW;IAEnC;IAEA;;;EAGC,GACD,UAAU;QAET,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO;IAE5B;IAEA;;;;EAIC,GACD,OAAQ,QAAQ,EAAG;QAElB,SAAS,MAAM,CAAE,IAAI,CAAC,KAAK,EAAE;IAE9B;IAEA;;;;EAIC,GACD,IAAI,WAAW;QAEd,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ;IAE3B;IAEA,IAAI,SAAU,KAAK,EAAG;QAErB,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG;IAEvB;AAED","ignoreList":[0]}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/.pnpm/three%400.182.0/node_modules/three/examples/jsm/postprocessing/ShaderPass.js"],"sourcesContent":["import {\n\tShaderMaterial,\n\tUniformsUtils\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\n/**\n * This pass can be used to create a post processing effect\n * with a raw GLSL shader object. Useful for implementing custom\n * effects.\n *\n * ```js\n * const fxaaPass = new ShaderPass( FXAAShader );\n * composer.addPass( fxaaPass );\n * ```\n *\n * @augments Pass\n * @three_import import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n */\nclass ShaderPass extends Pass {\n\n\t/**\n\t * Constructs a new shader pass.\n\t *\n\t * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as\n\t * defines and uniforms. It's also valid to pass a custom shader material.\n\t * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample\n\t * the read buffer.\n\t */\n\tconstructor( shader, textureID = 'tDiffuse' ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the texture uniform that should sample the read buffer.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'tDiffuse'\n\t\t */\n\t\tthis.textureID = textureID;\n\n\t\t/**\n\t\t * The pass uniforms.\n\t\t *\n\t\t * @type {?Object}\n\t\t */\n\t\tthis.uniforms = null;\n\n\t\t/**\n\t\t * The pass material.\n\t\t *\n\t\t * @type {?ShaderMaterial}\n\t\t */\n\t\tthis.material = null;\n\n\t\tif ( shader instanceof ShaderMaterial ) {\n\n\t\t\tthis.uniforms = shader.uniforms;\n\n\t\t\tthis.material = shader;\n\n\t\t} else if ( shader ) {\n\n\t\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t\tthis.material = new ShaderMaterial( {\n\n\t\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\t\tuniforms: this.uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// internals\n\n\t\tthis._fsQuad = new FullScreenQuad( this.material );\n\n\t}\n\n\t/**\n\t * Performs the shader pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t}\n\n\t\tthis._fsQuad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.material.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n}\n\nexport { ShaderPass };\n"],"names":[],"mappings":";;;;AAAA;AAIA;;;AAEA;;;;;;;;;;;;CAYC,GACD,MAAM,mBAAmB,iOAAI;IAE5B;;;;;;;EAOC,GACD,YAAa,MAAM,EAAE,YAAY,UAAU,CAAG;QAE7C,KAAK;QAEL;;;;;GAKC,GACD,IAAI,CAAC,SAAS,GAAG;QAEjB;;;;GAIC,GACD,IAAI,CAAC,QAAQ,GAAG;QAEhB;;;;GAIC,GACD,IAAI,CAAC,QAAQ,GAAG;QAEhB,IAAK,kBAAkB,wNAAc,EAAG;YAEvC,IAAI,CAAC,QAAQ,GAAG,OAAO,QAAQ;YAE/B,IAAI,CAAC,QAAQ,GAAG;QAEjB,OAAO,IAAK,QAAS;YAEpB,IAAI,CAAC,QAAQ,GAAG,uNAAa,CAAC,KAAK,CAAE,OAAO,QAAQ;YAEpD,IAAI,CAAC,QAAQ,GAAG,IAAI,wNAAc,CAAE;gBAEnC,MAAM,AAAE,OAAO,IAAI,KAAK,YAAc,OAAO,IAAI,GAAG;gBACpD,SAAS,OAAO,MAAM,CAAE,CAAC,GAAG,OAAO,OAAO;gBAC1C,UAAU,IAAI,CAAC,QAAQ;gBACvB,cAAc,OAAO,YAAY;gBACjC,gBAAgB,OAAO,cAAc;YAEtC;QAED;QAEA,YAAY;QAEZ,IAAI,CAAC,OAAO,GAAG,IAAI,2OAAc,CAAE,IAAI,CAAC,QAAQ;IAEjD;IAEA;;;;;;;;;;EAUC,GACD,OAAQ,QAAQ,EAAE,WAAW,EAAE,WAAW,0BAA0B,GAA3B,EAAgC;QAExE,IAAK,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,SAAS,CAAE,EAAG;YAEtC,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,SAAS,CAAE,CAAC,KAAK,GAAG,WAAW,OAAO;QAE3D;QAEA,IAAI,CAAC,OAAO,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ;QAErC,IAAK,IAAI,CAAC,cAAc,EAAG;YAE1B,SAAS,eAAe,CAAE;YAC1B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAE;QAEtB,OAAO;YAEN,SAAS,eAAe,CAAE;YAC1B,mHAAmH;YACnH,IAAK,IAAI,CAAC,KAAK,EAAG,SAAS,KAAK,CAAE,SAAS,cAAc,EAAE,SAAS,cAAc,EAAE,SAAS,gBAAgB;YAC7G,IAAI,CAAC,OAAO,CAAC,MAAM,CAAE;QAEtB;IAED;IAEA;;;EAGC,GACD,UAAU;QAET,IAAI,CAAC,QAAQ,CAAC,OAAO;QAErB,IAAI,CAAC,OAAO,CAAC,OAAO;IAErB;AAED","ignoreList":[0]}},
    {"offset": {"line": 313, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/.pnpm/three%400.182.0/node_modules/three/examples/jsm/postprocessing/MaskPass.js"],"sourcesContent":["import { Pass } from './Pass.js';\n\n/**\n * This pass can be used to define a mask during post processing.\n * Meaning only areas of subsequent post processing are affected\n * which lie in the masking area of this pass. Internally, the masking\n * is implemented with the stencil buffer.\n *\n * ```js\n * const maskPass = new MaskPass( scene, camera );\n * composer.addPass( maskPass );\n * ```\n *\n * @augments Pass\n * @three_import import { MaskPass } from 'three/addons/postprocessing/MaskPass.js';\n */\nclass MaskPass extends Pass {\n\n\t/**\n\t * Constructs a new mask pass.\n\t *\n\t * @param {Scene} scene - The 3D objects in this scene will define the mask.\n\t * @param {Camera} camera - The camera.\n\t */\n\tconstructor( scene, camera ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scene that defines the mask.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * Overwritten to perform a clear operation by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clear = true;\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t\t/**\n\t\t * Whether to inverse the mask or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.inverse = false;\n\n\t}\n\n\t/**\n\t * Performs a mask pass with the configured scene and camera.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tconst context = renderer.getContext();\n\t\tconst state = renderer.state;\n\n\t\t// don't update color or depth\n\n\t\tstate.buffers.color.setMask( false );\n\t\tstate.buffers.depth.setMask( false );\n\n\t\t// lock buffers\n\n\t\tstate.buffers.color.setLocked( true );\n\t\tstate.buffers.depth.setLocked( true );\n\n\t\t// set up stencil\n\n\t\tlet writeValue, clearValue;\n\n\t\tif ( this.inverse ) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\n\t\t}\n\n\t\tstate.buffers.stencil.setTest( true );\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\tstate.buffers.stencil.setClear( clearValue );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.setRenderTarget( readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\trenderer.setRenderTarget( writeBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// unlock color and depth buffer and make them writable for subsequent rendering/clearing\n\n\t\tstate.buffers.color.setLocked( false );\n\t\tstate.buffers.depth.setLocked( false );\n\n\t\tstate.buffers.color.setMask( true );\n\t\tstate.buffers.depth.setMask( true );\n\n\t\t// only render where stencil is set to 1\n\n\t\tstate.buffers.stencil.setLocked( false );\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t}\n\n}\n\n/**\n * This pass can be used to clear a mask previously defined with {@link MaskPass}.\n *\n * ```js\n * const clearPass = new ClearMaskPass();\n * composer.addPass( clearPass );\n * ```\n *\n * @augments Pass\n */\nclass ClearMaskPass extends Pass {\n\n\t/**\n\t * Constructs a new clear mask pass.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t}\n\n\t/**\n\t * Performs the clear of the currently defined mask.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\trenderer.state.buffers.stencil.setLocked( false );\n\t\trenderer.state.buffers.stencil.setTest( false );\n\n\t}\n\n}\n\nexport { MaskPass, ClearMaskPass };\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA;;;;;;;;;;;;;CAaC,GACD,MAAM,iBAAiB,iOAAI;IAE1B;;;;;EAKC,GACD,YAAa,KAAK,EAAE,MAAM,CAAG;QAE5B,KAAK;QAEL;;;;GAIC,GACD,IAAI,CAAC,KAAK,GAAG;QAEb;;;;GAIC,GACD,IAAI,CAAC,MAAM,GAAG;QAEd;;;;;GAKC,GACD,IAAI,CAAC,KAAK,GAAG;QAEb;;;;;GAKC,GACD,IAAI,CAAC,SAAS,GAAG;QAEjB;;;;;GAKC,GACD,IAAI,CAAC,OAAO,GAAG;IAEhB;IAEA;;;;;;;;;;EAUC,GACD,OAAQ,QAAQ,EAAE,WAAW,EAAE,WAAW,0BAA0B,GAA3B,EAAgC;QAExE,MAAM,UAAU,SAAS,UAAU;QACnC,MAAM,QAAQ,SAAS,KAAK;QAE5B,8BAA8B;QAE9B,MAAM,OAAO,CAAC,KAAK,CAAC,OAAO,CAAE;QAC7B,MAAM,OAAO,CAAC,KAAK,CAAC,OAAO,CAAE;QAE7B,eAAe;QAEf,MAAM,OAAO,CAAC,KAAK,CAAC,SAAS,CAAE;QAC/B,MAAM,OAAO,CAAC,KAAK,CAAC,SAAS,CAAE;QAE/B,iBAAiB;QAEjB,IAAI,YAAY;QAEhB,IAAK,IAAI,CAAC,OAAO,EAAG;YAEnB,aAAa;YACb,aAAa;QAEd,OAAO;YAEN,aAAa;YACb,aAAa;QAEd;QAEA,MAAM,OAAO,CAAC,OAAO,CAAC,OAAO,CAAE;QAC/B,MAAM,OAAO,CAAC,OAAO,CAAC,KAAK,CAAE,QAAQ,OAAO,EAAE,QAAQ,OAAO,EAAE,QAAQ,OAAO;QAC9E,MAAM,OAAO,CAAC,OAAO,CAAC,OAAO,CAAE,QAAQ,MAAM,EAAE,YAAY;QAC3D,MAAM,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAE;QAChC,MAAM,OAAO,CAAC,OAAO,CAAC,SAAS,CAAE;QAEjC,+BAA+B;QAE/B,SAAS,eAAe,CAAE;QAC1B,IAAK,IAAI,CAAC,KAAK,EAAG,SAAS,KAAK;QAChC,SAAS,MAAM,CAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;QAExC,SAAS,eAAe,CAAE;QAC1B,IAAK,IAAI,CAAC,KAAK,EAAG,SAAS,KAAK;QAChC,SAAS,MAAM,CAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;QAExC,yFAAyF;QAEzF,MAAM,OAAO,CAAC,KAAK,CAAC,SAAS,CAAE;QAC/B,MAAM,OAAO,CAAC,KAAK,CAAC,SAAS,CAAE;QAE/B,MAAM,OAAO,CAAC,KAAK,CAAC,OAAO,CAAE;QAC7B,MAAM,OAAO,CAAC,KAAK,CAAC,OAAO,CAAE;QAE7B,wCAAwC;QAExC,MAAM,OAAO,CAAC,OAAO,CAAC,SAAS,CAAE;QACjC,MAAM,OAAO,CAAC,OAAO,CAAC,OAAO,CAAE,QAAQ,KAAK,EAAE,GAAG,aAAc,eAAe;QAC9E,MAAM,OAAO,CAAC,OAAO,CAAC,KAAK,CAAE,QAAQ,IAAI,EAAE,QAAQ,IAAI,EAAE,QAAQ,IAAI;QACrE,MAAM,OAAO,CAAC,OAAO,CAAC,SAAS,CAAE;IAElC;AAED;AAEA;;;;;;;;;CASC,GACD,MAAM,sBAAsB,iOAAI;IAE/B;;EAEC,GACD,aAAc;QAEb,KAAK;QAEL;;;;;GAKC,GACD,IAAI,CAAC,SAAS,GAAG;IAElB;IAEA;;;;;;;;;;EAUC,GACD,OAAQ,SAAS,mDAAmD,GAApD,EAAyD;QAExE,SAAS,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAE;QAC1C,SAAS,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAE;IAEzC;AAED","ignoreList":[0]}},
    {"offset": {"line": 464, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/.pnpm/three%400.182.0/node_modules/three/examples/jsm/postprocessing/EffectComposer.js"],"sourcesContent":["import {\n\tClock,\n\tHalfFloatType,\n\tNoBlending,\n\tVector2,\n\tWebGLRenderTarget\n} from 'three';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { ShaderPass } from './ShaderPass.js';\nimport { ClearMaskPass, MaskPass } from './MaskPass.js';\n\n/**\n * Used to implement post-processing effects in three.js.\n * The class manages a chain of post-processing passes to produce the final visual result.\n * Post-processing passes are executed in order of their addition/insertion.\n * The last pass is automatically rendered to screen.\n *\n * This module can only be used with {@link WebGLRenderer}.\n *\n * ```js\n * const composer = new EffectComposer( renderer );\n *\n * // adding some passes\n * const renderPass = new RenderPass( scene, camera );\n * composer.addPass( renderPass );\n *\n * const glitchPass = new GlitchPass();\n * composer.addPass( glitchPass );\n *\n * const outputPass = new OutputPass()\n * composer.addPass( outputPass );\n *\n * function animate() {\n *\n * \tcomposer.render(); // instead of renderer.render()\n *\n * }\n * ```\n *\n * @three_import import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n */\nclass EffectComposer {\n\n\t/**\n\t * Constructs a new effect composer.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will\n\t * be used as the internal read and write buffers. If not given, the composer creates\n\t * the buffers automatically.\n\t */\n\tconstructor( renderer, renderTarget ) {\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {WebGLRenderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tconst size = renderer.getSize( new Vector2() );\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType } );\n\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\n\t\t} else {\n\n\t\t\tthis._width = renderTarget.width;\n\t\t\tthis._height = renderTarget.height;\n\n\t\t}\n\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\t\t/**\n\t\t * A reference to the internal write buffer. Passes usually write\n\t\t * their result into this buffer.\n\t\t *\n\t\t * @type {WebGLRenderTarget}\n\t\t */\n\t\tthis.writeBuffer = this.renderTarget1;\n\n\t\t/**\n\t\t * A reference to the internal read buffer. Passes usually read\n\t\t * the previous render result from this buffer.\n\t\t *\n\t\t * @type {WebGLRenderTarget}\n\t\t */\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t\t/**\n\t\t * Whether the final pass is rendered to the screen (default framebuffer) or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.renderToScreen = true;\n\n\t\t/**\n\t\t * An array representing the (ordered) chain of post-processing passes.\n\t\t *\n\t\t * @type {Array<Pass>}\n\t\t */\n\t\tthis.passes = [];\n\n\t\t/**\n\t\t * A copy pass used for internal swap operations.\n\t\t *\n\t\t * @private\n\t\t * @type {ShaderPass}\n\t\t */\n\t\tthis.copyPass = new ShaderPass( CopyShader );\n\t\tthis.copyPass.material.blending = NoBlending;\n\n\t\t/**\n\t\t * The internal clock for managing time data.\n\t\t *\n\t\t * @private\n\t\t * @type {Clock}\n\t\t */\n\t\tthis.clock = new Clock();\n\n\t}\n\n\t/**\n\t * Swaps the internal read/write buffers.\n\t */\n\tswapBuffers() {\n\n\t\tconst tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\n\t}\n\n\t/**\n\t * Adds the given pass to the pass chain.\n\t *\n\t * @param {Pass} pass - The pass to add.\n\t */\n\taddPass( pass ) {\n\n\t\tthis.passes.push( pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t}\n\n\t/**\n\t * Inserts the given pass at a given index.\n\t *\n\t * @param {Pass} pass - The pass to insert.\n\t * @param {number} index - The index into the pass chain.\n\t */\n\tinsertPass( pass, index ) {\n\n\t\tthis.passes.splice( index, 0, pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t}\n\n\t/**\n\t * Removes the given pass from the pass chain.\n\t *\n\t * @param {Pass} pass - The pass to remove.\n\t */\n\tremovePass( pass ) {\n\n\t\tconst index = this.passes.indexOf( pass );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.passes.splice( index, 1 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.\n\t *\n\t * @param {number} passIndex - The pass index.\n\t * @return {boolean} Whether the pass for the given index is the last pass in the pass chain.\n\t */\n\tisLastEnabledPass( passIndex ) {\n\n\t\tfor ( let i = passIndex + 1; i < this.passes.length; i ++ ) {\n\n\t\t\tif ( this.passes[ i ].enabled ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Executes all enabled post-processing passes in order to produce the final frame.\n\t *\n\t * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes\n\t * its own time delta value.\n\t */\n\trender( deltaTime ) {\n\n\t\t// deltaTime value is in seconds\n\n\t\tif ( deltaTime === undefined ) {\n\n\t\t\tdeltaTime = this.clock.getDelta();\n\n\t\t}\n\n\t\tconst currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\tlet maskActive = false;\n\n\t\tfor ( let i = 0, il = this.passes.length; i < il; i ++ ) {\n\n\t\t\tconst pass = this.passes[ i ];\n\n\t\t\tif ( pass.enabled === false ) continue;\n\n\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\n\n\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\tconst context = this.renderer.getContext();\n\t\t\t\t\tconst stencil = this.renderer.state.buffers.stencil;\n\n\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\n\n\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\n\t\t\t}\n\n\t\t\tif ( MaskPass !== undefined ) {\n\n\t\t\t\tif ( pass instanceof MaskPass ) {\n\n\t\t\t\t\tmaskActive = true;\n\n\t\t\t\t} else if ( pass instanceof ClearMaskPass ) {\n\n\t\t\t\t\tmaskActive = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\t/**\n\t * Resets the internal state of the EffectComposer.\n\t *\n\t * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like\n\t * the one from the constructor. If set, it is used to setup the read and write buffers.\n\t */\n\treset( renderTarget ) {\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tconst size = this.renderer.getSize( new Vector2() );\n\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t}\n\n\t/**\n\t * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},\n\t * this method honors the current pixel ration.\n\t *\n\t * @param {number} width - The width in logical pixels.\n\t * @param {number} height - The height in logical pixels.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tconst effectiveWidth = this._width * this._pixelRatio;\n\t\tconst effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\n\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\n\n\t\tfor ( let i = 0; i < this.passes.length; i ++ ) {\n\n\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.\n\t * Setting the pixel ratio will automatically resize the composer.\n\t *\n\t * @param {number} pixelRatio - The pixel ratio to set.\n\t */\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the composer is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\n\t\tthis.copyPass.dispose();\n\n\t}\n\n}\n\nexport { EffectComposer };\n"],"names":[],"mappings":";;;;AAAA;AAOA;AACA;AACA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BC,GACD,MAAM;IAEL;;;;;;;EAOC,GACD,YAAa,QAAQ,EAAE,YAAY,CAAG;QAErC;;;;GAIC,GACD,IAAI,CAAC,QAAQ,GAAG;QAEhB,IAAI,CAAC,WAAW,GAAG,SAAS,aAAa;QAEzC,IAAK,iBAAiB,WAAY;YAEjC,MAAM,OAAO,SAAS,OAAO,CAAE,IAAI,iNAAO;YAC1C,IAAI,CAAC,MAAM,GAAG,KAAK,KAAK;YACxB,IAAI,CAAC,OAAO,GAAG,KAAK,MAAM;YAE1B,eAAe,IAAI,2NAAiB,CAAE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,WAAW,EAAE;gBAAE,MAAM,uNAAa;YAAC;YAC7H,aAAa,OAAO,CAAC,IAAI,GAAG;QAE7B,OAAO;YAEN,IAAI,CAAC,MAAM,GAAG,aAAa,KAAK;YAChC,IAAI,CAAC,OAAO,GAAG,aAAa,MAAM;QAEnC;QAEA,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,aAAa,GAAG,aAAa,KAAK;QACvC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,GAAG;QAElC;;;;;GAKC,GACD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,aAAa;QAErC;;;;;GAKC,GACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,aAAa;QAEpC;;;;;GAKC,GACD,IAAI,CAAC,cAAc,GAAG;QAEtB;;;;GAIC,GACD,IAAI,CAAC,MAAM,GAAG,EAAE;QAEhB;;;;;GAKC,GACD,IAAI,CAAC,QAAQ,GAAG,IAAI,6OAAU,CAAE,sOAAU;QAC1C,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,GAAG,oNAAU;QAE5C;;;;;GAKC,GACD,IAAI,CAAC,KAAK,GAAG,IAAI,+MAAK;IAEvB;IAEA;;EAEC,GACD,cAAc;QAEb,MAAM,MAAM,IAAI,CAAC,UAAU;QAC3B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,WAAW;QAClC,IAAI,CAAC,WAAW,GAAG;IAEpB;IAEA;;;;EAIC,GACD,QAAS,IAAI,EAAG;QAEf,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE;QAClB,KAAK,OAAO,CAAE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,WAAW;IAE9E;IAEA;;;;;EAKC,GACD,WAAY,IAAI,EAAE,KAAK,EAAG;QAEzB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,OAAO,GAAG;QAC9B,KAAK,OAAO,CAAE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,WAAW;IAE9E;IAEA;;;;EAIC,GACD,WAAY,IAAI,EAAG;QAElB,MAAM,QAAQ,IAAI,CAAC,MAAM,CAAC,OAAO,CAAE;QAEnC,IAAK,UAAU,CAAE,GAAI;YAEpB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,OAAO;QAE5B;IAED;IAEA;;;;;EAKC,GACD,kBAAmB,SAAS,EAAG;QAE9B,IAAM,IAAI,IAAI,YAAY,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,IAAO;YAE3D,IAAK,IAAI,CAAC,MAAM,CAAE,EAAG,CAAC,OAAO,EAAG;gBAE/B,OAAO;YAER;QAED;QAEA,OAAO;IAER;IAEA;;;;;EAKC,GACD,OAAQ,SAAS,EAAG;QAEnB,gCAAgC;QAEhC,IAAK,cAAc,WAAY;YAE9B,YAAY,IAAI,CAAC,KAAK,CAAC,QAAQ;QAEhC;QAEA,MAAM,sBAAsB,IAAI,CAAC,QAAQ,CAAC,eAAe;QAEzD,IAAI,aAAa;QAEjB,IAAM,IAAI,IAAI,GAAG,KAAK,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,IAAI,IAAO;YAExD,MAAM,OAAO,IAAI,CAAC,MAAM,CAAE,EAAG;YAE7B,IAAK,KAAK,OAAO,KAAK,OAAQ;YAE9B,KAAK,cAAc,GAAK,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,iBAAiB,CAAE;YACvE,KAAK,MAAM,CAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,UAAU,EAAE,WAAW;YAE1E,IAAK,KAAK,SAAS,EAAG;gBAErB,IAAK,YAAa;oBAEjB,MAAM,UAAU,IAAI,CAAC,QAAQ,CAAC,UAAU;oBACxC,MAAM,UAAU,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO;oBAEnD,yDAAyD;oBACzD,QAAQ,OAAO,CAAE,QAAQ,QAAQ,EAAE,GAAG;oBAEtC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,UAAU,EAAE;oBAExE,sDAAsD;oBACtD,QAAQ,OAAO,CAAE,QAAQ,KAAK,EAAE,GAAG;gBAEpC;gBAEA,IAAI,CAAC,WAAW;YAEjB;YAEA,IAAK,yOAAQ,KAAK,WAAY;gBAE7B,IAAK,gBAAgB,yOAAQ,EAAG;oBAE/B,aAAa;gBAEd,OAAO,IAAK,gBAAgB,8OAAa,EAAG;oBAE3C,aAAa;gBAEd;YAED;QAED;QAEA,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAE;IAEhC;IAEA;;;;;EAKC,GACD,MAAO,YAAY,EAAG;QAErB,IAAK,iBAAiB,WAAY;YAEjC,MAAM,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAE,IAAI,iNAAO;YAC/C,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa;YAC9C,IAAI,CAAC,MAAM,GAAG,KAAK,KAAK;YACxB,IAAI,CAAC,OAAO,GAAG,KAAK,MAAM;YAE1B,eAAe,IAAI,CAAC,aAAa,CAAC,KAAK;YACvC,aAAa,OAAO,CAAE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,WAAW;QAEtF;QAEA,IAAI,CAAC,aAAa,CAAC,OAAO;QAC1B,IAAI,CAAC,aAAa,CAAC,OAAO;QAC1B,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,aAAa,GAAG,aAAa,KAAK;QAEvC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,aAAa;QACrC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,aAAa;IAErC;IAEA;;;;;;EAMC,GACD,QAAS,KAAK,EAAE,MAAM,EAAG;QAExB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,OAAO,GAAG;QAEf,MAAM,iBAAiB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,WAAW;QACrD,MAAM,kBAAkB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,WAAW;QAEvD,IAAI,CAAC,aAAa,CAAC,OAAO,CAAE,gBAAgB;QAC5C,IAAI,CAAC,aAAa,CAAC,OAAO,CAAE,gBAAgB;QAE5C,IAAM,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,IAAO;YAE/C,IAAI,CAAC,MAAM,CAAE,EAAG,CAAC,OAAO,CAAE,gBAAgB;QAE3C;IAED;IAEA;;;;;EAKC,GACD,cAAe,UAAU,EAAG;QAE3B,IAAI,CAAC,WAAW,GAAG;QAEnB,IAAI,CAAC,OAAO,CAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO;IAExC;IAEA;;;EAGC,GACD,UAAU;QAET,IAAI,CAAC,aAAa,CAAC,OAAO;QAC1B,IAAI,CAAC,aAAa,CAAC,OAAO;QAE1B,IAAI,CAAC,QAAQ,CAAC,OAAO;IAEtB;AAED","ignoreList":[0]}},
    {"offset": {"line": 719, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/.pnpm/three%400.182.0/node_modules/three/examples/jsm/postprocessing/RenderPass.js"],"sourcesContent":["import {\n\tColor\n} from 'three';\nimport { Pass } from './Pass.js';\n\n/**\n * This class represents a render pass. It takes a camera and a scene and produces\n * a beauty pass for subsequent post processing effects.\n *\n * ```js\n * const renderPass = new RenderPass( scene, camera );\n * composer.addPass( renderPass );\n * ```\n *\n * @augments Pass\n * @three_import import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n */\nclass RenderPass extends Pass {\n\n\t/**\n\t * Constructs a new render pass.\n\t *\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera.\n\t * @param {?Material} [overrideMaterial=null] - The override material. If set, this material is used\n\t * for all objects in the scene.\n\t * @param {?(number|Color|string)} [clearColor=null] - The clear color of the render pass.\n\t * @param {?number} [clearAlpha=null] - The clear alpha of the render pass.\n\t */\n\tconstructor( scene, camera, overrideMaterial = null, clearColor = null, clearAlpha = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scene to render.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The override material. If set, this material is used\n\t\t * for all objects in the scene.\n\t\t *\n\t\t * @type {?Material}\n\t\t * @default null\n\t\t */\n\t\tthis.overrideMaterial = overrideMaterial;\n\n\t\t/**\n\t\t * The clear color of the render pass.\n\t\t *\n\t\t * @type {?(number|Color|string)}\n\t\t * @default null\n\t\t */\n\t\tthis.clearColor = clearColor;\n\n\t\t/**\n\t\t * The clear alpha of the render pass.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.clearAlpha = clearAlpha;\n\n\t\t/**\n\t\t * Overwritten to perform a clear operation by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clear = true;\n\n\t\t/**\n\t\t * If set to `true`, only the depth can be cleared when `clear` is to `false`.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clearDepth = false;\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t\t/**\n\t\t * This flag indicates that this pass renders the scene itself.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderPass = true;\n\n\t\tthis._oldClearColor = new Color();\n\n\t}\n\n\t/**\n\t * Performs a beauty pass with the configured scene and camera.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tlet oldClearAlpha, oldOverrideMaterial;\n\n\t\tif ( this.overrideMaterial !== null ) {\n\n\t\t\toldOverrideMaterial = this.scene.overrideMaterial;\n\n\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t}\n\n\t\tif ( this.clearColor !== null ) {\n\n\t\t\trenderer.getClearColor( this._oldClearColor );\n\t\t\trenderer.setClearColor( this.clearColor, renderer.getClearAlpha() );\n\n\t\t}\n\n\t\tif ( this.clearAlpha !== null ) {\n\n\t\t\toldClearAlpha = renderer.getClearAlpha();\n\t\t\trenderer.setClearAlpha( this.clearAlpha );\n\n\t\t}\n\n\t\tif ( this.clearDepth == true ) {\n\n\t\t\trenderer.clearDepth();\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\n\t\tif ( this.clear === true ) {\n\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// restore\n\n\t\tif ( this.clearColor !== null ) {\n\n\t\t\trenderer.setClearColor( this._oldClearColor );\n\n\t\t}\n\n\t\tif ( this.clearAlpha !== null ) {\n\n\t\t\trenderer.setClearAlpha( oldClearAlpha );\n\n\t\t}\n\n\t\tif ( this.overrideMaterial !== null ) {\n\n\t\t\tthis.scene.overrideMaterial = oldOverrideMaterial;\n\n\t\t}\n\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n}\n\nexport { RenderPass };\n"],"names":[],"mappings":";;;;AAAA;AAGA;;;AAEA;;;;;;;;;;;CAWC,GACD,MAAM,mBAAmB,iOAAI;IAE5B;;;;;;;;;EASC,GACD,YAAa,KAAK,EAAE,MAAM,EAAE,mBAAmB,IAAI,EAAE,aAAa,IAAI,EAAE,aAAa,IAAI,CAAG;QAE3F,KAAK;QAEL;;;;GAIC,GACD,IAAI,CAAC,KAAK,GAAG;QAEb;;;;GAIC,GACD,IAAI,CAAC,MAAM,GAAG;QAEd;;;;;;GAMC,GACD,IAAI,CAAC,gBAAgB,GAAG;QAExB;;;;;GAKC,GACD,IAAI,CAAC,UAAU,GAAG;QAElB;;;;;GAKC,GACD,IAAI,CAAC,UAAU,GAAG;QAElB;;;;;GAKC,GACD,IAAI,CAAC,KAAK,GAAG;QAEb;;;;;GAKC,GACD,IAAI,CAAC,UAAU,GAAG;QAElB;;;;;GAKC,GACD,IAAI,CAAC,SAAS,GAAG;QAEjB;;;;;;GAMC,GACD,IAAI,CAAC,YAAY,GAAG;QAEpB,IAAI,CAAC,cAAc,GAAG,IAAI,+MAAK;IAEhC;IAEA;;;;;;;;;;EAUC,GACD,OAAQ,QAAQ,EAAE,WAAW,EAAE,WAAW,0BAA0B,GAA3B,EAAgC;QAExE,MAAM,eAAe,SAAS,SAAS;QACvC,SAAS,SAAS,GAAG;QAErB,IAAI,eAAe;QAEnB,IAAK,IAAI,CAAC,gBAAgB,KAAK,MAAO;YAErC,sBAAsB,IAAI,CAAC,KAAK,CAAC,gBAAgB;YAEjD,IAAI,CAAC,KAAK,CAAC,gBAAgB,GAAG,IAAI,CAAC,gBAAgB;QAEpD;QAEA,IAAK,IAAI,CAAC,UAAU,KAAK,MAAO;YAE/B,SAAS,aAAa,CAAE,IAAI,CAAC,cAAc;YAC3C,SAAS,aAAa,CAAE,IAAI,CAAC,UAAU,EAAE,SAAS,aAAa;QAEhE;QAEA,IAAK,IAAI,CAAC,UAAU,KAAK,MAAO;YAE/B,gBAAgB,SAAS,aAAa;YACtC,SAAS,aAAa,CAAE,IAAI,CAAC,UAAU;QAExC;QAEA,IAAK,IAAI,CAAC,UAAU,IAAI,MAAO;YAE9B,SAAS,UAAU;QAEpB;QAEA,SAAS,eAAe,CAAE,IAAI,CAAC,cAAc,GAAG,OAAO;QAEvD,IAAK,IAAI,CAAC,KAAK,KAAK,MAAO;YAE1B,mHAAmH;YACnH,SAAS,KAAK,CAAE,SAAS,cAAc,EAAE,SAAS,cAAc,EAAE,SAAS,gBAAgB;QAE5F;QAEA,SAAS,MAAM,CAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;QAExC,UAAU;QAEV,IAAK,IAAI,CAAC,UAAU,KAAK,MAAO;YAE/B,SAAS,aAAa,CAAE,IAAI,CAAC,cAAc;QAE5C;QAEA,IAAK,IAAI,CAAC,UAAU,KAAK,MAAO;YAE/B,SAAS,aAAa,CAAE;QAEzB;QAEA,IAAK,IAAI,CAAC,gBAAgB,KAAK,MAAO;YAErC,IAAI,CAAC,KAAK,CAAC,gBAAgB,GAAG;QAE/B;QAEA,SAAS,SAAS,GAAG;IAEtB;AAED","ignoreList":[0]}},
    {"offset": {"line": 859, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/.pnpm/three%400.182.0/node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js"],"sourcesContent":["import {\n\tColor\n} from 'three';\n\n/**\n * @module LuminosityHighPassShader\n * @three_import import { LuminosityHighPassShader } from 'three/addons/shaders/LuminosityHighPassShader.js';\n */\n\n/**\n * Luminosity high pass shader.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst LuminosityHighPassShader = {\n\n\tname: 'LuminosityHighPassShader',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'luminosityThreshold': { value: 1.0 },\n\t\t'smoothWidth': { value: 1.0 },\n\t\t'defaultColor': { value: new Color( 0x000000 ) },\n\t\t'defaultOpacity': { value: 0.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tfloat v = luminance( texel.xyz );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}`\n\n};\n\nexport { LuminosityHighPassShader };\n"],"names":[],"mappings":";;;;AAAA;;AAIA;;;CAGC,GAED;;;;;CAKC,GACD,MAAM,2BAA2B;IAEhC,MAAM;IAEN,UAAU;QAET,YAAY;YAAE,OAAO;QAAK;QAC1B,uBAAuB;YAAE,OAAO;QAAI;QACpC,eAAe;YAAE,OAAO;QAAI;QAC5B,gBAAgB;YAAE,OAAO,IAAI,+MAAK,CAAE;QAAW;QAC/C,kBAAkB;YAAE,OAAO;QAAI;IAEhC;IAEA,cAAc,QAAQ,GAAE,CAAC;;;;;;;;;;GAUvB,CAAC;IAEH,gBAAgB,QAAQ,GAAE,CAAC;;;;;;;;;;;;;;;;;;;;;;GAsBzB,CAAC;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 932, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/.pnpm/three%400.182.0/node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tHalfFloatType,\n\tMeshBasicMaterial,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * This pass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * When using this pass, tone mapping must be enabled in the renderer settings.\n *\n * Reference:\n * - [Bloom in Unreal Engine](https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/)\n *\n * ```js\n * const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );\n * const bloomPass = new UnrealBloomPass( resolution, 1.5, 0.4, 0.85 );\n * composer.addPass( bloomPass );\n * ```\n *\n * @augments Pass\n * @three_import import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n */\nclass UnrealBloomPass extends Pass {\n\n\t/**\n\t * Constructs a new Unreal Bloom pass.\n\t *\n\t * @param {Vector2} [resolution] - The effect's resolution.\n\t * @param {number} [strength=1] - The Bloom strength.\n\t * @param {number} radius - The Bloom radius.\n\t * @param {number} threshold - The luminance threshold limits which bright areas contribute to the Bloom effect.\n\t */\n\tconstructor( resolution, strength = 1, radius, threshold ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The Bloom strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.strength = strength;\n\n\t\t/**\n\t\t * The Bloom radius. Must be in the range `[0,1]`.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.radius = radius;\n\n\t\t/**\n\t\t * The luminance threshold limits which bright areas contribute to the Bloom effect.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.threshold = threshold;\n\n\t\t/**\n\t\t * The effect's resolution.\n\t\t *\n\t\t * @type {Vector2}\n\t\t * @default (256,256)\n\t\t */\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\t/**\n\t\t * The effect's clear color\n\t\t *\n\t\t * @type {Color}\n\t\t * @default (0,0,0)\n\t\t */\n\t\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t\t// internals\n\n\t\t// render targets\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tlet resx = Math.round( this.resolution.x / 2 );\n\t\tlet resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizontal = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizontal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizontal );\n\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tconst highPassShader = LuminosityHighPassShader;\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader\n\t\t} );\n\n\t\t// gaussian blur materials\n\n\t\tthis.separableBlurMaterials = [];\n\t\t// These sizes have been changed to account for the altered coefficients-calculation to avoid blockiness,\n\t\t// while retaining the same blur-strength. For details see https://github.com/mrdoob/three.js/pull/31528\n\t\tconst kernelSizeArray = [ 6, 10, 14, 18, 22 ];\n\t\tresx = Math.round( this.resolution.x / 2 );\n\t\tresy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this._getSeparableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// composite material\n\n\t\tthis.compositeMaterial = this._getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\n\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\t// blend material\n\n\t\tthis.copyUniforms = UniformsUtils.clone( CopyShader.uniforms );\n\n\t\tthis.blendMaterial = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: CopyShader.vertexShader,\n\t\t\tfragmentShader: CopyShader.fragmentShader,\n\t\t\tpremultipliedAlpha: true,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis._oldClearAlpha = 1;\n\n\t\tthis._basic = new MeshBasicMaterial();\n\n\t\tthis._fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t\t//\n\n\t\tfor ( let i = 0; i < this.separableBlurMaterials.length; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials[ i ].dispose();\n\n\t\t}\n\n\t\tthis.compositeMaterial.dispose();\n\t\tthis.blendMaterial.dispose();\n\t\tthis._basic.dispose();\n\n\t\t//\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs the Bloom pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tthis._oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis._fsQuad.material = this._basic;\n\t\t\tthis._basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\n\t\tthis._fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis._fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tlet inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis._fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis._fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis._fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis._fsQuad.material = this.blendMaterial;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this._oldClearColor, this._oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\t// internals\n\n\t_getSeparableBlurMaterial( kernelRadius ) {\n\n\t\tconst coefficients = [];\n\t\tconst sigma = kernelRadius / 3;\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( sigma * sigma ) ) / sigma );\n\n\t\t}\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_RADIUS': kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'invSize': { value: new Vector2( 0.5, 0.5 ) }, // inverse texture size\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'gaussianCoefficients': { value: coefficients } // precomputed Gaussian coefficients\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\n\t\t\t\t\tfor ( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\n\t\t\t\t\t\tfloat x = float( i );\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += ( sample1 + sample2 ) * w;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor = vec4( diffuseSum, 1.0 );\n\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\t_getCompositeMaterial( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'NUM_MIPS': nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'blurTexture1': { value: null },\n\t\t\t\t'blurTexture2': { value: null },\n\t\t\t\t'blurTexture3': { value: null },\n\t\t\t\t'blurTexture4': { value: null },\n\t\t\t\t'blurTexture5': { value: null },\n\t\t\t\t'bloomStrength': { value: 1.0 },\n\t\t\t\t'bloomFactors': { value: null },\n\t\t\t\t'bloomTintColors': { value: null },\n\t\t\t\t'bloomRadius': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor( const in float factor ) {\n\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix( factor, mirrorFactor, bloomRadius );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// 3.0 for backwards compatibility with previous alpha-based intensity\n\t\t\t\t\tvec3 bloom = 3.0 * bloomStrength * (\n\t\t\t\t\t\tlerpBloomFactor( bloomFactors[ 0 ] ) * bloomTintColors[ 0 ] * texture2D( blurTexture1, vUv ).rgb +\n\t\t\t\t\t\tlerpBloomFactor( bloomFactors[ 1 ] ) * bloomTintColors[ 1 ] * texture2D( blurTexture2, vUv ).rgb +\n\t\t\t\t\t\tlerpBloomFactor( bloomFactors[ 2 ] ) * bloomTintColors[ 2 ] * texture2D( blurTexture3, vUv ).rgb +\n\t\t\t\t\t\tlerpBloomFactor( bloomFactors[ 3 ] ) * bloomTintColors[ 3 ] * texture2D( blurTexture4, vUv ).rgb +\n\t\t\t\t\t\tlerpBloomFactor( bloomFactors[ 4 ] ) * bloomTintColors[ 4 ] * texture2D( blurTexture5, vUv ).rgb\n\t\t\t\t\t);\n\n\t\t\t\t\tfloat bloomAlpha = max( bloom.r, max( bloom.g, bloom.b ) );\n\t\t\t\t\tgl_FragColor = vec4( bloom, bloomAlpha );\n\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1372, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/.pnpm/three%400.182.0/node_modules/three/examples/jsm/shaders/OutputShader.js"],"sourcesContent":["/**\n * @module OutputShader\n * @three_import import { OutputShader } from 'three/addons/shaders/OutputShader.js';\n */\n\n/**\n * Performs tone mapping and color space conversion for\n * FX workflows.\n *\n * Used by {@link OutputPass}.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst OutputShader = {\n\n\tname: 'OutputShader',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'toneMappingExposure': { value: 1 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tprecision highp float;\n\n\t\tuniform mat4 modelViewMatrix;\n\t\tuniform mat4 projectionMatrix;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\t#include <tonemapping_pars_fragment>\n\t\t#include <colorspace_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\n\t\t\t// tone mapping\n\n\t\t\t#ifdef LINEAR_TONE_MAPPING\n\n\t\t\t\tgl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( REINHARD_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( CINEON_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( ACES_FILMIC_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( AGX_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( NEUTRAL_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( CUSTOM_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );\n\n\t\t\t#endif\n\n\t\t\t// color space\n\n\t\t\t#ifdef SRGB_TRANSFER\n\n\t\t\t\tgl_FragColor = sRGBTransferOETF( gl_FragColor );\n\n\t\t\t#endif\n\n\t\t}`\n\n};\n\nexport { OutputShader };\n"],"names":[],"mappings":";;;;AAAA;;;CAGC,GAED;;;;;;;;CAQC,GACD,MAAM,eAAe;IAEpB,MAAM;IAEN,UAAU;QAET,YAAY;YAAE,OAAO;QAAK;QAC1B,uBAAuB;YAAE,OAAO;QAAE;IAEnC;IAEA,cAAc,QAAQ,GAAE,CAAC;;;;;;;;;;;;;;;;GAgBvB,CAAC;IAEH,gBAAgB,QAAQ,GAAE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuDzB,CAAC;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 1476, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/.pnpm/three%400.182.0/node_modules/three/examples/jsm/postprocessing/OutputPass.js"],"sourcesContent":["import {\n\tColorManagement,\n\tRawShaderMaterial,\n\tUniformsUtils,\n\tLinearToneMapping,\n\tReinhardToneMapping,\n\tCineonToneMapping,\n\tAgXToneMapping,\n\tACESFilmicToneMapping,\n\tNeutralToneMapping,\n\tCustomToneMapping,\n\tSRGBTransfer\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { OutputShader } from '../shaders/OutputShader.js';\n\n/**\n * This pass is responsible for including tone mapping and color space conversion\n * into your pass chain. In most cases, this pass should be included at the end\n * of each pass chain. If a pass requires sRGB input (e.g. like FXAA), the pass\n * must follow `OutputPass` in the pass chain.\n *\n * The tone mapping and color space settings are extracted from the renderer.\n *\n * ```js\n * const outputPass = new OutputPass();\n * composer.addPass( outputPass );\n * ```\n *\n * @augments Pass\n * @three_import import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n */\nclass OutputPass extends Pass {\n\n\t/**\n\t * Constructs a new output pass.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag indicates that this is an output pass.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOutputPass = true;\n\n\t\t/**\n\t\t * The pass uniforms.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.uniforms = UniformsUtils.clone( OutputShader.uniforms );\n\n\t\t/**\n\t\t * The pass material.\n\t\t *\n\t\t * @type {RawShaderMaterial}\n\t\t */\n\t\tthis.material = new RawShaderMaterial( {\n\t\t\tname: OutputShader.name,\n\t\t\tuniforms: this.uniforms,\n\t\t\tvertexShader: OutputShader.vertexShader,\n\t\t\tfragmentShader: OutputShader.fragmentShader\n\t\t} );\n\n\t\t// internals\n\n\t\tthis._fsQuad = new FullScreenQuad( this.material );\n\n\t\tthis._outputColorSpace = null;\n\t\tthis._toneMapping = null;\n\n\t}\n\n\t/**\n\t * Performs the output pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive */ ) {\n\n\t\tthis.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.uniforms[ 'toneMappingExposure' ].value = renderer.toneMappingExposure;\n\n\t\t// rebuild defines if required\n\n\t\tif ( this._outputColorSpace !== renderer.outputColorSpace || this._toneMapping !== renderer.toneMapping ) {\n\n\t\t\tthis._outputColorSpace = renderer.outputColorSpace;\n\t\t\tthis._toneMapping = renderer.toneMapping;\n\n\t\t\tthis.material.defines = {};\n\n\t\t\tif ( ColorManagement.getTransfer( this._outputColorSpace ) === SRGBTransfer ) this.material.defines.SRGB_TRANSFER = '';\n\n\t\t\tif ( this._toneMapping === LinearToneMapping ) this.material.defines.LINEAR_TONE_MAPPING = '';\n\t\t\telse if ( this._toneMapping === ReinhardToneMapping ) this.material.defines.REINHARD_TONE_MAPPING = '';\n\t\t\telse if ( this._toneMapping === CineonToneMapping ) this.material.defines.CINEON_TONE_MAPPING = '';\n\t\t\telse if ( this._toneMapping === ACESFilmicToneMapping ) this.material.defines.ACES_FILMIC_TONE_MAPPING = '';\n\t\t\telse if ( this._toneMapping === AgXToneMapping ) this.material.defines.AGX_TONE_MAPPING = '';\n\t\t\telse if ( this._toneMapping === NeutralToneMapping ) this.material.defines.NEUTRAL_TONE_MAPPING = '';\n\t\t\telse if ( this._toneMapping === CustomToneMapping ) this.material.defines.CUSTOM_TONE_MAPPING = '';\n\n\t\t\tthis.material.needsUpdate = true;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.renderToScreen === true ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.material.dispose();\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n}\n\nexport { OutputPass };\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}