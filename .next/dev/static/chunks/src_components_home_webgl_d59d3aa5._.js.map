{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/home/webgl/ghost/GhostSphere.tsx"],"sourcesContent":["'use client';\n\nimport React, { useLayoutEffect, useMemo, useRef, useState } from 'react';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { GhostParams, FluorescentColors } from './GhostParams';\nimport { Eyes } from '../Eyes';\n\ninterface GhostSphereProps {\n  positionRef: React.MutableRefObject<THREE.Vector3>;\n  onMovementUpdate: (isMoving: boolean, speed: number) => void;\n}\n\nexport function GhostSphere({\n  positionRef,\n  onMovementUpdate,\n}: GhostSphereProps) {\n  const meshRef = useRef<THREE.Mesh>(null);\n  const groupRef = useRef<THREE.Group>(null);\n  const { pointer, viewport } = useThree();\n\n  // Estado para controle de brilho dos olhos\n  const [eyeOpacity, setEyeOpacity] = useState(0);\n  const currentMovementRef = useRef(0);\n\n  // Criar geometria deformada uma única vez\n  const geometry = useMemo(() => {\n    const geo = new THREE.SphereGeometry(2, 40, 40);\n    const positions = geo.attributes.position.array;\n\n    // Aplicar deformação \"wavy\" na parte inferior\n    for (let i = 0; i < positions.length; i += 3) {\n      if (positions[i + 1] < -0.2) {\n        const x = positions[i];\n        const z = positions[i + 2];\n        const noise1 = Math.sin(x * 5) * 0.35;\n        const noise2 = Math.cos(z * 4) * 0.25;\n        const noise3 = Math.sin((x + z) * 3) * 0.15;\n        positions[i + 1] = -2.0 + (noise1 + noise2 + noise3);\n      }\n    }\n    geo.computeVertexNormals();\n    return geo;\n  }, []);\n\n  useFrame((state, delta) => {\n    if (!groupRef.current || !meshRef.current) return;\n\n    const time = state.clock.elapsedTime;\n\n    // --- Movimento (Mouse Follow) ---\n    // Converter pointer (-1 a 1) para coordenadas do mundo baseadas no viewport\n    // Ajuste os multiplicadores (11 e 7 no original) conforme o tamanho do seu viewport\n    const targetX = pointer.x * (viewport.width / 2) * 0.8;\n    const targetY = pointer.y * (viewport.height / 2) * 0.8;\n\n    const prevPos = groupRef.current.position.clone();\n\n    // Lerp suave para posição do mouse\n    groupRef.current.position.x +=\n      (targetX - groupRef.current.position.x) * GhostParams.followSpeed;\n    groupRef.current.position.y +=\n      (targetY - groupRef.current.position.y) * GhostParams.followSpeed;\n\n    // Atualizar ref global para outros componentes (atmosfera, partículas)\n    positionRef.current.copy(groupRef.current.position);\n\n    // --- Flutuação ---\n    const float1 = Math.sin(time * GhostParams.floatSpeed * 1.5) * 0.03;\n    const float2 = Math.cos(time * GhostParams.floatSpeed * 0.7) * 0.018;\n    const float3 = Math.sin(time * GhostParams.floatSpeed * 2.3) * 0.008;\n    groupRef.current.position.y += float1 + float2 + float3;\n\n    // --- Rotação e Tilt ---\n    const mouseDirection = new THREE.Vector2(\n      targetX - groupRef.current.position.x,\n      targetY - groupRef.current.position.y\n    ).normalize();\n\n    const tiltStrength = 0.1 * GhostParams.wobbleAmount;\n    const tiltDecay = 0.95;\n\n    meshRef.current.rotation.z =\n      meshRef.current.rotation.z * tiltDecay +\n      -mouseDirection.x * tiltStrength * (1 - tiltDecay);\n    meshRef.current.rotation.x =\n      meshRef.current.rotation.x * tiltDecay +\n      mouseDirection.y * tiltStrength * (1 - tiltDecay);\n    meshRef.current.rotation.y =\n      Math.sin(time * 1.4) * 0.05 * GhostParams.wobbleAmount;\n\n    // --- Escala (Respiração) ---\n    const pulse1 =\n      Math.sin(time * GhostParams.pulseSpeed) * GhostParams.pulseIntensity;\n    const scaleVariation =\n      1 +\n      Math.sin(time * 2.1) * 0.025 * GhostParams.wobbleAmount +\n      pulse1 * 0.015;\n    const scaleBreath = 1 + Math.sin(time * 0.8) * 0.012;\n    const finalScale = scaleVariation * scaleBreath;\n    meshRef.current.scale.set(finalScale, finalScale, finalScale);\n\n    // --- Material Pulsing ---\n    const breathe = Math.sin(time * 0.6) * 0.12;\n    const mat = meshRef.current.material as THREE.MeshStandardMaterial;\n    mat.emissiveIntensity = GhostParams.emissiveIntensity + pulse1 + breathe;\n\n    // --- Eye Logic ---\n    const movementAmount = prevPos.distanceTo(groupRef.current.position);\n    currentMovementRef.current =\n      currentMovementRef.current * GhostParams.eyeGlowDecay +\n      movementAmount * (1 - GhostParams.eyeGlowDecay);\n\n    const isMoving = currentMovementRef.current > GhostParams.movementThreshold;\n    const targetGlow = isMoving ? 1.0 : 0.0;\n    const glowChangeSpeed = isMoving\n      ? GhostParams.eyeGlowResponse * 2\n      : GhostParams.eyeGlowResponse;\n\n    setEyeOpacity((prev) => prev + (targetGlow - prev) * glowChangeSpeed);\n\n    // Notificar pai sobre movimento para partículas\n    onMovementUpdate(isMoving, movementAmount * 100); // Scale up movement for logic\n  });\n\n  return (\n    <group ref={groupRef}>\n      <mesh ref={meshRef} geometry={geometry}>\n        <meshStandardMaterial\n          color={GhostParams.bodyColor}\n          transparent\n          opacity={GhostParams.ghostOpacity}\n          emissive={GhostParams.glowColor}\n          emissiveIntensity={GhostParams.emissiveIntensity}\n          roughness={0.02}\n          metalness={0.0}\n          side={THREE.DoubleSide}\n          alphaTest={0.1}\n        />\n      </mesh>\n      <Eyes eyeOpacity={eyeOpacity} />\n    </group>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/home/webgl/AtmosphereVeil.tsx"],"sourcesContent":["'use client';\n\nimport React, { useMemo, useRef } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { GhostParams } from './ghost/GhostParams';\n\ninterface AtmosphereVeilProps {\n  ghostPosition: React.MutableRefObject<THREE.Vector3>;\n}\n\nconst vertexShader = `\n  varying vec2 vUv;\n  varying vec3 vWorldPosition;\n  void main() {\n    vUv = uv;\n    vec4 worldPos = modelMatrix * vec4(position, 1.0);\n    vWorldPosition = worldPos.xyz;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n\nconst fragmentShader = `\n  uniform vec3 ghostPosition;\n  uniform float revealRadius;\n  uniform float fadeStrength;\n  uniform float baseOpacity;\n  uniform float revealOpacity;\n  uniform float time;\n  varying vec2 vUv;\n  varying vec3 vWorldPosition;\n  \n  void main() {\n    float dist = distance(vWorldPosition.xy, ghostPosition.xy);\n    \n    // Pulsing reveal radius\n    float dynamicRadius = revealRadius + sin(time * 2.0) * 5.0;\n    \n    // Create smooth reveal gradient\n    float reveal = smoothstep(dynamicRadius * 0.2, dynamicRadius, dist);\n    reveal = pow(reveal, fadeStrength);\n    \n    // Mix between revealed and base opacity\n    float opacity = mix(revealOpacity, baseOpacity, reveal);\n    \n    // EXTREMELY low RGB values to avoid bloom interference\n    gl_FragColor = vec4(0.001, 0.001, 0.002, opacity);\n  }\n`;\n\nexport function AtmosphereVeil({ ghostPosition }: AtmosphereVeilProps) {\n  const materialRef = useRef<THREE.ShaderMaterial>(null);\n\n  const uniforms = useMemo(\n    () => ({\n      ghostPosition: { value: new THREE.Vector3(0, 0, 0) },\n      revealRadius: { value: GhostParams.revealRadius },\n      fadeStrength: { value: GhostParams.fadeStrength },\n      baseOpacity: { value: GhostParams.baseOpacity },\n      revealOpacity: { value: GhostParams.revealOpacity },\n      time: { value: 0 },\n    }),\n    []\n  );\n\n  useFrame((state) => {\n    if (materialRef.current) {\n      materialRef.current.uniforms.time.value = state.clock.elapsedTime;\n      materialRef.current.uniforms.ghostPosition.value.copy(\n        ghostPosition.current\n      );\n    }\n  });\n\n  return (\n    <mesh position={[0, 0, -50]} renderOrder={-100}>\n      <planeGeometry args={[300, 300]} />\n      <shaderMaterial\n        ref={materialRef}\n        vertexShader={vertexShader}\n        fragmentShader={fragmentShader}\n        uniforms={uniforms}\n        transparent\n        depthWrite={false}\n      />\n    </mesh>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;;;AALA;;;;;AAWA,MAAM,eAAe,CAAC;;;;;;;;;AAStB,CAAC;AAED,MAAM,iBAAiB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BxB,CAAC;AAEM,SAAS,eAAe,EAAE,aAAa,EAAuB;;IACnE,MAAM,cAAc,IAAA,gXAAM,EAAuB;IAEjD,MAAM,WAAW,IAAA,iXAAO;4CACtB,IAAM,CAAC;gBACL,eAAe;oBAAE,OAAO,IAAI,iNAAa,CAAC,GAAG,GAAG;gBAAG;gBACnD,cAAc;oBAAE,OAAO,4KAAW,CAAC,YAAY;gBAAC;gBAChD,cAAc;oBAAE,OAAO,4KAAW,CAAC,YAAY;gBAAC;gBAChD,aAAa;oBAAE,OAAO,4KAAW,CAAC,WAAW;gBAAC;gBAC9C,eAAe;oBAAE,OAAO,4KAAW,CAAC,aAAa;gBAAC;gBAClD,MAAM;oBAAE,OAAO;gBAAE;YACnB,CAAC;2CACD,EAAE;IAGJ,IAAA,2aAAQ;mCAAC,CAAC;YACR,IAAI,YAAY,OAAO,EAAE;gBACvB,YAAY,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,GAAG,MAAM,KAAK,CAAC,WAAW;gBACjE,YAAY,OAAO,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CACnD,cAAc,OAAO;YAEzB;QACF;;IAEA,qBACE,sYAAC;QAAK,UAAU;YAAC;YAAG;YAAG,CAAC;SAAG;QAAE,aAAa,CAAC;;0BACzC,sYAAC;gBAAc,MAAM;oBAAC;oBAAK;iBAAI;;;;;;0BAC/B,sYAAC;gBACC,KAAK;gBACL,cAAc;gBACd,gBAAgB;gBAChB,UAAU;gBACV,WAAW;gBACX,YAAY;;;;;;;;;;;;AAIpB;GArCgB;;QAed,2aAAQ;;;KAfM"}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/home/webgl/Particles.tsx"],"sourcesContent":["'use client';\n\nimport React, { useRef, useMemo, useState } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { GhostParams } from './ghost/GhostParams';\n\ninterface ParticlesProps {\n  ghostPosition: React.MutableRefObject<THREE.Vector3>;\n  isGhostMoving: boolean;\n  movementSpeed: number;\n}\n\ntype ParticleData = {\n  mesh: THREE.Mesh;\n  life: number;\n  decay: number;\n  velocity: THREE.Vector3;\n  rotationSpeed: THREE.Euler;\n};\n\nexport function Particles({\n  ghostPosition,\n  isGhostMoving,\n  movementSpeed,\n}: ParticlesProps) {\n  const groupRef = useRef<THREE.Group>(null);\n  const particlesRef = useRef<ParticleData[]>([]);\n  const lastEmitTime = useRef(0);\n\n  // Geometrias reutilizáveis\n  const geometries = useMemo(\n    () => [\n      new THREE.SphereGeometry(0.05, 6, 6),\n      new THREE.TetrahedronGeometry(0.04, 0),\n      new THREE.OctahedronGeometry(0.045, 0),\n    ],\n    []\n  );\n\n  const material = useMemo(\n    () =>\n      new THREE.MeshBasicMaterial({\n        color: GhostParams.particleColor,\n        transparent: true,\n        opacity: 0,\n        alphaTest: 0.1,\n      }),\n    []\n  );\n\n  useFrame((state) => {\n    const time = state.clock.elapsedTime;\n    const now = performance.now();\n\n    // --- Emissão de Partículas ---\n    const shouldCreate = GhostParams.createParticlesOnlyWhenMoving\n      ? isGhostMoving && movementSpeed > 0.5 // Ajuste de sensibilidade\n      : true;\n\n    if (shouldCreate && now - lastEmitTime.current > 100) {\n      const count = Math.min(GhostParams.particleCreationRate, 5); // Limite por frame\n\n      for (let i = 0; i < count; i++) {\n        if (particlesRef.current.length >= GhostParams.particleCount) break;\n\n        const geom = geometries[Math.floor(Math.random() * geometries.length)];\n        const mesh = new THREE.Mesh(geom, material.clone());\n\n        // Posição inicial (atrás do fantasma)\n        mesh.position.copy(ghostPosition.current);\n        mesh.position.z -= 0.8 + Math.random() * 0.6;\n        mesh.position.x += (Math.random() - 0.5) * 3.5;\n        mesh.position.y += (Math.random() - 0.5) * 3.5 - 0.8;\n\n        const scale = 0.6 + Math.random() * 0.7;\n        mesh.scale.set(scale, scale, scale);\n\n        // Cor aleatória leve\n        const color = new THREE.Color(GhostParams.particleColor);\n        color.offsetHSL(Math.random() * 0.1 - 0.05, 0, 0);\n        (mesh.material as THREE.MeshBasicMaterial).color = color;\n        (mesh.material as THREE.MeshBasicMaterial).opacity =\n          Math.random() * 0.9;\n\n        groupRef.current?.add(mesh);\n\n        particlesRef.current.push({\n          mesh,\n          life: 1.0,\n          decay: Math.random() * 0.003 + GhostParams.particleDecayRate,\n          velocity: new THREE.Vector3(\n            (Math.random() - 0.5) * 0.012,\n            (Math.random() - 0.5) * 0.012 - 0.002,\n            (Math.random() - 0.5) * 0.012 - 0.006\n          ),\n          rotationSpeed: new THREE.Euler(\n            (Math.random() - 0.5) * 0.015,\n            (Math.random() - 0.5) * 0.015,\n            (Math.random() - 0.5) * 0.015\n          ),\n        });\n      }\n      lastEmitTime.current = now;\n    }\n\n    // --- Atualização de Partículas ---\n    for (let i = particlesRef.current.length - 1; i >= 0; i--) {\n      const p = particlesRef.current[i];\n      p.life -= p.decay;\n      (p.mesh.material as THREE.MeshBasicMaterial).opacity = p.life * 0.85;\n\n      // Movimento\n      p.mesh.position.add(p.velocity);\n      const swirl = Math.cos(time * 1.8 + p.mesh.position.y) * 0.0008;\n      p.mesh.position.x += swirl;\n\n      // Rotação\n      p.mesh.rotation.x += p.rotationSpeed.x;\n      p.mesh.rotation.y += p.rotationSpeed.y;\n      p.mesh.rotation.z += p.rotationSpeed.z;\n\n      // Morte\n      if (p.life <= 0) {\n        groupRef.current?.remove(p.mesh);\n        p.mesh.geometry.dispose(); // Opcional se geometria for compartilhada, mas material foi clonado\n        (p.mesh.material as THREE.Material).dispose();\n        particlesRef.current.splice(i, 1);\n      }\n    }\n  });\n\n  return <group ref={groupRef} />;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 414, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/home/webgl/Fireflies.tsx"],"sourcesContent":["'use client';\n\nimport React, { useMemo, useRef } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { GhostParams } from './ghost/GhostParams';\n\nexport function Fireflies() {\n  const count = 20;\n  const groupRef = useRef<THREE.Group>(null);\n\n  // Dados estáticos iniciais\n  const initialData = useMemo(() => {\n    return new Array(count).fill(0).map(() => ({\n      position: new THREE.Vector3(\n        (Math.random() - 0.5) * 40,\n        (Math.random() - 0.5) * 30,\n        (Math.random() - 0.5) * 20\n      ),\n      velocity: new THREE.Vector3(\n        (Math.random() - 0.5) * GhostParams.fireflySpeed,\n        (Math.random() - 0.5) * GhostParams.fireflySpeed,\n        (Math.random() - 0.5) * GhostParams.fireflySpeed\n      ),\n      phase: Math.random() * Math.PI * 2,\n      pulseSpeed: 2 + Math.random() * 3,\n    }));\n  }, []);\n\n  useFrame((state) => {\n    if (!groupRef.current) return;\n    const time = state.clock.elapsedTime;\n\n    groupRef.current.children.forEach((child, i) => {\n      const data = initialData[i];\n      const firefly = child as THREE.Mesh;\n      const glow = firefly.children[0] as THREE.Mesh;\n      const light = firefly.children[1] as THREE.PointLight;\n\n      // Pulse\n      const pulsePhase = time + data.phase;\n      const pulse = Math.sin(pulsePhase * data.pulseSpeed) * 0.4 + 0.6;\n\n      // Update Opacity & Intensity\n      const glowMat = glow.material as THREE.MeshBasicMaterial;\n      const flyMat = firefly.material as THREE.MeshBasicMaterial;\n\n      glowMat.opacity = GhostParams.fireflyGlowIntensity * 0.4 * pulse;\n      flyMat.opacity = GhostParams.fireflyGlowIntensity * 0.9 * pulse;\n      light.intensity = GhostParams.fireflyGlowIntensity * 0.8 * pulse;\n\n      // Random Walk\n      data.velocity.x += (Math.random() - 0.5) * 0.001;\n      data.velocity.y += (Math.random() - 0.5) * 0.001;\n      data.velocity.z += (Math.random() - 0.5) * 0.001;\n      data.velocity.clampLength(0, GhostParams.fireflySpeed);\n\n      firefly.position.add(data.velocity);\n\n      // Bounds check\n      if (Math.abs(firefly.position.x) > 30) data.velocity.x *= -0.5;\n      if (Math.abs(firefly.position.y) > 20) data.velocity.y *= -0.5;\n      if (Math.abs(firefly.position.z) > 15) data.velocity.z *= -0.5;\n    });\n  });\n\n  return (\n    <group ref={groupRef}>\n      {initialData.map((data, i) => (\n        <mesh key={i} position={data.position}>\n          <sphereGeometry args={[0.02, 2, 2]} />\n          <meshBasicMaterial color=\"#ffff44\" transparent opacity={0.9} />\n\n          {/* Glow */}\n          <mesh>\n            <sphereGeometry args={[0.08, 8, 8]} />\n            <meshBasicMaterial\n              color=\"#ffff88\"\n              transparent\n              opacity={0.4}\n              side={THREE.BackSide}\n            />\n          </mesh>\n\n          {/* Light */}\n          <pointLight color=\"#ffff44\" distance={3} decay={2} intensity={0.8} />\n        </mesh>\n      ))}\n    </group>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/home/webgl/GhostCanvas.tsx"],"sourcesContent":["'use client';\n\nimport React, { Suspense, useRef, useState } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { EffectComposer, Bloom } from '@react-three/postprocessing';\nimport * as THREE from 'three';\n\nimport { GhostSphere } from './ghost/GhostSphere';\nimport { AtmosphereVeil } from './AtmosphereVeil';\nimport { Particles } from './Particles';\nimport { Fireflies } from './Fireflies';\nimport { AnalogDecayEffect } from './postprocessing/AnalogDecayPass';\nimport { GhostParams } from './ghost/GhostParams';\n\nexport default function GhostCanvas() {\n  const ghostPosRef = useRef(new THREE.Vector3(0, 0, 0));\n  const [isGhostMoving, setIsGhostMoving] = useState(false);\n  const [movementSpeed, setMovementSpeed] = useState(0);\n\n  const handleMovementUpdate = (moving: boolean, speed: number) => {\n    setIsGhostMoving(moving);\n    setMovementSpeed(speed);\n  };\n\n  return (\n    <div className=\"fixed inset-0 z-0 pointer-events-none\">\n      <Canvas\n        dpr={[1, 2]}\n        camera={{ position: [0, 0, 20], fov: 75 }}\n        gl={{\n          antialias: true,\n          alpha: true,\n          powerPreference: 'high-performance',\n          toneMapping: THREE.ACESFilmicToneMapping,\n          toneMappingExposure: 0.9,\n        }}\n      >\n        <Suspense fallback={null}>\n          <color attach=\"background\" args={['#000000']} />{' '}\n          {/* Fallback dark bg, or remove for transparent */}\n          {/* Lights */}\n          <ambientLight intensity={0.08} color=\"#0a0a2e\" />\n          <directionalLight\n            position={[-8, 6, -4]}\n            intensity={GhostParams.rimLightIntensity}\n            color=\"#4a90e2\"\n          />\n          <directionalLight\n            position={[8, -4, -6]}\n            intensity={GhostParams.rimLightIntensity * 0.7}\n            color=\"#50e3c2\"\n          />\n          {/* Scene Components */}\n          <GhostSphere\n            positionRef={ghostPosRef}\n            onMovementUpdate={handleMovementUpdate}\n          />\n          <AtmosphereVeil ghostPosition={ghostPosRef} />\n          <Particles\n            ghostPosition={ghostPosRef}\n            isGhostMoving={isGhostMoving}\n            movementSpeed={movementSpeed}\n          />\n          <Fireflies />\n          {/* Post Processing */}\n          <EffectComposer disableNormalPass>\n            <Bloom\n              luminanceThreshold={0.0}\n              mipmapBlur\n              intensity={0.3}\n              radius={0.5} // Ajuste fino pode ser necessário aqui\n            />\n            <AnalogDecayEffect />\n          </EffectComposer>\n        </Suspense>\n      </Canvas>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAZA;;;;;;;;;;;AAce,SAAS;;IACtB,MAAM,cAAc,IAAA,gXAAM,EAAC,IAAI,iNAAa,CAAC,GAAG,GAAG;IACnD,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,kXAAQ,EAAC;IACnD,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,kXAAQ,EAAC;IAEnD,MAAM,uBAAuB,CAAC,QAAiB;QAC7C,iBAAiB;QACjB,iBAAiB;IACnB;IAEA,qBACE,sYAAC;QAAI,WAAU;kBACb,cAAA,sYAAC,6ZAAM;YACL,KAAK;gBAAC;gBAAG;aAAE;YACX,QAAQ;gBAAE,UAAU;oBAAC;oBAAG;oBAAG;iBAAG;gBAAE,KAAK;YAAG;YACxC,IAAI;gBACF,WAAW;gBACX,OAAO;gBACP,iBAAiB;gBACjB,aAAa,+NAA2B;gBACxC,qBAAqB;YACvB;sBAEA,cAAA,sYAAC,kXAAQ;gBAAC,UAAU;;kCAClB,sYAAC;wBAAM,QAAO;wBAAa,MAAM;4BAAC;yBAAU;;;;;;oBAAK;kCAGjD,sYAAC;wBAAa,WAAW;wBAAM,OAAM;;;;;;kCACrC,sYAAC;wBACC,UAAU;4BAAC,CAAC;4BAAG;4BAAG,CAAC;yBAAE;wBACrB,WAAW,4KAAW,CAAC,iBAAiB;wBACxC,OAAM;;;;;;kCAER,sYAAC;wBACC,UAAU;4BAAC;4BAAG,CAAC;4BAAG,CAAC;yBAAE;wBACrB,WAAW,4KAAW,CAAC,iBAAiB,GAAG;wBAC3C,OAAM;;;;;;kCAGR,sYAAC,6KAAW;wBACV,aAAa;wBACb,kBAAkB;;;;;;kCAEpB,sYAAC,0KAAc;wBAAC,eAAe;;;;;;kCAC/B,sYAAC,gKAAS;wBACR,eAAe;wBACf,eAAe;wBACf,eAAe;;;;;;kCAEjB,sYAAC,gKAAS;;;;;kCAEV,sYAAC,kYAAc;wBAAC,iBAAiB;;0CAC/B,sYAAC,yXAAK;gCACJ,oBAAoB;gCACpB,UAAU;gCACV,WAAW;gCACX,QAAQ;;;;;;0CAEV,sYAAC,gMAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;AAM9B;GAhEwB;KAAA"}}]
}