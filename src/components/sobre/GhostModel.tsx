/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Noby Grand (https://sketchfab.com/NobyGrand)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/ghost-w-tophat-6b1217e3462440519a2d0e3e75bf16d3
Title: Ghost w/ Tophat
*/
import * as THREE from 'three';
import React, { useEffect, useMemo, useRef } from 'react';
import { useGLTF, Float } from '@react-three/drei';
import { useFrame, useThree } from '@react-three/fiber';
import { GLTF } from 'three-stdlib';
import { MotionValue } from 'framer-motion';

type GLTFResult = GLTF & {
  nodes: {
    Body_Ghost_White_0: THREE.Mesh;
    Eyes_Eyes_0: THREE.Mesh;
    Hat_Hat_Black_0: THREE.Mesh;
    Rim_Rim_Red_0: THREE.Mesh;
  };
  materials: {
    Ghost_White: THREE.MeshStandardMaterial;
    Eyes: THREE.MeshStandardMaterial;
    Hat_Black: THREE.MeshStandardMaterial;
    Rim_Red: THREE.MeshStandardMaterial;
  };
};

// Definição da interface com scrollProgress
interface GhostModelProps extends React.ComponentProps<'group'> {
  scrollProgress?: MotionValue<number>;
}

export function GhostModel({ scrollProgress, ...props }: GhostModelProps) {
  const { nodes, materials } = useGLTF(
    'https://umkmwbkwvulxtdodzmzf.supabase.co/storage/v1/object/public/site-assets/about/beliefs/ghost-transformed.glb'
  ) as unknown as GLTFResult;

  const { gl, viewport } = useThree();
  const groupRef = useRef<THREE.Group>(null);
  const animRef = useRef<THREE.Group>(null);
  const mouseRef = useRef({ x: 0, y: 0 });
  const basePosition = useMemo(() => {
    if (Array.isArray(props.position)) {
      const [x = 0, y = 0, z = 0] = props.position;
      return new THREE.Vector3(x, y, z);
    }
    if (props.position instanceof THREE.Vector3) {
      return props.position.clone();
    }
    return new THREE.Vector3(0, 0, 0);
  }, [props.position]);

  useEffect(() => {
    const handleMouseMove = (event: MouseEvent) => {
      if (gl.domElement) {
        const rect = gl.domElement.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        mouseRef.current = { x, y };
      }
    };
    const canvas = gl.domElement;
    canvas.addEventListener('mousemove', handleMouseMove);
    return () => canvas.removeEventListener('mousemove', handleMouseMove);
  }, [gl]);

  useEffect(() => {
    if (groupRef.current) {
      groupRef.current.position.copy(basePosition);
    }
  }, [basePosition]);

  // --- Responsividade (Policy 4.3) ---
  const isMobile = viewport.width < 5;
  const isTablet = viewport.width >= 5 && viewport.width < 8;

  // Escala responsiva: mobile menor, tablet médio, desktop maior
  const baseScale = isMobile
    ? viewport.width * 0.15  // Mobile: 15% da largura do viewport (menor)
    : isTablet
    ? viewport.width * 0.12  // Tablet: 12% da largura
    : viewport.width * 0.08; // Desktop: 8% da largura (proporcional)

  // Handle touch interactions simply by updating mouseRef
  useEffect(() => {
    const handleTouchMove = (e: TouchEvent) => {
      if (e.touches.length > 0 && gl.domElement) {
        const touch = e.touches[0];
        const rect = gl.domElement.getBoundingClientRect();
        const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
        mouseRef.current = { x, y };
      }
    };

    const canvas = gl.domElement;
    canvas.addEventListener('touchmove', handleTouchMove, { passive: true });
    return () => canvas.removeEventListener('touchmove', handleTouchMove);
  }, [gl]);

  useFrame((state) => {
    if (!animRef.current || !scrollProgress || !groupRef.current) return;

    const progress = scrollProgress.get();
    const mouse = mouseRef.current;

    // Manter o fantasma sempre centralizado independentemente do dispositivo
    const finalOffsetX = 0;
    const finalOffsetY = 0;

    groupRef.current.position.x = THREE.MathUtils.lerp(
      groupRef.current.position.x,
      basePosition.x + finalOffsetX,
      0.05
    );

    groupRef.current.position.y = THREE.MathUtils.lerp(
      groupRef.current.position.y,
      basePosition.y + finalOffsetY,
      0.05
    );

    // --- Animação Base ---
    // REMOVIDA ROTAÇÃO Y PELO SCROLL (Pedido: "não rotacione, fique sempre vista frontal")
    // animRef.current.rotation.y = -progress * Math.PI * 2;
    // Mantemos 0 ou uma rotação base fixa se necessário
    animRef.current.rotation.y = THREE.MathUtils.lerp(
      animRef.current.rotation.y,
      0,
      0.05
    );

    // --- Resposta ao Mouse/Scroll (Posição e Rotação) ---
    // Aumentar influência para tornar mais sensível como na home
    const mouseInfluence = 0.4; // Influência aumentada para movimento mais perceptível
    const scrollInfluence = 2.0; // Influência do scroll aumentada

    // Movimento lateral suave (side-to-side) com oscilação natural
    const time = state.clock.elapsedTime;
    const sideToSideOffset = Math.sin(time * 0.5) * 0.3; // Oscilação lenta lateral aumentada
    const upDownOffset = Math.sin(time * 0.7) * 0.2; // Oscilação vertical aumentada

    // Calcula movimento baseado no scroll para adicionar à posição
    const scrollX = (progress - 0.5) * scrollInfluence; // Usar o progresso do scroll para mover o ghost
    const scrollY = Math.sin(progress * Math.PI * 2) * scrollInfluence * 0.5; // Movimento vertical baseado no scroll

    // Lerp positions (relativo ao 0,0,0 do grupo pai)
    // Combina movimento do mouse com scroll e oscilação natural
    animRef.current.position.x = THREE.MathUtils.lerp(
      animRef.current.position.x,
      mouse.x * mouseInfluence + scrollX + sideToSideOffset,
      0.08 // Lerp mais rápido para resposta mais imediata
    );
    animRef.current.position.y = THREE.MathUtils.lerp(
      animRef.current.position.y,
      mouse.y * mouseInfluence + scrollY + upDownOffset,
      0.08 // Lerp mais rápido para resposta mais imediata
    );

    // Lerp rotações X e Z baseadas no mouse (Tilt mais perceptível)
    // RotationX: Inclina para cima/baixo
    animRef.current.rotation.x = THREE.MathUtils.lerp(
      animRef.current.rotation.x,
      -mouse.y * mouseInfluence * 0.8, // Tilt vertical mais perceptível
      0.08
    );

    // RotationZ: Inclina para os lados (Bank) com oscilação natural
    const naturalTilt = Math.sin(time * 0.6) * 0.1; // Balanço natural aumentado
    animRef.current.rotation.z = THREE.MathUtils.lerp(
      animRef.current.rotation.z,
      -mouse.x * mouseInfluence * 0.6 + naturalTilt, // Tilt horizontal mais perceptível
      0.08
    );

    let targetScale = 1; // Escala base interna (multiplicativa)

    // --- Efeitos de Final de Seção ---
    if (progress > 0.8) {
      const intensity = Math.min(1, (progress - 0.8) * 5);

      // Move Z para frente (aproximação)
      animRef.current.position.z = THREE.MathUtils.lerp(
        animRef.current.position.z,
        intensity,
        0.05
      );

      // Adiciona wobble extra ao Z (se desejado, mas mantendo frontalidade)
      // Manter wobble sutil
      const timeBasedWobble =
        Math.sin(state.clock.elapsedTime * 2) * 0.05 * intensity;
      animRef.current.rotation.z += timeBasedWobble;

      // Aumenta escala interna (zoom effect)
      targetScale = 1 + 0.1 * intensity;
    } else {
      // Retorna Z para 0
      animRef.current.position.z = THREE.MathUtils.lerp(
        animRef.current.position.z,
        0,
        0.05
      );
    }

    // Aplica escala interna (multiplicação sobre a escala base do grupo pai)
    animRef.current.scale.setScalar(targetScale);
  });

  return (
    <Float
      speed={1.5}              // Velocidade mais suave
      rotationIntensity={0.3}  // Rotação mais sutil
      floatIntensity={1.2}     // Flutuação mais pronunciada
      floatingRange={[-0.3, 0.3]} // Maior amplitude vertical (up-down)
    >
      {/* Grupo Pai: Recebe as props de posicionamento global, mas tem escala controlada responsivamente */}
      <group ref={groupRef} {...props} scale={baseScale} dispose={null}>
        {/* Grupo Interno: Recebe as animações (rotação, mouse sway) relativas ao pai */}
        <group ref={animRef}>
          <mesh
            name="Body_Ghost_White_0"
            castShadow
            receiveShadow
            geometry={nodes.Body_Ghost_White_0.geometry}
            material={materials.Ghost_White}
            position={[0, 1.5578, 0]}
            rotation={[-Math.PI / 2, 0, 0]}
          />
          <mesh
            name="Eyes_Eyes_0"
            castShadow
            receiveShadow
            geometry={nodes.Eyes_Eyes_0.geometry}
            material={materials.Eyes}
            position={[0, 1.5578, 0]}
            rotation={[-Math.PI / 2, 0, 0]}
          />
          <mesh
            name="Hat_Hat_Black_0"
            castShadow
            receiveShadow
            geometry={nodes.Hat_Hat_Black_0.geometry}
            material={materials.Hat_Black}
            position={[0, 2.9913, 0]}
            rotation={[-Math.PI / 2, 0, 0]}
          />
          <mesh
            name="Rim_Rim_Red_0"
            castShadow
            receiveShadow
            geometry={nodes.Rim_Rim_Red_0.geometry}
            material={materials.Rim_Red}
            position={[0, 2.3541, 0]}
            rotation={[-Math.PI / 2, 0, 0]}
          />
        </group>
      </group>
    </Float>
  );
}

// Preload only in the browser to avoid Node/SSG environments where
// Web Workers (used by meshopt decoding) are unavailable.
if (typeof window !== 'undefined') {
  useGLTF.preload(
    'https://umkmwbkwvulxtdodzmzf.supabase.co/storage/v1/object/public/site-assets/about/beliefs/ghost-transformed.glb'
  );
}