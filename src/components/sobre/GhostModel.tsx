/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Noby Grand (https://sketchfab.com/NobyGrand)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/ghost-w-tophat-6b1217e3462440519a2d0e3e75bf16d3
Title: Ghost w/ Tophat
*/
import * as THREE from 'three';
import React, { useEffect, useMemo, useRef } from 'react';
import { useGLTF } from '@react-three/drei';
import { useFrame, useThree } from '@react-three/fiber';
import { GLTF } from 'three-stdlib';
import { MotionValue, useReducedMotion } from 'framer-motion';

type GLTFResult = GLTF & {
  nodes: {
    Body_Ghost_White_0: THREE.Mesh;
    Eyes_Eyes_0: THREE.Mesh;
    Hat_Hat_Black_0: THREE.Mesh;
    Rim_Rim_Red_0: THREE.Mesh;
  };
  materials: {
    Ghost_White: THREE.MeshStandardMaterial;
    Eyes: THREE.MeshStandardMaterial;
    Hat_Black: THREE.MeshStandardMaterial;
    Rim_Red: THREE.MeshStandardMaterial;
  };
};

// Definição da interface com scrollProgress
interface GhostModelProps extends React.ComponentProps<'group'> {
  scrollProgress?: MotionValue<number>;
  scale?: number | [number, number, number];
}

const GHOST_URL =
  'https://umkmwbkwvulxtdodzmzf.supabase.co/storage/v1/object/public/site-assets/about/beliefs/ghost-transformed.glb';
const GHOST_MESH_ROTATION: [number, number, number] = [-Math.PI / 2, 0, 0];

export function GhostModel({ scrollProgress, ...props }: GhostModelProps) {
  const prefersReducedMotion = useReducedMotion();

  const { nodes, materials } = useGLTF(GHOST_URL) as unknown as GLTFResult;

  const { gl, viewport } = useThree();
  const groupRef = useRef<THREE.Group>(null);
  const animRef = useRef<THREE.Group>(null);
  const mouseRef = useRef({ x: 0, y: 0 });
  const basePosition = useMemo(() => {
    if (Array.isArray(props.position)) {
      const [x = 0, y = 0, z = 0] = props.position;
      return new THREE.Vector3(x, y, z);
    }
    if (props.position instanceof THREE.Vector3) {
      return props.position.clone();
    }
    return new THREE.Vector3(0, 0, 0);
  }, [props.position]);

  const ghostMaterial = useMemo(() => {
    const material = materials.Ghost_White.clone();
    material.color = new THREE.Color('#f6f8ff');
    material.emissive = new THREE.Color('#d9e4ff');
    material.emissiveIntensity = 0.06;
    material.roughness = 0.5;
    material.metalness = 0.02;
    return material;
  }, [materials.Ghost_White]);

  const eyesMaterial = useMemo(() => {
    const material = materials.Eyes.clone();
    material.color = new THREE.Color('#121212');
    material.roughness = 0.32;
    material.metalness = 0.01;
    return material;
  }, [materials.Eyes]);

  const hatMaterial = useMemo(() => {
    const material = materials.Hat_Black.clone();
    material.color = new THREE.Color('#06080d');
    material.roughness = 0.42;
    material.metalness = 0.16;
    material.emissive = new THREE.Color('#040915');
    material.emissiveIntensity = 0.1;
    return material;
  }, [materials.Hat_Black]);

  const rimMaterial = useMemo(() => {
    const material = materials.Rim_Red.clone();
    material.color = new THREE.Color('#ff3246');
    material.emissive = new THREE.Color('#ff2b57');
    material.emissiveIntensity = 0.22;
    material.roughness = 0.36;
    material.metalness = 0.08;
    return material;
  }, [materials.Rim_Red]);

  useEffect(() => {
    return () => {
      ghostMaterial.dispose();
      eyesMaterial.dispose();
      hatMaterial.dispose();
      rimMaterial.dispose();
    };
  }, [eyesMaterial, ghostMaterial, hatMaterial, rimMaterial]);

  useEffect(() => {
    if (prefersReducedMotion) return;
    const handleMouseMove = (event: MouseEvent) => {
      if (gl.domElement) {
        const rect = gl.domElement.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        mouseRef.current = { x, y };
      }
    };
    const canvas = gl.domElement;
    canvas.addEventListener('mousemove', handleMouseMove);
    return () => canvas.removeEventListener('mousemove', handleMouseMove);
  }, [gl, prefersReducedMotion]);

  useEffect(() => {
    if (groupRef.current) {
      groupRef.current.position.copy(basePosition);
    }
  }, [basePosition]);

  const isMobile = viewport.width < 5;
  const defaultScale = isMobile ? Math.min(1.02, viewport.width * 0.2) : 1.28;
  const baseScale: number | [number, number, number] =
    props.scale ?? defaultScale;

  useEffect(() => {
    if (prefersReducedMotion) return;
    const handleTouchMove = (e: TouchEvent) => {
      if (e.touches.length > 0 && gl.domElement) {
        const touch = e.touches[0];
        const rect = gl.domElement.getBoundingClientRect();
        const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
        mouseRef.current = { x, y };
      }
    };

    const canvas = gl.domElement;
    canvas.addEventListener('touchmove', handleTouchMove, { passive: true });
    return () => canvas.removeEventListener('touchmove', handleTouchMove);
  }, [gl, prefersReducedMotion]);

  useFrame((state) => {
    if (!animRef.current || !groupRef.current) return;

    const progress = scrollProgress?.get?.() ?? 0;
    const mouse = prefersReducedMotion ? { x: 0, y: 0 } : mouseRef.current;

    const desktopMouseX = viewport.width >= 5 ? mouse.x * 0.14 : 0;
    const mobileParallaxX = viewport.width < 5 ? mouse.x * 0.06 : 0;
    const targetContainerX = basePosition.x + desktopMouseX + mobileParallaxX;

    groupRef.current.position.x = THREE.MathUtils.lerp(
      groupRef.current.position.x,
      targetContainerX,
      0.05
    );
    groupRef.current.position.y = THREE.MathUtils.lerp(
      groupRef.current.position.y,
      basePosition.y,
      0.08
    );
    groupRef.current.position.z = THREE.MathUtils.lerp(
      groupRef.current.position.z,
      basePosition.z,
      0.08
    );

    const elapsedTime = state.clock.getElapsedTime();
    const floatY = prefersReducedMotion ? 0 : Math.sin(elapsedTime * 1.18) * 0.055;
    const floatX = prefersReducedMotion ? 0 : Math.cos(elapsedTime * 0.8) * 0.018;
    const scrollLift = prefersReducedMotion
      ? 0
      : THREE.MathUtils.clamp(progress * 0.14, 0, 0.14);
    const mobileLift = viewport.width < 5 ? 0.06 : 0;
    const targetY = mouse.y * 0.04 + floatY + scrollLift + mobileLift;
    const targetX = floatX;

    animRef.current.position.x = THREE.MathUtils.lerp(
      animRef.current.position.x,
      targetX,
      0.06
    );
    animRef.current.position.y = THREE.MathUtils.lerp(
      animRef.current.position.y,
      targetY,
      0.06
    );
    animRef.current.position.z = THREE.MathUtils.lerp(
      animRef.current.position.z,
      0,
      0.06
    );
    animRef.current.rotation.x = 0;
    animRef.current.rotation.y = 0;
    animRef.current.rotation.z = 0;
  });

  return (
    <group ref={groupRef} {...props} scale={baseScale} dispose={null}>
      <group ref={animRef}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Body_Ghost_White_0.geometry}
          material={ghostMaterial}
          position={[0, 1.558, 0]}
          rotation={GHOST_MESH_ROTATION}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Eyes_Eyes_0.geometry}
          material={eyesMaterial}
          position={[0, 1.558, 0]}
          rotation={GHOST_MESH_ROTATION}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Hat_Hat_Black_0.geometry}
          material={hatMaterial}
          position={[0, 2.991, 0]}
          rotation={GHOST_MESH_ROTATION}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Rim_Rim_Red_0.geometry}
          material={rimMaterial}
          position={[0, 2.354, 0]}
          rotation={GHOST_MESH_ROTATION}
        />
      </group>
    </group>
  );
}

// Preload only in the browser to avoid Node/SSG environments where
// Web Workers (used by meshopt decoding) are unavailable.
if (typeof window !== 'undefined') {
  useGLTF.preload(GHOST_URL);
}
